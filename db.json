{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/git学习整理.md","hash":"562e2ad1aa3a1b8bcee5d2095862dd3c53f0c64b","modified":1666965908042},{"_id":"source/_posts/别人不说-你一定要懂的人情世故.md","hash":"57601cac443396b9af1e582dc1f6afd073af7e48","modified":1666967952192},{"_id":"source/_posts/Win11中WSL2搭配ubuntu使用笔记.md","hash":"281b7604ae80d3d11a34e731451407d9e103224d","modified":1665908069313},{"_id":"source/_posts/人生的智慧.md","hash":"3709d51b405994788c9b557a990f8dd7a4b4f17d","modified":1666968274097},{"_id":"source/_posts/Hexo博客备份.md","hash":"229a9024c422bcb17d0dfe32171438a9700a7fef","modified":1666968674230},{"_id":"source/_posts/排序算法记录.md","hash":"6270c121a6a05499ef1056e5eaa5e63e6791b8d0","modified":1665908057689},{"_id":"source/_posts/基于GitHub和Hexo搭建博客.md","hash":"73a250a2f6502aba88807b016b511b1cc5758a73","modified":1666968674230},{"_id":"source/_posts/如何有效阅读一本书.md","hash":"9c293b61e193e13534ff8cbdc1fce035795be6fe","modified":1666968460546},{"_id":"source/_posts/操作系统原理.md","hash":"1522220f47baba88ddad895df66e306b9cc30093","modified":1667317996143},{"_id":"source/_posts/小狗钱钱.md","hash":"bf84a9857ecbc44b11637ce3b5e1478acbc6e307","modified":1666966679797},{"_id":"source/_posts/自控力.md","hash":"e489e3298b14845ceb16b862a73fab790223da06","modified":1665908064780},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计.md","hash":"afc3257d8c30cd07a1ba5cd9e2210d42b4b08a20","modified":1667316810446},{"_id":"source/_posts/胃靠养-肠靠清.md","hash":"6acdb55c32088da507d2a49c9d4495552d1d7964","modified":1666968674230},{"_id":"source/about/index.md","hash":"0f11cb24405ba2fe354d40cae7ac8da3afffc7b0","modified":1664204518291},{"_id":"source/_posts/读书与做人.md","hash":"d4c17c50ceb0cda6f6bbd079bff894962f06b991","modified":1665908096293},{"_id":"source/_posts/基于GitHub和Hexo搭建博客/组件版本.png","hash":"4be0aa74c9ab630ac3ed565e9523a83545b8cd7d","modified":1664204518289},{"_id":"source/_posts/Hexo博客备份/git文件.png","hash":"318c5a0160614de874b2361598891e4da2e4e806","modified":1666968674230},{"_id":"source/_posts/操作系统原理/10.jpg","hash":"911c403866424c7bf3aae76357b7edaaa234dbba","modified":1617457300000},{"_id":"source/_posts/git学习整理/1829507-20220316234843811-601091411.png","hash":"3c27a0309a05109b6b458fb47658ec29eb376522","modified":1664288196657},{"_id":"source/_posts/操作系统原理/1.jpg","hash":"e9009e2416b43218bddbb2a61ecab6723db700d6","modified":1615554916000},{"_id":"source/_posts/操作系统原理/2.jpg","hash":"e903006700c5208d1946aad5494c5ddfadb8b6d9","modified":1615556082000},{"_id":"source/_posts/操作系统原理/3.jpg","hash":"84f20ae202f8faac302a2792cc93957dd592a0ef","modified":1615635114000},{"_id":"source/_posts/操作系统原理/4.jpg","hash":"3b56b4b201c603a680ee13a107e546512764219f","modified":1615635434000},{"_id":"source/_posts/操作系统原理/6.jpg","hash":"ced30b8b8e6b1c99f329c0fe252fca00a12b1ac4","modified":1615636120000},{"_id":"source/_posts/操作系统原理/5.jpg","hash":"625ff05f256cf0444accc9423175de8586f7ce0a","modified":1615635790000},{"_id":"source/_posts/操作系统原理/7.jpg","hash":"a8c3a714c40b1779e99027c310ad99dd73d622d3","modified":1615637504000},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/2.jpg","hash":"4ca1d304fa1f141d44cfbcf2ae1a70fecee1aca3","modified":1613650744000},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/1.jpg","hash":"06a00a40cfc311b799cdf1d5edd39781d78deabd","modified":1613648750000},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/3.jpg","hash":"15e47ca82a4a0df18484e38db3dd672305f13706","modified":1613651524000},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/4.jpg","hash":"8df32ce7afdd10ebfb17d5e09e1afeef3a1e6ef9","modified":1613653048000},{"_id":"source/_posts/操作系统原理/9.jpg","hash":"e1b1705e51eeddad705fe33f0c57aa96f136c2ce","modified":1617456642000},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/6.jpg","hash":"93afdd412f4daba4e4bfea2b9241c8b0f1bb877e","modified":1613653308000},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/5.jpg","hash":"dfee673f109e97b63ae3769c0a90df28bff7a157","modified":1613653212000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1664204516099},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"1c05cec69cd3cf349b268f027a6916a9187601e0","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"c52ce73a291fa50953edbd11c1dfb1cc7cab52c2","modified":1664204516061},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"3e309acfd433067266c4f6c6e9e4726eb814d6c3","modified":1664204516061},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"2ec6a89d66f8e41fded68aa8ec3b3363a20ea48c","modified":1664204516061},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"2839da328f197cf90cafdf2b538fcd027ab6cfba","modified":1664204516061},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"511e49f0bd8282a0d002c527474da8e1e5add393","modified":1664204516060},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7fcd16cd363f1a166a3270c23c0660eff7475744","modified":1664204516062},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"76d2920b49c8d2489c37514489545d0fc4eac834","modified":1664204516061},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"b05d1a43516dc6886d65631d90d6995acae673db","modified":1664204516062},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"676b3ee8a16d796b4a898a9e5be2f52c372055ed","modified":1664204516063},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"aac765cccef9f9044c4a88941fd01ba1883178fc","modified":1664204516063},{"_id":"node_modules/hexo-theme-fluid/layout/.DS_Store","hash":"e2295dbe42d85b294e6f3aeefaf3623bd31759ed","modified":1664204516063},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"411aa49e2e8dea90a6d8cc2dc92f264609ea273b","modified":1664204516062},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"c524ce76747042ec2f9ed8d5025f80e01b462b3b","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"0a589faccde6c2c9572e8d3d359e7c8fb166335e","modified":1664204516063},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"838a68e210bddfca6d4ba070e1e2f1ca53cb7d06","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"264f68cbf826787e683a30e1377c56c0895c7386","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"bd3ede2a5f45c5256cf8f883bb8fcca645834869","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"8ba210724c023d45a4564415762f3da299bd1d0e","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"d4ffeb7eff398dea154340794bd277f75ddeedef","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"fbed4b3d1e475b3de9d8ce05362abcc658a53408","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"e87fc58829ea214ac16e8e4f13cd5c389133697b","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"33ee985aaf03c8839d8f48e38113e851705cb2db","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"b7c1a6d8fc1097fc16d2300260297013cb692153","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/.DS_Store","hash":"daec53fd4601c37ca272321ba2eb594d9b0a43ac","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/source/.DS_Store","hash":"e11e97632e6d13d5b9dccadcc514268f3c039508","modified":1664204516089},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"78c34e32746041f23678669bbadfbede15e4c6d2","modified":1664204516063},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"508254a648d8597e62e4012c8beab44bfa82e904","modified":1664204516064},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"bfea4674af78eb72b3a6baaa7ec9fc3c3db55ebd","modified":1664204516064},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"52b8954ae0eff5eb66a3841b37f144336b8f0866","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"5a712dded014ff5a5ffea79fb0e30b429ae715c7","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"3668304d08c48b68d532532921a12069a2736150","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"70646e7f7a7684e12b298cd8a36fbea2814c3635","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"b5cd435b27f090939b6051bef41a38a3376044ac","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"3ca4c60a38b6b895986b15128a668266b1b12009","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"57a0f61242d9ce2bd2c51b2f84193f6dc1377ef9","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0d443f23c459787338917900f50fec1c8b3b3bdd","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"6c3b24207e4ea3ae4edeb715af40ef23711b92b9","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bc9ba08d1d871394ee1c3a1cc2f21dc343f515a","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"96af7e55fdbe0819bacc554ecbfe42375a088df6","modified":1664204516084},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"00a41768fe258bb8f3323bf4bb0b862d6e2d97c0","modified":1664204516084},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"f9821f7789ea6f069977a8c642aa5ccb6d19077c","modified":1664204516084},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"9219d59c51930c7a82fcde918d6efbc5aa572ea2","modified":1664204516084},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"49b2c6449d7be35739c6cfea3cab4e790580983a","modified":1664204516084},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"f713ddb6c8018ec7b96d3567057f1f932609beea","modified":1664204516085},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"a93b87835bfa491fa2aa90f97f25281e3a4ffed9","modified":1664204516085},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"d7ff7cf5e721dfeafe0c2a77a5929b2c3f8fee2a","modified":1664204516085},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"9c01393f446c490c56b6b0d482aaa8d97cc8b717","modified":1664204516086},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"bda7fbe58082a2a02c0db066794b791b14462271","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"a2a15ea722863aba09dcad578558432682a3b6b3","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"3d30c722b9e24c33577d6fab822628841fadf992","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"2340a576635b16fd2456b3494f5afe89cd7764db","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"1c9156e12030fa2219a933edde460ec563836047","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"e1d0caed12e7cd9a35cf64272c41854b2901a58f","modified":1664204516086},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"aa03d0b914d87b9194ee3a0612ab5827a8dedbdd","modified":1664204516086},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"cc176cc1d7e7cc28cedf8397ae748c691d140be2","modified":1664204516087},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"6c5916d86c63795c7e910bf614b0e7ece5073702","modified":1664204516087},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"dbfe59fde77d87b1d7d0c46480a2a729010988eb","modified":1664204516087},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"8020acc2c4bb3a2054e3cb349fac7cd10b79a0be","modified":1664204516087},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"bd763ffc145a1f0b2c4a5dc8a101f0bc94b3f2f7","modified":1664204516064},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"37f90bd4e35ce49457dc2a348b9f66e0b242c014","modified":1664204516088},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"3e03b534e2e92a6e17567b006d7e3eaad4b37598","modified":1664204516089},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"a5d70005913ab03cea0a0dc601097628b4dbd5a8","modified":1664204516089},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"dbdb10b23fcd3928e86a4cb46fa3455e060b4aa0","modified":1664204516089},{"_id":"node_modules/hexo-theme-fluid/scripts/events/.DS_Store","hash":"80308812974d7cb7e001cd8f64ff9fced30ff139","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"c74d7aed425d20f2fa096f386a9521b67b9ab269","modified":1664204516100},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1664204516088},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"9e9171325bb7148c11ceee283d00c137c8a1c5c5","modified":1664204516101},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"57ce8b8f95ab1f40612a9dce1793de5ab9b4bbfc","modified":1664204516101},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3f92a93cb12e01f5ce54bc941fa6626b3ee2571a","modified":1664204516109},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"1fe60b2ab1d704f5a4f55e700dca5b8785fb390e","modified":1664204516099},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"67f6250f98b36a6599ea982d11cbb060c5ffb92a","modified":1664204516110},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"1ab61ed47ec88c876e447872342fed9be560b0f0","modified":1664204516111},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"31d35fe044ad01dda7975d47c99d636eaa81bfc8","modified":1664204516110},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"7d70feed0a19e3d9f5886416ae99a72e21e2f10c","modified":1664204516110},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"89fc9f663a1091911b79ab9697c09446d16184f9","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1664204516102},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1664204516103},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"e9ad1b5659f0af867174687daa0ecf4375e40b75","modified":1664204516110},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"61e8108fe16fbf19ce13ea89b3120c1191bb4665","modified":1664204516112},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1664204516108},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"5f33939016d0a7bb72d4376af46ebb28fbf85c04","modified":1664204516111},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1664204516109},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1664204516108},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1664204516112},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"0c410ef79785897c8de3da333b057a2936fd569b","modified":1664204516064},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"66995ec9dab10ed35c2a775010c447113c6848d4","modified":1664204516065},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"1e93ca89777e4beb0f0e5cb70e03aab48e958542","modified":1664204516064},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"7f04e5c22821bb94da791973d9c6692b03bac81d","modified":1664204516065},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"79ec17eec6e15076c685688e740230e92c66efa9","modified":1664204516064},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"1568d377cd1d214be50a6560197c185ead0f7740","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"45c879768b40ba56af62e18ad54bffbf73a6f3a1","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"ef04d4fc3f26588ae9d8712938d648304fc05455","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"bcceafab01fe695c59951d939f7cef502f3d7b48","modified":1664204516065},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"d7bcc183fc31af643e7835b13da10fe2ab8614ce","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"99fe072ec17e83332325b3c59464bd39ea1f5a96","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"a84d8dcb44f5f6289ef09db4d02ab14de72c2c87","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"ed2348bd9f56d19836b508c52ce9cc9122471f51","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"3b31e068f394c3f63a98843711e64ac4af463fef","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"77d0c9df31a22ed8a3e341637bde4165a11a7ce9","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"3900e54ade140e0e49c571a1955f0b1f3a59b281","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"502b99e19e496825df7032ca2b0b1a95ebb2b357","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"76a224723775388d3fbb0433b32dfb5dcbc75a4c","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"03c7c69fbb1754fdccfa18671aac23b8637b869e","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"1560b1ca7f1f40fe1e18047ab68a3576f6613619","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"fedcfb5de65c0828f6925d60a758e0c79a45396f","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"887292388acb8e90c1a7a415a82d128d881f8c9d","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"47c1df255aa552ad71ef3e57deca46530a8f2802","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"eac44cfb6b0843304b2da35b32b0fa24afd9d7f9","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"7bf29bd9faf12030e19993576299936a999c0e46","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"db4ecdcc762bb1b1bae5060f0baa6115174779ff","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"ea10caef2e655200e275b70d40d464e34123d10b","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"f9c0f25eee37cc6e72a5fbefb2cd7284a9fd16d7","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"ac544baecc05df96c6558d42b57af219e1d59e52","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"31208a0db986ba864f756a8ec806b7d254440f9b","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"235dc1c2f7086dcdb9a2091cd219ef2a37aebfa4","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"92123b7280695b4ac6650f5e1d7fa0d772c71f5b","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"c9efdd41b8606969e5b55f49a2f6df596641b995","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"3f06fd3a865a703eed67aac30692d2c4b348d3a6","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"c9696633f77dd8055e900497469f9e64eca4d97f","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"ec6bf395ccad3dd41f29dc0080aeabf413e30fd9","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"2507cdad08f61cf8c1d9b0ca7f4f1dc8c4e5841b","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"171697018fd384fce0834875ca94b91f16564cac","modified":1664204516090},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"046979dbd8cdabd21d89f9c1d8f1bb3f2fd06d6f","modified":1664204516090},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"77cda31b5434b75ff7ac600f60a97918bc389616","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"92c062cf55457b6549497244d09ec34e9c0c95c2","modified":1664204516099},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"e3846fb429f6732bd15fde40f7c28b3492d786c8","modified":1664204516091},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"9ea66cf79f1e4356b6b402bc3dc5fb55c9862f1f","modified":1664204516099},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"8ba5fb6a8ced1de6f7893184bf12f4021fe22595","modified":1664204516091},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"7d50d2ae4b8b736a764fcce21ec456fa6b72518c","modified":1664204516097},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"7f95c49025a347605c726b0874fe074d888e1cc2","modified":1664204516096},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"4263f7b930e6b57e13295d17fd3745a9e5c52494","modified":1664204516096},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"577f3289d7f3851d4eeb867db3d92f1313a431da","modified":1664204516096},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"d3aeb7bf22d52d7dde59b292090ef8b46943718a","modified":1664204516096},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"cd255079553985722ee80fb1833f6507dde52194","modified":1664204516095},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"58a7f8f2baea2d58cf5f7edfc91314ee5d7156ca","modified":1664204516096},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"1fc96d09d52d9502e84e4e2a8d482ea45e8b81ea","modified":1664204516098},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"96c3bb95dea4b3d3ecd20b810a674bfcef04870c","modified":1664204516096},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4bd2449fb8a3620229f0862a3b499faf1eedf2fd","modified":1664204516098},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"e8fe053ef8734e54fae12e46acd0087bcd67f8a2","modified":1664204516098},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"2d12f23b46d0ce07ae810bc4f5635c490a098fa4","modified":1664204516098},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"2e44047b9fecf662696b9cfce5c77ac3376cda85","modified":1664204516098},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"d3ef491fd449d89a1b95801dee788a5d9bec4320","modified":1664204516097},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"29e9b72cfda2f2baf9cf2597fcd7f9e66303a9bd","modified":1664204516099},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"80301db38e448e40e88bb34d0128628b0809b243","modified":1664204516092},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"1068d71721baeed76bf0176f9b964d36b5764c9f","modified":1664204516092},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"417a7388b39c0203178b0032e151febd66a0e9f3","modified":1664204516092},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"26d65475b1c52a61115044db8883df6739c3a473","modified":1664204516091},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"41935973a66c14ab2bea0539d4b1f15c62534fa4","modified":1664204516093},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"30f50446609d49c896e92a89225591b606adc863","modified":1664204516094},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"e6f5921ff9009c1853e7db30c482bc1682433ed9","modified":1664204516093},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"cef058fd6f33651118b5bdaa3c814757f5c82154","modified":1664204516068},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"0ca6171ce262339e0e36cfea0978b554d87ae7fc","modified":1664204516094},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"48799d3148ef6493be0e05897c635124e9b05d03","modified":1664204516094},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"3ac1eb36e124adef607775aa505386d5680960e2","modified":1664204516092},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"8fad325e411bc83c8ebdc4115015477eed5f60da","modified":1664204516094},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"04447d3b673be84a1af1dc57933a3c41dd7c0cfe","modified":1664204516095},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"f4ae7cbf2f10f459de7864f8e642553b587df889","modified":1664204516095},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4dbbbb1a2508a72bc04680552d7ebbea0eed0fe","modified":1664204516095},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"1f4e678d7219815ab62de1b92ec75e021247f90b","modified":1664204516095},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"5defef321e3e933fe84f3f2ca481c88f55381fb0","modified":1664204516095},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"1f0b11c14f117e4636f929e472a1e87d06841acb","modified":1664204516107},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1664204516105},{"_id":"public/local-search.xml","hash":"891ea075d159ebc6066b09912de4f6f4b9c991e1","modified":1667318002338},{"_id":"public/about/index.html","hash":"55df8a6cccf75d2f3e18c69955af0ceb5c011bce","modified":1667318002338},{"_id":"public/archives/index.html","hash":"3f8b5699fed63472de7af0a6c777f4acd91fe04e","modified":1667318002338},{"_id":"public/archives/page/2/index.html","hash":"493488446e9655c770cbcdc30af03cb3559c7b6d","modified":1667318002338},{"_id":"public/archives/2022/index.html","hash":"fe77f836653a2fc2af10638ac877fe9f445e7164","modified":1667318002338},{"_id":"public/archives/2022/page/2/index.html","hash":"e4d9334b6bafe3ff190f0c56d01a152334e1dd33","modified":1667318002338},{"_id":"public/archives/2022/09/index.html","hash":"461eaa8072b5a97bb458e7ba54f0c436ec8822e5","modified":1667318002338},{"_id":"public/archives/2022/10/index.html","hash":"78aeeefff3282e6cb0640e6eaaea1035e94b4aa9","modified":1667318002338},{"_id":"public/archives/2022/11/index.html","hash":"3a401fc88c0b5358721e9b18af6f84256a720aa1","modified":1667318002338},{"_id":"public/categories/linux/index.html","hash":"f8046b72be66a352625736873df9e7ab8748b58b","modified":1667318002338},{"_id":"public/categories/读书/index.html","hash":"41835481e8730ead4da2774100554be2849716e2","modified":1667318002338},{"_id":"public/categories/其他/index.html","hash":"12df7edc30bfc1ad35e3b7710e5dbdd7e0b768dd","modified":1667318002338},{"_id":"public/categories/vcs/index.html","hash":"cd367d68f64cd47a24015e4951bcfa3061fb2713","modified":1667318002338},{"_id":"public/categories/数据结构与算法/index.html","hash":"7d8c8f17012c4c214432fba5d9cadc728f6f8a46","modified":1667318002338},{"_id":"public/tags/ubuntu/index.html","hash":"d2cdab2299468cb539d404f2dc55b42ee32bb11f","modified":1667318002338},{"_id":"public/tags/读书与做人/index.html","hash":"0b281974e862367238e56817f18674c0b023abf4","modified":1667318002338},{"_id":"public/tags/博客搭建/index.html","hash":"89fdc9977118ed665dfab031ce2d62fbba66bf8e","modified":1667318002338},{"_id":"public/tags/git/index.html","hash":"30c0c6dbabb986362385b562282060223635f38b","modified":1667318002338},{"_id":"public/tags/心理/index.html","hash":"6a215ed03b1b99d5d9e795d5c2dd6d010136f2dc","modified":1667318002338},{"_id":"public/tags/理财/index.html","hash":"ebfe6eed0c1938d4eb8105ea80390015411c68f0","modified":1667318002338},{"_id":"public/tags/排序/index.html","hash":"2381ac69b863580dd01a9534656fa1f9155d1a70","modified":1667318002338},{"_id":"public/tags/养生/index.html","hash":"f492d83830b6f9c2a0bcdf8183f813f80d769fd8","modified":1667318002338},{"_id":"public/tags/计算机结构/index.html","hash":"a2def2827a2f4c96e6367ae28c7b7cbdc326122f","modified":1667318002338},{"_id":"public/tags/操作系统/index.html","hash":"54e9d8e2c63527fee21e675d95ed5024e828e46c","modified":1667318002338},{"_id":"public/404.html","hash":"ca4afca4e4bb785b1cd197c51b73c0d91308d789","modified":1667318002338},{"_id":"public/tags/index.html","hash":"0cc82d5fcad1c9bac687b86c8cac20f20a4067ad","modified":1667318002338},{"_id":"public/links/index.html","hash":"46879f274a7cf3b520b8da7dad41d894f5752f2d","modified":1667318002338},{"_id":"public/2022/11/01/操作系统原理/index.html","hash":"9dedb6299826eb10d93117e18a85d4196b4832f1","modified":1667318002338},{"_id":"public/2022/11/01/计算机组成原理与汇编语言程序设计/index.html","hash":"149ab19988a5cdb68c10d1f006dc49dd8c8e9a90","modified":1667318002338},{"_id":"public/2022/10/28/别人不说-你一定要懂的人情世故/index.html","hash":"3d2fb339800cadc704c7bc50bf82fe1f72ccab51","modified":1667318002338},{"_id":"public/2022/10/28/小狗钱钱/index.html","hash":"db832563d1b824845ff2283734531674e3433e74","modified":1667318002338},{"_id":"public/2022/10/14/排序算法记录/index.html","hash":"e3eb9c14f6c9f98deb13fae3a4f27eeac2a48755","modified":1667318002338},{"_id":"public/2022/10/09/胃靠养-肠靠清/index.html","hash":"b5fa06938434974c720755996bbcfe431b86a12b","modified":1667318002338},{"_id":"public/2022/10/08/Hexo博客备份/index.html","hash":"d0baf25ffbd8fa5c37b654b9301a6a1ce0f59ab8","modified":1667318002338},{"_id":"public/2022/09/25/git学习整理/index.html","hash":"945eb9997deba011303190608d0c1312ad02b668","modified":1667318002338},{"_id":"public/2022/09/17/Win11中WSL2搭配ubuntu使用笔记/index.html","hash":"34c2076aaf85cc815f8a6cd698bd04b62d00c6a2","modified":1667318002338},{"_id":"public/2022/09/11/人生的智慧/index.html","hash":"2d3ff0979b8b52afe424dccd467cc1efa15efcc6","modified":1667318002338},{"_id":"public/2022/09/11/读书与做人/index.html","hash":"d3e0f0901e2949173ab083c35db8862b3db83ad0","modified":1667318002338},{"_id":"public/2022/09/11/自控力/index.html","hash":"9d659aa2005ac2b50d719959d69e1ad9d6038fd1","modified":1667318002338},{"_id":"public/2022/09/11/如何有效阅读一本书/index.html","hash":"6e2e2206b2c6139f720c67e44d998bb61a1b2337","modified":1667318002338},{"_id":"public/2022/09/06/基于GitHub和Hexo搭建博客/index.html","hash":"e4dbc12c4755b4855e5d65a030599846a902a53d","modified":1667318002338},{"_id":"public/index.html","hash":"e8a1f24e6e786bac24e8684202dc0ffa9049ea30","modified":1667318002338},{"_id":"public/page/2/index.html","hash":"3467a5bfaed4cf1867587268b3e54cdf1c3771e2","modified":1667318002338},{"_id":"public/categories/index.html","hash":"a199b6ea3c261e824844f4aecdfc1c9c5d8eaea4","modified":1667318002338},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1667318002338},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1667318002338},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1667318002338},{"_id":"public/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1667318002338},{"_id":"public/2022/10/08/Hexo博客备份/git文件.png","hash":"318c5a0160614de874b2361598891e4da2e4e806","modified":1667318002338},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1667318002338},{"_id":"public/2022/09/25/git学习整理/1829507-20220316234843811-601091411.png","hash":"3c27a0309a05109b6b458fb47658ec29eb376522","modified":1667318002338},{"_id":"public/2022/09/06/基于GitHub和Hexo搭建博客/组件版本.png","hash":"4be0aa74c9ab630ac3ed565e9523a83545b8cd7d","modified":1667318002338},{"_id":"public/2022/11/01/计算机组成原理与汇编语言程序设计/1.jpg","hash":"06a00a40cfc311b799cdf1d5edd39781d78deabd","modified":1667318002338},{"_id":"public/2022/11/01/计算机组成原理与汇编语言程序设计/3.jpg","hash":"15e47ca82a4a0df18484e38db3dd672305f13706","modified":1667318002338},{"_id":"public/2022/11/01/计算机组成原理与汇编语言程序设计/2.jpg","hash":"4ca1d304fa1f141d44cfbcf2ae1a70fecee1aca3","modified":1667318002338},{"_id":"public/2022/11/01/计算机组成原理与汇编语言程序设计/5.jpg","hash":"dfee673f109e97b63ae3769c0a90df28bff7a157","modified":1667318002338},{"_id":"public/2022/11/01/计算机组成原理与汇编语言程序设计/4.jpg","hash":"8df32ce7afdd10ebfb17d5e09e1afeef3a1e6ef9","modified":1667318002338},{"_id":"public/2022/11/01/计算机组成原理与汇编语言程序设计/6.jpg","hash":"93afdd412f4daba4e4bfea2b9241c8b0f1bb877e","modified":1667318002338},{"_id":"public/2022/11/01/操作系统原理/10.jpg","hash":"911c403866424c7bf3aae76357b7edaaa234dbba","modified":1667318002338},{"_id":"public/2022/11/01/操作系统原理/1.jpg","hash":"e9009e2416b43218bddbb2a61ecab6723db700d6","modified":1667318002338},{"_id":"public/2022/11/01/操作系统原理/2.jpg","hash":"e903006700c5208d1946aad5494c5ddfadb8b6d9","modified":1667318002338},{"_id":"public/2022/11/01/操作系统原理/4.jpg","hash":"3b56b4b201c603a680ee13a107e546512764219f","modified":1667318002338},{"_id":"public/2022/11/01/操作系统原理/3.jpg","hash":"84f20ae202f8faac302a2792cc93957dd592a0ef","modified":1667318002338},{"_id":"public/2022/11/01/操作系统原理/5.jpg","hash":"625ff05f256cf0444accc9423175de8586f7ce0a","modified":1667318002338},{"_id":"public/2022/11/01/操作系统原理/7.jpg","hash":"a8c3a714c40b1779e99027c310ad99dd73d622d3","modified":1667318002338},{"_id":"public/2022/11/01/操作系统原理/6.jpg","hash":"ced30b8b8e6b1c99f329c0fe252fca00a12b1ac4","modified":1667318002338},{"_id":"public/2022/11/01/操作系统原理/9.jpg","hash":"e1b1705e51eeddad705fe33f0c57aa96f136c2ce","modified":1667318002338},{"_id":"public/css/highlight-dark.css","hash":"2b0daa6e5343da9dbb26d617d224b8397e48556b","modified":1667318002338},{"_id":"public/css/highlight.css","hash":"0f9a477d33d3b15ebe7e163e756fb7c54c7ded6b","modified":1667318002338},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1667318002338},{"_id":"public/js/boot.js","hash":"2848f8eb5081a7f0550fbd76dc06d3ff877f1913","modified":1667318002338},{"_id":"public/js/color-schema.js","hash":"ba63f7c3324bc1fdd050a90add9d8faaffc27e07","modified":1667318002338},{"_id":"public/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1667318002338},{"_id":"public/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1667318002338},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1667318002338},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1667318002338},{"_id":"public/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1667318002338},{"_id":"public/js/plugins.js","hash":"2333494add51e5e1374602a4e81f0be36a05d4c2","modified":1667318002338},{"_id":"public/css/main.css","hash":"f7ce6ed5308c621930136e91fe5e47d1ad91130b","modified":1667318002338},{"_id":"public/img/favicon.png","hash":"1f0b11c14f117e4636f929e472a1e87d06841acb","modified":1667318002338},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1667318002338}],"Category":[{"name":"linux","_id":"cl9ye38vt0003q8t74l8qg7ee"},{"name":"读书","_id":"cl9ye38vx0008q8t74p5q0w71"},{"name":"其他","_id":"cl9ye38w0000eq8t7e2p04vzu"},{"name":"vcs","_id":"cl9ye38w4000lq8t71bm0472k"},{"name":"数据结构与算法","_id":"cl9ye38wb0013q8t7ea7yao8m"}],"Data":[],"Page":[{"title":"about atree","layout":"about atree","_content":"","source":"about/index.md","raw":"---\ntitle: about atree\nlayout: about atree\n---\n","date":"2022-09-26T15:01:58.291Z","updated":"2022-09-26T15:01:58.291Z","path":"about/index.html","comments":1,"_id":"cl9ye38vl0000q8t7hzq1f3y5","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""}],"Post":[{"title":"Win11中WSL2搭配ubuntu使用笔记","date":"2022-09-17T15:05:49.000Z","_content":"\n# 背景\n\n在surface go 3上基于WSL2装了一个ubuntu玩玩，记录下相关信息\n\n# 安装步骤\n\n[Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu](https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview)\n\n## WSL命令\n\n- cmd键入以下命令以查看所有正在运行的WSL，然后按Enter：\n\n`wsl --list --verbose`\n\n- cmd关闭所有的后台的linux虚拟机\n\n`wsl --shutdown`\n\n* 重新启动linux虚拟机\n\n如果需要重新启动Linux发行版，只需从开始菜单或使用`wsl --distribution DISTRO-NAME`命令在命令提示符下再次将其打开。请记住将DISTRO-NAME替换为发行版的实际名称。\n\n# 命令\n\n## 基本命令\n\n* 系统升级\n\n`sudo apt update`\n\n`sudo apt full-upgrade`\n\n* 文件传输（图形化界面）\n\n`explorer.exe .`\n\n* 查看Linux内核版本命令\n\n`cat /proc/version`\n\n* 查看Linux系统版本\n\n`cat /etc/issue`\n\n# 参考资料\n\n[Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu](https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview)\n\n[只需一条命令，快速在Windows 10上关闭Linux - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/351880793)\n","source":"_posts/Win11中WSL2搭配ubuntu使用笔记.md","raw":"---\ntitle: Win11中WSL2搭配ubuntu使用笔记\ndate: 2022-09-17 23:05:49\ncategories: \n- linux\ntags: \n- ubuntu\n---\n\n# 背景\n\n在surface go 3上基于WSL2装了一个ubuntu玩玩，记录下相关信息\n\n# 安装步骤\n\n[Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu](https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview)\n\n## WSL命令\n\n- cmd键入以下命令以查看所有正在运行的WSL，然后按Enter：\n\n`wsl --list --verbose`\n\n- cmd关闭所有的后台的linux虚拟机\n\n`wsl --shutdown`\n\n* 重新启动linux虚拟机\n\n如果需要重新启动Linux发行版，只需从开始菜单或使用`wsl --distribution DISTRO-NAME`命令在命令提示符下再次将其打开。请记住将DISTRO-NAME替换为发行版的实际名称。\n\n# 命令\n\n## 基本命令\n\n* 系统升级\n\n`sudo apt update`\n\n`sudo apt full-upgrade`\n\n* 文件传输（图形化界面）\n\n`explorer.exe .`\n\n* 查看Linux内核版本命令\n\n`cat /proc/version`\n\n* 查看Linux系统版本\n\n`cat /etc/issue`\n\n# 参考资料\n\n[Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu](https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview)\n\n[只需一条命令，快速在Windows 10上关闭Linux - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/351880793)\n","slug":"Win11中WSL2搭配ubuntu使用笔记","published":1,"updated":"2022-10-16T08:14:29.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38vo0001q8t7dtwj6q7b","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>在surface go 3上基于WSL2装了一个ubuntu玩玩，记录下相关信息</p>\n<h1 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h1><p><a href=\"https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview\">Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu</a></p>\n<h2 id=\"WSL命令\"><a href=\"#WSL命令\" class=\"headerlink\" title=\"WSL命令\"></a>WSL命令</h2><ul>\n<li>cmd键入以下命令以查看所有正在运行的WSL，然后按Enter：</li>\n</ul>\n<p><code>wsl --list --verbose</code></p>\n<ul>\n<li>cmd关闭所有的后台的linux虚拟机</li>\n</ul>\n<p><code>wsl --shutdown</code></p>\n<ul>\n<li>重新启动linux虚拟机</li>\n</ul>\n<p>如果需要重新启动Linux发行版，只需从开始菜单或使用<code>wsl --distribution DISTRO-NAME</code>命令在命令提示符下再次将其打开。请记住将DISTRO-NAME替换为发行版的实际名称。</p>\n<h1 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h1><h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><ul>\n<li>系统升级</li>\n</ul>\n<p><code>sudo apt update</code></p>\n<p><code>sudo apt full-upgrade</code></p>\n<ul>\n<li>文件传输（图形化界面）</li>\n</ul>\n<p><code>explorer.exe .</code></p>\n<ul>\n<li>查看Linux内核版本命令</li>\n</ul>\n<p><code>cat /proc/version</code></p>\n<ul>\n<li>查看Linux系统版本</li>\n</ul>\n<p><code>cat /etc/issue</code></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview\">Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/351880793\">只需一条命令，快速在Windows 10上关闭Linux - 知乎 (zhihu.com)</a></p>\n","site":{"data":{}},"wordcount":507,"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>在surface go 3上基于WSL2装了一个ubuntu玩玩，记录下相关信息</p>\n<h1 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h1><p><a href=\"https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview\">Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu</a></p>\n<h2 id=\"WSL命令\"><a href=\"#WSL命令\" class=\"headerlink\" title=\"WSL命令\"></a>WSL命令</h2><ul>\n<li>cmd键入以下命令以查看所有正在运行的WSL，然后按Enter：</li>\n</ul>\n<p><code>wsl --list --verbose</code></p>\n<ul>\n<li>cmd关闭所有的后台的linux虚拟机</li>\n</ul>\n<p><code>wsl --shutdown</code></p>\n<ul>\n<li>重新启动linux虚拟机</li>\n</ul>\n<p>如果需要重新启动Linux发行版，只需从开始菜单或使用<code>wsl --distribution DISTRO-NAME</code>命令在命令提示符下再次将其打开。请记住将DISTRO-NAME替换为发行版的实际名称。</p>\n<h1 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h1><h2 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h2><ul>\n<li>系统升级</li>\n</ul>\n<p><code>sudo apt update</code></p>\n<p><code>sudo apt full-upgrade</code></p>\n<ul>\n<li>文件传输（图形化界面）</li>\n</ul>\n<p><code>explorer.exe .</code></p>\n<ul>\n<li>查看Linux内核版本命令</li>\n</ul>\n<p><code>cat /proc/version</code></p>\n<ul>\n<li>查看Linux系统版本</li>\n</ul>\n<p><code>cat /etc/issue</code></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview\">Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/351880793\">只需一条命令，快速在Windows 10上关闭Linux - 知乎 (zhihu.com)</a></p>\n"},{"title":"人生的智慧","date":"2022-09-11T14:00:57.000Z","_content":"\n# 信息\n\n《人生的智慧》 阿图尔·叔本华 湖南人民出版社\n\n# 摘录\n\n- 幸福的首要因素，甚至，一个人此生存在的主要意义，是由他的内在机制决定的；一个人内心满足与否，取决于他的情感、欲望和思想共同作用的结果，外在环境对人只起到了间接调节的作用。我们年轻时几乎意识不到的一点是，最高级最丰富且最持久的乐趣来源于思想，思想力量的强弱决定了乐趣大小。身外之物对幸福的影响太微弱，大多数无须为生计发愁的人们由于内在贫乏，跟那些生活在底层为生计奔波劳碌的人们一样的感觉不幸福。他们头脑空洞、想象力贫瘠、精神空虚，只好与跟自己相似的人为伍，正所谓“物以类聚，人以群分”——他们聚在一起追求消遣娱乐，纵情感官享受，最后以荒唐告终。\n- 幸福的本质在于“人”，那么集中精力保持身体健康、培养能力，无疑要比一心积累财富更明智，但千万不要误以为我们就应该忽略掉对生活必需品的获取。身心健康是幸福的首要关键，最愚蠢的事就是牺牲自己的健康去追求任何其他一时的快活，不管是为了利益、升迁、学问还是名气，甚至为了转瞬即逝的感官乐趣糟蹋自己的健康，都是愚不可及的行为。\n- 实际上，生活就像是钟摆一般，在这两端之间或激烈或温和地来回摇摆——要么痛苦，要么无聊，反正总有一项逃不掉。究其根源，痛苦和无聊是一种双重对立的存在，一是外部的或客观的，一是内在的或主观的。匮乏的环境和贫穷会导致痛苦；而一个人衣食无忧，那么他就会无聊。这样的不幸只能靠内在的力量，亦即精神财富来抵御。\n- 人类有两大最常见的愚蠢，第一是“不是在他自身的本质中去寻求幸福，而是在别人看待‘他是什么’中求幸福”，就是说太在意别人的看法，为别人而活。第二是牺牲健康去谋求别的东西，不明白一个健康的乞丐比疾病的国王要幸福。“人是什么”比“人有什么”，要重要得多。在是否幸福这件事情上，个人的人格、气质、心态、信仰，比汽车、房子、珠宝等更为重要。也就是说，你的个性才是最宝贵的财富。你需要去追求物质、名誉，但你更需要追求的，是你独立而健康的个性。正是在这个意义上，叔本华才会说：“个性远比民族性更重要。最廉价的骄傲是民族骄傲，也就是所谓的‘民族自豪感’——如果一个人号称为他的国家或民族自豪，那只能说明他本身并没有什么可值得骄傲的，否则也不会抓着那些千百万人共有的东西引以为荣了。”\n\n# 感想\n\n幸福的本质在于“人”。首先是需要保障身体健康，保持适当的锻炼，任何事情都要给健康让路，不管是利益、升迁、学问还是名气；其次需要持之以恒地提升内心精神境界并汲取知识，去观赏大自然的鬼斧神工和历史上的伟大成就，像雕琢艺术品一样构建自己的内心世界；不要过多地在意外界的看法，克制嫉妒等不良情绪，减少不必要的痛苦.\n","source":"_posts/人生的智慧.md","raw":"---\ntitle: 人生的智慧\ndate: 2022-09-11 22:00:57\ncategories: \n- 读书\ntags: \n- 读书与做人\n---\n\n# 信息\n\n《人生的智慧》 阿图尔·叔本华 湖南人民出版社\n\n# 摘录\n\n- 幸福的首要因素，甚至，一个人此生存在的主要意义，是由他的内在机制决定的；一个人内心满足与否，取决于他的情感、欲望和思想共同作用的结果，外在环境对人只起到了间接调节的作用。我们年轻时几乎意识不到的一点是，最高级最丰富且最持久的乐趣来源于思想，思想力量的强弱决定了乐趣大小。身外之物对幸福的影响太微弱，大多数无须为生计发愁的人们由于内在贫乏，跟那些生活在底层为生计奔波劳碌的人们一样的感觉不幸福。他们头脑空洞、想象力贫瘠、精神空虚，只好与跟自己相似的人为伍，正所谓“物以类聚，人以群分”——他们聚在一起追求消遣娱乐，纵情感官享受，最后以荒唐告终。\n- 幸福的本质在于“人”，那么集中精力保持身体健康、培养能力，无疑要比一心积累财富更明智，但千万不要误以为我们就应该忽略掉对生活必需品的获取。身心健康是幸福的首要关键，最愚蠢的事就是牺牲自己的健康去追求任何其他一时的快活，不管是为了利益、升迁、学问还是名气，甚至为了转瞬即逝的感官乐趣糟蹋自己的健康，都是愚不可及的行为。\n- 实际上，生活就像是钟摆一般，在这两端之间或激烈或温和地来回摇摆——要么痛苦，要么无聊，反正总有一项逃不掉。究其根源，痛苦和无聊是一种双重对立的存在，一是外部的或客观的，一是内在的或主观的。匮乏的环境和贫穷会导致痛苦；而一个人衣食无忧，那么他就会无聊。这样的不幸只能靠内在的力量，亦即精神财富来抵御。\n- 人类有两大最常见的愚蠢，第一是“不是在他自身的本质中去寻求幸福，而是在别人看待‘他是什么’中求幸福”，就是说太在意别人的看法，为别人而活。第二是牺牲健康去谋求别的东西，不明白一个健康的乞丐比疾病的国王要幸福。“人是什么”比“人有什么”，要重要得多。在是否幸福这件事情上，个人的人格、气质、心态、信仰，比汽车、房子、珠宝等更为重要。也就是说，你的个性才是最宝贵的财富。你需要去追求物质、名誉，但你更需要追求的，是你独立而健康的个性。正是在这个意义上，叔本华才会说：“个性远比民族性更重要。最廉价的骄傲是民族骄傲，也就是所谓的‘民族自豪感’——如果一个人号称为他的国家或民族自豪，那只能说明他本身并没有什么可值得骄傲的，否则也不会抓着那些千百万人共有的东西引以为荣了。”\n\n# 感想\n\n幸福的本质在于“人”。首先是需要保障身体健康，保持适当的锻炼，任何事情都要给健康让路，不管是利益、升迁、学问还是名气；其次需要持之以恒地提升内心精神境界并汲取知识，去观赏大自然的鬼斧神工和历史上的伟大成就，像雕琢艺术品一样构建自己的内心世界；不要过多地在意外界的看法，克制嫉妒等不良情绪，减少不必要的痛苦.\n","slug":"人生的智慧","published":1,"updated":"2022-10-28T14:44:34.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38vr0002q8t71du74pcd","content":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《人生的智慧》 阿图尔·叔本华 湖南人民出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li>幸福的首要因素，甚至，一个人此生存在的主要意义，是由他的内在机制决定的；一个人内心满足与否，取决于他的情感、欲望和思想共同作用的结果，外在环境对人只起到了间接调节的作用。我们年轻时几乎意识不到的一点是，最高级最丰富且最持久的乐趣来源于思想，思想力量的强弱决定了乐趣大小。身外之物对幸福的影响太微弱，大多数无须为生计发愁的人们由于内在贫乏，跟那些生活在底层为生计奔波劳碌的人们一样的感觉不幸福。他们头脑空洞、想象力贫瘠、精神空虚，只好与跟自己相似的人为伍，正所谓“物以类聚，人以群分”——他们聚在一起追求消遣娱乐，纵情感官享受，最后以荒唐告终。</li>\n<li>幸福的本质在于“人”，那么集中精力保持身体健康、培养能力，无疑要比一心积累财富更明智，但千万不要误以为我们就应该忽略掉对生活必需品的获取。身心健康是幸福的首要关键，最愚蠢的事就是牺牲自己的健康去追求任何其他一时的快活，不管是为了利益、升迁、学问还是名气，甚至为了转瞬即逝的感官乐趣糟蹋自己的健康，都是愚不可及的行为。</li>\n<li>实际上，生活就像是钟摆一般，在这两端之间或激烈或温和地来回摇摆——要么痛苦，要么无聊，反正总有一项逃不掉。究其根源，痛苦和无聊是一种双重对立的存在，一是外部的或客观的，一是内在的或主观的。匮乏的环境和贫穷会导致痛苦；而一个人衣食无忧，那么他就会无聊。这样的不幸只能靠内在的力量，亦即精神财富来抵御。</li>\n<li>人类有两大最常见的愚蠢，第一是“不是在他自身的本质中去寻求幸福，而是在别人看待‘他是什么’中求幸福”，就是说太在意别人的看法，为别人而活。第二是牺牲健康去谋求别的东西，不明白一个健康的乞丐比疾病的国王要幸福。“人是什么”比“人有什么”，要重要得多。在是否幸福这件事情上，个人的人格、气质、心态、信仰，比汽车、房子、珠宝等更为重要。也就是说，你的个性才是最宝贵的财富。你需要去追求物质、名誉，但你更需要追求的，是你独立而健康的个性。正是在这个意义上，叔本华才会说：“个性远比民族性更重要。最廉价的骄傲是民族骄傲，也就是所谓的‘民族自豪感’——如果一个人号称为他的国家或民族自豪，那只能说明他本身并没有什么可值得骄傲的，否则也不会抓着那些千百万人共有的东西引以为荣了。”</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>幸福的本质在于“人”。首先是需要保障身体健康，保持适当的锻炼，任何事情都要给健康让路，不管是利益、升迁、学问还是名气；其次需要持之以恒地提升内心精神境界并汲取知识，去观赏大自然的鬼斧神工和历史上的伟大成就，像雕琢艺术品一样构建自己的内心世界；不要过多地在意外界的看法，克制嫉妒等不良情绪，减少不必要的痛苦.</p>\n","site":{"data":{}},"wordcount":1091,"excerpt":"","more":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《人生的智慧》 阿图尔·叔本华 湖南人民出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li>幸福的首要因素，甚至，一个人此生存在的主要意义，是由他的内在机制决定的；一个人内心满足与否，取决于他的情感、欲望和思想共同作用的结果，外在环境对人只起到了间接调节的作用。我们年轻时几乎意识不到的一点是，最高级最丰富且最持久的乐趣来源于思想，思想力量的强弱决定了乐趣大小。身外之物对幸福的影响太微弱，大多数无须为生计发愁的人们由于内在贫乏，跟那些生活在底层为生计奔波劳碌的人们一样的感觉不幸福。他们头脑空洞、想象力贫瘠、精神空虚，只好与跟自己相似的人为伍，正所谓“物以类聚，人以群分”——他们聚在一起追求消遣娱乐，纵情感官享受，最后以荒唐告终。</li>\n<li>幸福的本质在于“人”，那么集中精力保持身体健康、培养能力，无疑要比一心积累财富更明智，但千万不要误以为我们就应该忽略掉对生活必需品的获取。身心健康是幸福的首要关键，最愚蠢的事就是牺牲自己的健康去追求任何其他一时的快活，不管是为了利益、升迁、学问还是名气，甚至为了转瞬即逝的感官乐趣糟蹋自己的健康，都是愚不可及的行为。</li>\n<li>实际上，生活就像是钟摆一般，在这两端之间或激烈或温和地来回摇摆——要么痛苦，要么无聊，反正总有一项逃不掉。究其根源，痛苦和无聊是一种双重对立的存在，一是外部的或客观的，一是内在的或主观的。匮乏的环境和贫穷会导致痛苦；而一个人衣食无忧，那么他就会无聊。这样的不幸只能靠内在的力量，亦即精神财富来抵御。</li>\n<li>人类有两大最常见的愚蠢，第一是“不是在他自身的本质中去寻求幸福，而是在别人看待‘他是什么’中求幸福”，就是说太在意别人的看法，为别人而活。第二是牺牲健康去谋求别的东西，不明白一个健康的乞丐比疾病的国王要幸福。“人是什么”比“人有什么”，要重要得多。在是否幸福这件事情上，个人的人格、气质、心态、信仰，比汽车、房子、珠宝等更为重要。也就是说，你的个性才是最宝贵的财富。你需要去追求物质、名誉，但你更需要追求的，是你独立而健康的个性。正是在这个意义上，叔本华才会说：“个性远比民族性更重要。最廉价的骄傲是民族骄傲，也就是所谓的‘民族自豪感’——如果一个人号称为他的国家或民族自豪，那只能说明他本身并没有什么可值得骄傲的，否则也不会抓着那些千百万人共有的东西引以为荣了。”</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>幸福的本质在于“人”。首先是需要保障身体健康，保持适当的锻炼，任何事情都要给健康让路，不管是利益、升迁、学问还是名气；其次需要持之以恒地提升内心精神境界并汲取知识，去观赏大自然的鬼斧神工和历史上的伟大成就，像雕琢艺术品一样构建自己的内心世界；不要过多地在意外界的看法，克制嫉妒等不良情绪，减少不必要的痛苦.</p>\n"},{"title":"Hexo博客备份","date":"2022-10-08T14:55:38.000Z","_content":"\n# 1 概述\n\n《基于GitHub和Hexo搭建博客》中总结了如何利用github和hexo搭建个人博客，但是github上上传的只是博客网站文件，像markdown笔记之类的源文件并没有备份，如果本地电脑坏了很难恢复以往的markdown笔记，所以需要连同markdown笔记在内的源文件都备份到github上。\n\n# 2 备份步骤\n\n## 2.1 创建新分支\n\n在github上的博客所在仓库上创建一个用来备份的分支hexo，并且将其设置为默认分支。\n\n## 2.2 获取git信息文件\n\n去桌面或者哪里随便一个地方，把刚刚的hexo分支给clone下来。然后剪切出里面的.git文件夹，复制到现在的博客文件夹中。\n\n![](./Hexo博客备份/git文件.png)\n\n## 2.3 添加 .[gitignore](https://so.csdn.net/so/search?q=gitignore&spm=1001.2101.3001.7020)\n\n用来在上传时候忽略一些文件，即不上传`.gitignore`中忽略的文件。如果有最好，没有的话自己手动添加。\n\n```\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/\n.deploy*/\n```\n\n**注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。**\n\n## 2.4 备份\n\n在hexo博客的根目录下执行\n\n```\n$ git add .\n$ git commit -m \"Backup\"\n$ git push origin hexo\n```\n\n这样就备份完博客了且在Github上能看到两个分支(main和hexo)。\n\n## 2.5 备份习惯\n\n```\nhexo clean\ngit add .\ngit commit -m \"Backup\"\ngit push\nhexo g\nhexo d\n```\n\n# 3 恢复步骤\n\n## 3.1 环境准备\n\n安装git 、nodejs，确保github公钥接入，参考《基于GitHub和Hexo搭建博客》\n\n## 3.2 克隆项目到本地\n\n输入下列命令克隆博客必须文件(hexo分支)：\n\n```\n$ git clone https://xxxxx(详见仓库链接)\n```\n\n## 3.3 博客恢复\n\n在clone下来的那个文件夹里面执行\n\n```\n$ npm install hexo-cli\n$ npm install\n$ npm install hexo-deployer-git –save\n$ rm -rf .deploy_git\n```\n\n然后再去安装原来安装的一些插件。**在此不需要执行hexo init这条指令，因为不是从零搭建起新博客。\n\n后续正常写博客，执行以下命令即可\n\n```\nhexo n xx\nhexo clean\nhexo g\nhexo d\n```\n\n# 4 参考\n\n[【Hexo异常】fatal: in unpopulated submodule '.deploy_git'_nomasp的博客-CSDN博客](https://blog.csdn.net/NoMasp/article/details/79504699)\n\n[ Hexo博客的备份_fFee-ops的博客-CSDN博客_hexo备份](https://blog.csdn.net/qq_21040559/article/details/109702142)\n","source":"_posts/Hexo博客备份.md","raw":"---\ntitle: Hexo博客备份\ndate: 2022-10-08 22:55:38\ncategories: \n- 其他\ntags: \n- 博客搭建\n---\n\n# 1 概述\n\n《基于GitHub和Hexo搭建博客》中总结了如何利用github和hexo搭建个人博客，但是github上上传的只是博客网站文件，像markdown笔记之类的源文件并没有备份，如果本地电脑坏了很难恢复以往的markdown笔记，所以需要连同markdown笔记在内的源文件都备份到github上。\n\n# 2 备份步骤\n\n## 2.1 创建新分支\n\n在github上的博客所在仓库上创建一个用来备份的分支hexo，并且将其设置为默认分支。\n\n## 2.2 获取git信息文件\n\n去桌面或者哪里随便一个地方，把刚刚的hexo分支给clone下来。然后剪切出里面的.git文件夹，复制到现在的博客文件夹中。\n\n![](./Hexo博客备份/git文件.png)\n\n## 2.3 添加 .[gitignore](https://so.csdn.net/so/search?q=gitignore&spm=1001.2101.3001.7020)\n\n用来在上传时候忽略一些文件，即不上传`.gitignore`中忽略的文件。如果有最好，没有的话自己手动添加。\n\n```\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/\n.deploy*/\n```\n\n**注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。**\n\n## 2.4 备份\n\n在hexo博客的根目录下执行\n\n```\n$ git add .\n$ git commit -m \"Backup\"\n$ git push origin hexo\n```\n\n这样就备份完博客了且在Github上能看到两个分支(main和hexo)。\n\n## 2.5 备份习惯\n\n```\nhexo clean\ngit add .\ngit commit -m \"Backup\"\ngit push\nhexo g\nhexo d\n```\n\n# 3 恢复步骤\n\n## 3.1 环境准备\n\n安装git 、nodejs，确保github公钥接入，参考《基于GitHub和Hexo搭建博客》\n\n## 3.2 克隆项目到本地\n\n输入下列命令克隆博客必须文件(hexo分支)：\n\n```\n$ git clone https://xxxxx(详见仓库链接)\n```\n\n## 3.3 博客恢复\n\n在clone下来的那个文件夹里面执行\n\n```\n$ npm install hexo-cli\n$ npm install\n$ npm install hexo-deployer-git –save\n$ rm -rf .deploy_git\n```\n\n然后再去安装原来安装的一些插件。**在此不需要执行hexo init这条指令，因为不是从零搭建起新博客。\n\n后续正常写博客，执行以下命令即可\n\n```\nhexo n xx\nhexo clean\nhexo g\nhexo d\n```\n\n# 4 参考\n\n[【Hexo异常】fatal: in unpopulated submodule '.deploy_git'_nomasp的博客-CSDN博客](https://blog.csdn.net/NoMasp/article/details/79504699)\n\n[ Hexo博客的备份_fFee-ops的博客-CSDN博客_hexo备份](https://blog.csdn.net/qq_21040559/article/details/109702142)\n","slug":"Hexo博客备份","published":1,"updated":"2022-10-28T14:51:14.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38vv0005q8t7ah2uhgtk","content":"<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h1><p>《基于GitHub和Hexo搭建博客》中总结了如何利用github和hexo搭建个人博客，但是github上上传的只是博客网站文件，像markdown笔记之类的源文件并没有备份，如果本地电脑坏了很难恢复以往的markdown笔记，所以需要连同markdown笔记在内的源文件都备份到github上。</p>\n<h1 id=\"2-备份步骤\"><a href=\"#2-备份步骤\" class=\"headerlink\" title=\"2 备份步骤\"></a>2 备份步骤</h1><h2 id=\"2-1-创建新分支\"><a href=\"#2-1-创建新分支\" class=\"headerlink\" title=\"2.1 创建新分支\"></a>2.1 创建新分支</h2><p>在github上的博客所在仓库上创建一个用来备份的分支hexo，并且将其设置为默认分支。</p>\n<h2 id=\"2-2-获取git信息文件\"><a href=\"#2-2-获取git信息文件\" class=\"headerlink\" title=\"2.2 获取git信息文件\"></a>2.2 获取git信息文件</h2><p>去桌面或者哪里随便一个地方，把刚刚的hexo分支给clone下来。然后剪切出里面的.git文件夹，复制到现在的博客文件夹中。</p>\n<p><img src=\"/2022/10/08/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/git%E6%96%87%E4%BB%B6.png\"></p>\n<h2 id=\"2-3-添加-gitignore\"><a href=\"#2-3-添加-gitignore\" class=\"headerlink\" title=\"2.3 添加 .gitignore\"></a>2.3 添加 .<a href=\"https://so.csdn.net/so/search?q=gitignore&spm=1001.2101.3001.7020\">gitignore</a></h2><p>用来在上传时候忽略一些文件，即不上传<code>.gitignore</code>中忽略的文件。如果有最好，没有的话自己手动添加。</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\"><span class=\"hljs-meta\">.DS_Store</span><br>Thumbs<span class=\"hljs-number\">.</span><span class=\"hljs-built_in\">db</span><br><span class=\"hljs-built_in\">db</span><span class=\"hljs-number\">.</span>json<br>*.log<br>node_modules/<br><span class=\"hljs-meta\">public</span>/<br><span class=\"hljs-meta\">.deploy</span>*/<br></code></pre></td></tr></table></figure>\n\n<p><strong>注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。</strong></p>\n<h2 id=\"2-4-备份\"><a href=\"#2-4-备份\" class=\"headerlink\" title=\"2.4 备份\"></a>2.4 备份</h2><p>在hexo博客的根目录下执行</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-variable\">$ </span>git add .<br><span class=\"hljs-variable\">$ </span>git commit -m <span class=\"hljs-string\">&quot;Backup&quot;</span><br><span class=\"hljs-variable\">$ </span>git push origin hexo<br></code></pre></td></tr></table></figure>\n\n<p>这样就备份完博客了且在Github上能看到两个分支(main和hexo)。</p>\n<h2 id=\"2-5-备份习惯\"><a href=\"#2-5-备份习惯\" class=\"headerlink\" title=\"2.5 备份习惯\"></a>2.5 备份习惯</h2><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">hexo</span> clean<br><span class=\"hljs-symbol\">git</span> <span class=\"hljs-keyword\">add</span> .<br><span class=\"hljs-symbol\">git</span> commit -m <span class=\"hljs-string\">&quot;Backup&quot;</span><br><span class=\"hljs-symbol\">git</span> <span class=\"hljs-keyword\">push</span><br><span class=\"hljs-symbol\">hexo</span> g<br><span class=\"hljs-symbol\">hexo</span> d<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"3-恢复步骤\"><a href=\"#3-恢复步骤\" class=\"headerlink\" title=\"3 恢复步骤\"></a>3 恢复步骤</h1><h2 id=\"3-1-环境准备\"><a href=\"#3-1-环境准备\" class=\"headerlink\" title=\"3.1 环境准备\"></a>3.1 环境准备</h2><p>安装git 、nodejs，确保github公钥接入，参考《基于GitHub和Hexo搭建博客》</p>\n<h2 id=\"3-2-克隆项目到本地\"><a href=\"#3-2-克隆项目到本地\" class=\"headerlink\" title=\"3.2 克隆项目到本地\"></a>3.2 克隆项目到本地</h2><p>输入下列命令克隆博客必须文件(hexo分支)：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">$ git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">https</span>://xxxxx(详见仓库链接)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-博客恢复\"><a href=\"#3-3-博客恢复\" class=\"headerlink\" title=\"3.3 博客恢复\"></a>3.3 博客恢复</h2><p>在clone下来的那个文件夹里面执行</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-variable\">$</span> npm install hexo<span class=\"hljs-literal\">-cli</span><br><span class=\"hljs-variable\">$</span> npm install<br><span class=\"hljs-variable\">$</span> npm install hexo<span class=\"hljs-literal\">-deployer-git</span> –save<br><span class=\"hljs-variable\">$</span> <span class=\"hljs-built_in\">rm</span> <span class=\"hljs-literal\">-rf</span> .deploy_git<br></code></pre></td></tr></table></figure>\n\n<p>然后再去安装原来安装的一些插件。**在此不需要执行hexo init这条指令，因为不是从零搭建起新博客。</p>\n<p>后续正常写博客，执行以下命令即可</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">hexo <span class=\"hljs-built_in\">n</span> xx<br>hexo <span class=\"hljs-built_in\">clean</span><br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"4-参考\"><a href=\"#4-参考\" class=\"headerlink\" title=\"4 参考\"></a>4 参考</h1><p><a href=\"https://blog.csdn.net/NoMasp/article/details/79504699\">【Hexo异常】fatal: in unpopulated submodule ‘.deploy_git’_nomasp的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/qq_21040559/article/details/109702142\"> Hexo博客的备份_fFee-ops的博客-CSDN博客_hexo备份</a></p>\n","site":{"data":{}},"wordcount":1155,"excerpt":"","more":"<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1 概述\"></a>1 概述</h1><p>《基于GitHub和Hexo搭建博客》中总结了如何利用github和hexo搭建个人博客，但是github上上传的只是博客网站文件，像markdown笔记之类的源文件并没有备份，如果本地电脑坏了很难恢复以往的markdown笔记，所以需要连同markdown笔记在内的源文件都备份到github上。</p>\n<h1 id=\"2-备份步骤\"><a href=\"#2-备份步骤\" class=\"headerlink\" title=\"2 备份步骤\"></a>2 备份步骤</h1><h2 id=\"2-1-创建新分支\"><a href=\"#2-1-创建新分支\" class=\"headerlink\" title=\"2.1 创建新分支\"></a>2.1 创建新分支</h2><p>在github上的博客所在仓库上创建一个用来备份的分支hexo，并且将其设置为默认分支。</p>\n<h2 id=\"2-2-获取git信息文件\"><a href=\"#2-2-获取git信息文件\" class=\"headerlink\" title=\"2.2 获取git信息文件\"></a>2.2 获取git信息文件</h2><p>去桌面或者哪里随便一个地方，把刚刚的hexo分支给clone下来。然后剪切出里面的.git文件夹，复制到现在的博客文件夹中。</p>\n<p><img src=\"/2022/10/08/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/git%E6%96%87%E4%BB%B6.png\"></p>\n<h2 id=\"2-3-添加-gitignore\"><a href=\"#2-3-添加-gitignore\" class=\"headerlink\" title=\"2.3 添加 .gitignore\"></a>2.3 添加 .<a href=\"https://so.csdn.net/so/search?q=gitignore&spm=1001.2101.3001.7020\">gitignore</a></h2><p>用来在上传时候忽略一些文件，即不上传<code>.gitignore</code>中忽略的文件。如果有最好，没有的话自己手动添加。</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs x86asm\"><span class=\"hljs-meta\">.DS_Store</span><br>Thumbs<span class=\"hljs-number\">.</span><span class=\"hljs-built_in\">db</span><br><span class=\"hljs-built_in\">db</span><span class=\"hljs-number\">.</span>json<br>*.log<br>node_modules/<br><span class=\"hljs-meta\">public</span>/<br><span class=\"hljs-meta\">.deploy</span>*/<br></code></pre></td></tr></table></figure>\n\n<p><strong>注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。</strong></p>\n<h2 id=\"2-4-备份\"><a href=\"#2-4-备份\" class=\"headerlink\" title=\"2.4 备份\"></a>2.4 备份</h2><p>在hexo博客的根目录下执行</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-variable\">$ </span>git add .<br><span class=\"hljs-variable\">$ </span>git commit -m <span class=\"hljs-string\">&quot;Backup&quot;</span><br><span class=\"hljs-variable\">$ </span>git push origin hexo<br></code></pre></td></tr></table></figure>\n\n<p>这样就备份完博客了且在Github上能看到两个分支(main和hexo)。</p>\n<h2 id=\"2-5-备份习惯\"><a href=\"#2-5-备份习惯\" class=\"headerlink\" title=\"2.5 备份习惯\"></a>2.5 备份习惯</h2><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-symbol\">hexo</span> clean<br><span class=\"hljs-symbol\">git</span> <span class=\"hljs-keyword\">add</span> .<br><span class=\"hljs-symbol\">git</span> commit -m <span class=\"hljs-string\">&quot;Backup&quot;</span><br><span class=\"hljs-symbol\">git</span> <span class=\"hljs-keyword\">push</span><br><span class=\"hljs-symbol\">hexo</span> g<br><span class=\"hljs-symbol\">hexo</span> d<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"3-恢复步骤\"><a href=\"#3-恢复步骤\" class=\"headerlink\" title=\"3 恢复步骤\"></a>3 恢复步骤</h1><h2 id=\"3-1-环境准备\"><a href=\"#3-1-环境准备\" class=\"headerlink\" title=\"3.1 环境准备\"></a>3.1 环境准备</h2><p>安装git 、nodejs，确保github公钥接入，参考《基于GitHub和Hexo搭建博客》</p>\n<h2 id=\"3-2-克隆项目到本地\"><a href=\"#3-2-克隆项目到本地\" class=\"headerlink\" title=\"3.2 克隆项目到本地\"></a>3.2 克隆项目到本地</h2><p>输入下列命令克隆博客必须文件(hexo分支)：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">$ git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">https</span>://xxxxx(详见仓库链接)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-博客恢复\"><a href=\"#3-3-博客恢复\" class=\"headerlink\" title=\"3.3 博客恢复\"></a>3.3 博客恢复</h2><p>在clone下来的那个文件夹里面执行</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-variable\">$</span> npm install hexo<span class=\"hljs-literal\">-cli</span><br><span class=\"hljs-variable\">$</span> npm install<br><span class=\"hljs-variable\">$</span> npm install hexo<span class=\"hljs-literal\">-deployer-git</span> –save<br><span class=\"hljs-variable\">$</span> <span class=\"hljs-built_in\">rm</span> <span class=\"hljs-literal\">-rf</span> .deploy_git<br></code></pre></td></tr></table></figure>\n\n<p>然后再去安装原来安装的一些插件。**在此不需要执行hexo init这条指令，因为不是从零搭建起新博客。</p>\n<p>后续正常写博客，执行以下命令即可</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">hexo <span class=\"hljs-built_in\">n</span> xx<br>hexo <span class=\"hljs-built_in\">clean</span><br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"4-参考\"><a href=\"#4-参考\" class=\"headerlink\" title=\"4 参考\"></a>4 参考</h1><p><a href=\"https://blog.csdn.net/NoMasp/article/details/79504699\">【Hexo异常】fatal: in unpopulated submodule ‘.deploy_git’_nomasp的博客-CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/qq_21040559/article/details/109702142\"> Hexo博客的备份_fFee-ops的博客-CSDN博客_hexo备份</a></p>\n"},{"title":"git学习整理","date":"2022-09-25T12:06:06.000Z","_content":"\n# 创建版本库\n\n版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n初始化一个Git仓库，使用`git init`命令。\n\n添加文件到Git仓库，分两步：\n\n1. 使用命令`git add 文件名`，注意，可反复多次使用，添加多个文件，此时文件放到了缓存区；\n2. 使用命令`git commit -m \"提交信息\"`，完成，此时文件从缓存区被放到了head指定的当前分支中。\n\n# 查看工作区状态与提交修改\n\n要随时掌握工作区的状态，使用`git status`命令。\n\n如果git status告诉你有文件被修改过，用`git diff`可以查看修改内容。\n\n提交修改与添加文件的步骤一样\n\n```\n git add 文件名\n git commit -m \"add a line\"\n```\n\n将暂存区的版本提交到版本库,从而形成工作区->暂存区->版本库的基本链路,本地工作区的版本控制流程大致如此.\n\n# 版本切换\n\nHEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`（commit_id可以输入前几位就行）。\n\n穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。\n\n要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。\n\n# 多次修改\n\n第一次修改 -> git add -> 第二次修改 -> git add -> git commit\n\n# 修改撤销\n\n- 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file`。\n- 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD` ，就回到了场景1，第二步按场景1操作。\n- 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考**版本切换**一节，不过前提是没有推送到远程库。\n\n# 删除文件\n\n如果在本地删除了文件，可以通过以下操作在git库里删除  \n\n`git rm test.txt`  \n\n`git commit -m \"remove test.txt\"`  \n\n可以通过以下操作恢复，相当于是让工作目录test.txt恢复到暂存区中test.txt的状态\n\n`git checkout -- test.txt`\n\n# 添加远程库\n\n**git连接GitHub的操作可以见《Windows环境基于GitHub和Hexo搭建个人博客》的2.2节**\n\n把本地库的内容推送到远程，用git push命令，实际上是把指定分支推送到远程。  \n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n1. 要关联一个远程库，使用命令\n   \n   ```\n   git remote add origin git@server-name:path/repo-name.git\n   ```\n   \n   例如：\n   \n   ```\n   git remote add origin git@github.com:michaelliao/learngit.git\n   ```\n\n2. 关联后，使用命令`git push -u origin master`第一次推送master分支的所有内容；\n\n3. 此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改；\n\n# 克隆远程库\n\nGit支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。以下是拉去默认分支的内容\n\n```shell\n$ git clone git@github.com:michaelliao/gitskills.git\n```\n\n因为刚才推送到master分支，所以我们可以拉取master分支的内容\n\n```\ngit clone git@github.com:michaelliao/gitskills.git -b master\n```\n\n# 分支\n\n## 命令\n\n查看分支：`git branch`\n\n创建分支：`git branch <name>`\n\n切换分支：`git checkout <name>`或者`git switch <name>`\n\n创建+切换分支：`git checkout -b <name>`或者`git switch -c <name>`\n\n合并某分支到当前分支：`git merge <name>`\n\n删除分支：`git branch -d <name>`\n\n通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。具体的`git merge --no-ff -m \"merge with no-ff\" dev`，加上--no-ff选项。\n\n## 分支管理\n\nmaster分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。  \n\n所以，团队合作的分支看起来就像这样：\n\n![](./git学习整理/1829507-20220316234843811-601091411.png)\n\n## bug分支\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；\n\n在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n\n具体可以参考：https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136\n\n## feature分支\n\n开发一个新feature，最好新建一个分支，开发完可以合并到dev分支；\n\n如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。\n\n# 多人协作\n\n多人协作的工作模式通常是这样：\n\n- 首先，可以试图用git push origin 推送自己的修改；\n- 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n- 如果合并有冲突，则解决冲突，并在本地提交；\n- 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！\n- 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to origin/。\n\n多人协作重点：\n\n- 查看远程库信息，使用git remote -v；\n- 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n- 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；\n- 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；\n- 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；\n- 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。\n\n# 标签\n\n命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id；\n\n命令git tag -a -m \"blablabla...\"可以指定标签信息；\n\n命令git tag可以查看所有标签。\n\n命令git push origin 可以推送一个本地标签；\n\n命令git push origin --tags可以推送全部未推送过的本地标签；\n\n命令git tag -d 可以删除一个本地标签；\n\n命令git push origin :refs/tags/可以删除一个远程标签。\n\n# 使用github\n\n在GitHub上，可以任意Fork开源仓库，复制到自己的仓库；\n\n自己拥有Fork后的仓库的读写权限；\n\n可以推送pull request给官方仓库来贡献代码。\n\n# 参考\n\n[Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/896043488029600)\n","source":"_posts/git学习整理.md","raw":"---\ntitle: git学习整理\ndate: 2022-09-25 20:06:06\ncategories: \n- vcs\ntags: \n- git\n---\n\n# 创建版本库\n\n版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n初始化一个Git仓库，使用`git init`命令。\n\n添加文件到Git仓库，分两步：\n\n1. 使用命令`git add 文件名`，注意，可反复多次使用，添加多个文件，此时文件放到了缓存区；\n2. 使用命令`git commit -m \"提交信息\"`，完成，此时文件从缓存区被放到了head指定的当前分支中。\n\n# 查看工作区状态与提交修改\n\n要随时掌握工作区的状态，使用`git status`命令。\n\n如果git status告诉你有文件被修改过，用`git diff`可以查看修改内容。\n\n提交修改与添加文件的步骤一样\n\n```\n git add 文件名\n git commit -m \"add a line\"\n```\n\n将暂存区的版本提交到版本库,从而形成工作区->暂存区->版本库的基本链路,本地工作区的版本控制流程大致如此.\n\n# 版本切换\n\nHEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`（commit_id可以输入前几位就行）。\n\n穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。\n\n要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。\n\n# 多次修改\n\n第一次修改 -> git add -> 第二次修改 -> git add -> git commit\n\n# 修改撤销\n\n- 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file`。\n- 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD` ，就回到了场景1，第二步按场景1操作。\n- 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考**版本切换**一节，不过前提是没有推送到远程库。\n\n# 删除文件\n\n如果在本地删除了文件，可以通过以下操作在git库里删除  \n\n`git rm test.txt`  \n\n`git commit -m \"remove test.txt\"`  \n\n可以通过以下操作恢复，相当于是让工作目录test.txt恢复到暂存区中test.txt的状态\n\n`git checkout -- test.txt`\n\n# 添加远程库\n\n**git连接GitHub的操作可以见《Windows环境基于GitHub和Hexo搭建个人博客》的2.2节**\n\n把本地库的内容推送到远程，用git push命令，实际上是把指定分支推送到远程。  \n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n1. 要关联一个远程库，使用命令\n   \n   ```\n   git remote add origin git@server-name:path/repo-name.git\n   ```\n   \n   例如：\n   \n   ```\n   git remote add origin git@github.com:michaelliao/learngit.git\n   ```\n\n2. 关联后，使用命令`git push -u origin master`第一次推送master分支的所有内容；\n\n3. 此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改；\n\n# 克隆远程库\n\nGit支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。以下是拉去默认分支的内容\n\n```shell\n$ git clone git@github.com:michaelliao/gitskills.git\n```\n\n因为刚才推送到master分支，所以我们可以拉取master分支的内容\n\n```\ngit clone git@github.com:michaelliao/gitskills.git -b master\n```\n\n# 分支\n\n## 命令\n\n查看分支：`git branch`\n\n创建分支：`git branch <name>`\n\n切换分支：`git checkout <name>`或者`git switch <name>`\n\n创建+切换分支：`git checkout -b <name>`或者`git switch -c <name>`\n\n合并某分支到当前分支：`git merge <name>`\n\n删除分支：`git branch -d <name>`\n\n通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。具体的`git merge --no-ff -m \"merge with no-ff\" dev`，加上--no-ff选项。\n\n## 分支管理\n\nmaster分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。  \n\n所以，团队合作的分支看起来就像这样：\n\n![](./git学习整理/1829507-20220316234843811-601091411.png)\n\n## bug分支\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；\n\n在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\n\n具体可以参考：https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136\n\n## feature分支\n\n开发一个新feature，最好新建一个分支，开发完可以合并到dev分支；\n\n如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。\n\n# 多人协作\n\n多人协作的工作模式通常是这样：\n\n- 首先，可以试图用git push origin 推送自己的修改；\n- 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n- 如果合并有冲突，则解决冲突，并在本地提交；\n- 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！\n- 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to origin/。\n\n多人协作重点：\n\n- 查看远程库信息，使用git remote -v；\n- 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n- 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；\n- 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；\n- 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；\n- 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。\n\n# 标签\n\n命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id；\n\n命令git tag -a -m \"blablabla...\"可以指定标签信息；\n\n命令git tag可以查看所有标签。\n\n命令git push origin 可以推送一个本地标签；\n\n命令git push origin --tags可以推送全部未推送过的本地标签；\n\n命令git tag -d 可以删除一个本地标签；\n\n命令git push origin :refs/tags/可以删除一个远程标签。\n\n# 使用github\n\n在GitHub上，可以任意Fork开源仓库，复制到自己的仓库；\n\n自己拥有Fork后的仓库的读写权限；\n\n可以推送pull request给官方仓库来贡献代码。\n\n# 参考\n\n[Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/896043488029600)\n","slug":"git学习整理","published":1,"updated":"2022-10-28T14:05:08.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38vw0006q8t7ej1s830c","content":"<h1 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h1><p>版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>\n<p>初始化一个Git仓库，使用<code>git init</code>命令。</p>\n<p>添加文件到Git仓库，分两步：</p>\n<ol>\n<li>使用命令<code>git add 文件名</code>，注意，可反复多次使用，添加多个文件，此时文件放到了缓存区；</li>\n<li>使用命令<code>git commit -m &quot;提交信息&quot;</code>，完成，此时文件从缓存区被放到了head指定的当前分支中。</li>\n</ol>\n<h1 id=\"查看工作区状态与提交修改\"><a href=\"#查看工作区状态与提交修改\" class=\"headerlink\" title=\"查看工作区状态与提交修改\"></a>查看工作区状态与提交修改</h1><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p>\n<p>如果git status告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p>\n<p>提交修改与添加文件的步骤一样</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git <span class=\"hljs-keyword\">add</span> 文件名<br>git <span class=\"hljs-keyword\">commit</span> -m &quot;add a line&quot;<br></code></pre></td></tr></table></figure>\n\n<p>将暂存区的版本提交到版本库,从而形成工作区-&gt;暂存区-&gt;版本库的基本链路,本地工作区的版本控制流程大致如此.</p>\n<h1 id=\"版本切换\"><a href=\"#版本切换\" class=\"headerlink\" title=\"版本切换\"></a>版本切换</h1><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>（commit_id可以输入前几位就行）。</p>\n<p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p>\n<p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>\n<h1 id=\"多次修改\"><a href=\"#多次修改\" class=\"headerlink\" title=\"多次修改\"></a>多次修改</h1><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p>\n<h1 id=\"修改撤销\"><a href=\"#修改撤销\" class=\"headerlink\" title=\"修改撤销\"></a>修改撤销</h1><ul>\n<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>\n<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD</code> ，就回到了场景1，第二步按场景1操作。</li>\n<li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<strong>版本切换</strong>一节，不过前提是没有推送到远程库。</li>\n</ul>\n<h1 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h1><p>如果在本地删除了文件，可以通过以下操作在git库里删除  </p>\n<p><code>git rm test.txt</code>  </p>\n<p><code>git commit -m &quot;remove test.txt&quot;</code>  </p>\n<p>可以通过以下操作恢复，相当于是让工作目录test.txt恢复到暂存区中test.txt的状态</p>\n<p><code>git checkout -- test.txt</code></p>\n<h1 id=\"添加远程库\"><a href=\"#添加远程库\" class=\"headerlink\" title=\"添加远程库\"></a>添加远程库</h1><p><strong>git连接GitHub的操作可以见《Windows环境基于GitHub和Hexo搭建个人博客》的2.2节</strong></p>\n<p>把本地库的内容推送到远程，用git push命令，实际上是把指定分支推送到远程。  </p>\n<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>\n<ol>\n<li><p>要关联一个远程库，使用命令</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git remote <span class=\"hljs-keyword\">add</span> origin git@<span class=\"hljs-keyword\">server</span>-<span class=\"hljs-type\">name</span>:<span class=\"hljs-type\">path</span>/repo-<span class=\"hljs-type\">name</span>.git<br></code></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\">git remote <span class=\"hljs-keyword\">add</span><span class=\"language-bash\"> origin git@github.com:michaelliao/learngit.git</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>\n</li>\n<li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>\n</li>\n</ol>\n<h1 id=\"克隆远程库\"><a href=\"#克隆远程库\" class=\"headerlink\" title=\"克隆远程库\"></a>克隆远程库</h1><p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。以下是拉去默认分支的内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"hljs-built_in\">clone</span> git@github.com:michaelliao/gitskills.git</span><br></code></pre></td></tr></table></figure>\n\n<p>因为刚才推送到master分支，所以我们可以拉取master分支的内容</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">git</span>@github.com:michaelliao/gitskills.git -b <span class=\"hljs-literal\">master</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h1><h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>查看分支：<code>git branch</code></p>\n<p>创建分支：<code>git branch &lt;name&gt;</code></p>\n<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>\n<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>\n<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>\n<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>\n<p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。具体的<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>，加上–no-ff选项。</p>\n<h2 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h2><p>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。  </p>\n<p>所以，团队合作的分支看起来就像这样：</p>\n<p><img src=\"/2022/09/25/git%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/1829507-20220316234843811-601091411.png\"></p>\n<h2 id=\"bug分支\"><a href=\"#bug分支\" class=\"headerlink\" title=\"bug分支\"></a>bug分支</h2><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>\n<p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</p>\n<p>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>\n<p>具体可以参考：<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136\">https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136</a></p>\n<h2 id=\"feature分支\"><a href=\"#feature分支\" class=\"headerlink\" title=\"feature分支\"></a>feature分支</h2><p>开发一个新feature，最好新建一个分支，开发完可以合并到dev分支；</p>\n<p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。</p>\n<h1 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h1><p>多人协作的工作模式通常是这样：</p>\n<ul>\n<li>首先，可以试图用git push origin 推送自己的修改；</li>\n<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>\n<li>如果合并有冲突，则解决冲突，并在本地提交；</li>\n<li>没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！</li>\n<li>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to origin&#x2F;。</li>\n</ul>\n<p>多人协作重点：</p>\n<ul>\n<li>查看远程库信息，使用git remote -v；</li>\n<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>\n<li>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</li>\n<li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin&#x2F;branch-name，本地和远程分支的名称最好一致；</li>\n<li>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin&#x2F;branch-name；</li>\n<li>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</li>\n</ul>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><p>命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p>\n<p>命令git tag -a -m “blablabla…”可以指定标签信息；</p>\n<p>命令git tag可以查看所有标签。</p>\n<p>命令git push origin 可以推送一个本地标签；</p>\n<p>命令git push origin –tags可以推送全部未推送过的本地标签；</p>\n<p>命令git tag -d 可以删除一个本地标签；</p>\n<p>命令git push origin :refs&#x2F;tags&#x2F;可以删除一个远程标签。</p>\n<h1 id=\"使用github\"><a href=\"#使用github\" class=\"headerlink\" title=\"使用github\"></a>使用github</h1><p>在GitHub上，可以任意Fork开源仓库，复制到自己的仓库；</p>\n<p>自己拥有Fork后的仓库的读写权限；</p>\n<p>可以推送pull request给官方仓库来贡献代码。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>\n","site":{"data":{}},"wordcount":3422,"excerpt":"","more":"<h1 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h1><p>版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>\n<p>初始化一个Git仓库，使用<code>git init</code>命令。</p>\n<p>添加文件到Git仓库，分两步：</p>\n<ol>\n<li>使用命令<code>git add 文件名</code>，注意，可反复多次使用，添加多个文件，此时文件放到了缓存区；</li>\n<li>使用命令<code>git commit -m &quot;提交信息&quot;</code>，完成，此时文件从缓存区被放到了head指定的当前分支中。</li>\n</ol>\n<h1 id=\"查看工作区状态与提交修改\"><a href=\"#查看工作区状态与提交修改\" class=\"headerlink\" title=\"查看工作区状态与提交修改\"></a>查看工作区状态与提交修改</h1><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p>\n<p>如果git status告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p>\n<p>提交修改与添加文件的步骤一样</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git <span class=\"hljs-keyword\">add</span> 文件名<br>git <span class=\"hljs-keyword\">commit</span> -m &quot;add a line&quot;<br></code></pre></td></tr></table></figure>\n\n<p>将暂存区的版本提交到版本库,从而形成工作区-&gt;暂存区-&gt;版本库的基本链路,本地工作区的版本控制流程大致如此.</p>\n<h1 id=\"版本切换\"><a href=\"#版本切换\" class=\"headerlink\" title=\"版本切换\"></a>版本切换</h1><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>（commit_id可以输入前几位就行）。</p>\n<p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p>\n<p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>\n<h1 id=\"多次修改\"><a href=\"#多次修改\" class=\"headerlink\" title=\"多次修改\"></a>多次修改</h1><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p>\n<h1 id=\"修改撤销\"><a href=\"#修改撤销\" class=\"headerlink\" title=\"修改撤销\"></a>修改撤销</h1><ul>\n<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>\n<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD</code> ，就回到了场景1，第二步按场景1操作。</li>\n<li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<strong>版本切换</strong>一节，不过前提是没有推送到远程库。</li>\n</ul>\n<h1 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h1><p>如果在本地删除了文件，可以通过以下操作在git库里删除  </p>\n<p><code>git rm test.txt</code>  </p>\n<p><code>git commit -m &quot;remove test.txt&quot;</code>  </p>\n<p>可以通过以下操作恢复，相当于是让工作目录test.txt恢复到暂存区中test.txt的状态</p>\n<p><code>git checkout -- test.txt</code></p>\n<h1 id=\"添加远程库\"><a href=\"#添加远程库\" class=\"headerlink\" title=\"添加远程库\"></a>添加远程库</h1><p><strong>git连接GitHub的操作可以见《Windows环境基于GitHub和Hexo搭建个人博客》的2.2节</strong></p>\n<p>把本地库的内容推送到远程，用git push命令，实际上是把指定分支推送到远程。  </p>\n<p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>\n<ol>\n<li><p>要关联一个远程库，使用命令</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\">git remote <span class=\"hljs-keyword\">add</span> origin git@<span class=\"hljs-keyword\">server</span>-<span class=\"hljs-type\">name</span>:<span class=\"hljs-type\">path</span>/repo-<span class=\"hljs-type\">name</span>.git<br></code></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dockerfile\">git remote <span class=\"hljs-keyword\">add</span><span class=\"language-bash\"> origin git@github.com:michaelliao/learngit.git</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>\n</li>\n<li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>\n</li>\n</ol>\n<h1 id=\"克隆远程库\"><a href=\"#克隆远程库\" class=\"headerlink\" title=\"克隆远程库\"></a>克隆远程库</h1><p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。以下是拉去默认分支的内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"hljs-built_in\">clone</span> git@github.com:michaelliao/gitskills.git</span><br></code></pre></td></tr></table></figure>\n\n<p>因为刚才推送到master分支，所以我们可以拉取master分支的内容</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\">git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">git</span>@github.com:michaelliao/gitskills.git -b <span class=\"hljs-literal\">master</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h1><h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>查看分支：<code>git branch</code></p>\n<p>创建分支：<code>git branch &lt;name&gt;</code></p>\n<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>\n<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>\n<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>\n<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>\n<p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。具体的<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>，加上–no-ff选项。</p>\n<h2 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h2><p>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。  </p>\n<p>所以，团队合作的分支看起来就像这样：</p>\n<p><img src=\"/2022/09/25/git%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/1829507-20220316234843811-601091411.png\"></p>\n<h2 id=\"bug分支\"><a href=\"#bug分支\" class=\"headerlink\" title=\"bug分支\"></a>bug分支</h2><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>\n<p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</p>\n<p>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>\n<p>具体可以参考：<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136\">https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136</a></p>\n<h2 id=\"feature分支\"><a href=\"#feature分支\" class=\"headerlink\" title=\"feature分支\"></a>feature分支</h2><p>开发一个新feature，最好新建一个分支，开发完可以合并到dev分支；</p>\n<p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。</p>\n<h1 id=\"多人协作\"><a href=\"#多人协作\" class=\"headerlink\" title=\"多人协作\"></a>多人协作</h1><p>多人协作的工作模式通常是这样：</p>\n<ul>\n<li>首先，可以试图用git push origin 推送自己的修改；</li>\n<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>\n<li>如果合并有冲突，则解决冲突，并在本地提交；</li>\n<li>没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！</li>\n<li>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to origin&#x2F;。</li>\n</ul>\n<p>多人协作重点：</p>\n<ul>\n<li>查看远程库信息，使用git remote -v；</li>\n<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>\n<li>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</li>\n<li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin&#x2F;branch-name，本地和远程分支的名称最好一致；</li>\n<li>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin&#x2F;branch-name；</li>\n<li>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</li>\n</ul>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><p>命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p>\n<p>命令git tag -a -m “blablabla…”可以指定标签信息；</p>\n<p>命令git tag可以查看所有标签。</p>\n<p>命令git push origin 可以推送一个本地标签；</p>\n<p>命令git push origin –tags可以推送全部未推送过的本地标签；</p>\n<p>命令git tag -d 可以删除一个本地标签；</p>\n<p>命令git push origin :refs&#x2F;tags&#x2F;可以删除一个远程标签。</p>\n<h1 id=\"使用github\"><a href=\"#使用github\" class=\"headerlink\" title=\"使用github\"></a>使用github</h1><p>在GitHub上，可以任意Fork开源仓库，复制到自己的仓库；</p>\n<p>自己拥有Fork后的仓库的读写权限；</p>\n<p>可以推送pull request给官方仓库来贡献代码。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>\n"},{"title":"别人不说,你一定要懂的人情世故","date":"2022-10-28T14:31:08.000Z","_content":"\n# 信息\n\n《别人不说，你一定要懂的人情世故》 墨墨 北京理工大学出版社\n\n# 摘录\n\n- 不能主动去接触他人，人脉关系必定不广，人生路程也不会走得太顺遂，唯有怀着主动之心，你才能广交天下的朋友。\n\n- 在职场里，要求我们在即使没有功利、没有收益的时候也要给别人以支持、给人以帮助，更不能砸别人的场面。\n\n- 批评最好能单独进行，如果在公共场合批评，那就太伤你下属的感情了，这样做的结果是让你的下属成为你的刺儿头。如果能单独进行，即使其他人知道，你的下属也会好过点儿。\n\n- 自己身居要职，就注定了要被批评，与其困扰于被批评，还不如想办法习惯它。\n\n- 多在背后赞美，多在第三者面前赞美，是融洽人际关系的好方法。懂得人情世故的人会选择在背后赞美，通过间接的方式让人接受赞美，不仅避免了当面说好话的尴尬，还能够放大赞美的效果，从而达到润滑彼此关系的目的。\n\n- 我们要尽量避开背后议论、评价他人，若迫不得已参与评论，则应多说一些中肯的话，而要避免说坏话。如果可能的话，最好避开背后议论他人，无论你是说好话还是说坏话。\n\n- 在做事情的时候，将丑话说在前头，能够让人的态度更加认真和慎重，而不会掉以轻心、马虎了事。同时，也能够避免一些纠纷。丑话虽然不受听、扎耳朵，但却是超越流俗、突破情面把本相说到底、把前景想周全，既重人情，更重信义的真话。\n\n- 多聊对方关心和得意的事，是懂得人情世故的做法，但是有不少人不懂得这其中的道理，常常从自身的爱好出发，说自己喜欢的话题，聊自己得意的事，结果让对方缺乏兴趣，甚至不耐烦。所以在与人交流时，尽可能地忘掉自己，不要总是谈自己的事情，你的生活引不起别人的兴趣。\n\n- 如果有人请求你的帮助，即便对方的困境纯属咎由自取，你也不要说他的不是。你可以说自己无能为力，并拒绝他的请求，但不要指责他。请求帮助，承认自己是一个弱者，这已经是丢面子的事情了，如果你还进一步指责对方，则会让对方的脸色更加难看。\n\n- 与人处事就如同下一盘象棋，只有那些阅历不深的人才会一口气赢对方七八盘，让对方抬不起头。事实上人们交际，彼此之间并非比赛，对输赢不必那么认真，主要目的是交流感情，增进友谊，进而发展合作共进的关系。\n\n- 做人要有胸怀，特别是与人相交，不能整日计较鸡毛蒜皮的小事，枉费了许多时间和精力。在生活中应该多理解，在工作上应该多宽容，在待人上应该多温和，在处事上应该多大度。这样的处世原则将让你的朋友如沐春风。\n\n# 感想\n\n内容较多，多思考，多实践，多反思。\n","source":"_posts/别人不说-你一定要懂的人情世故.md","raw":"---\ntitle: 别人不说,你一定要懂的人情世故\ndate: 2022-10-28 22:31:08\ncategories: \n- 读书\ntags: \n- 心理\n---\n\n# 信息\n\n《别人不说，你一定要懂的人情世故》 墨墨 北京理工大学出版社\n\n# 摘录\n\n- 不能主动去接触他人，人脉关系必定不广，人生路程也不会走得太顺遂，唯有怀着主动之心，你才能广交天下的朋友。\n\n- 在职场里，要求我们在即使没有功利、没有收益的时候也要给别人以支持、给人以帮助，更不能砸别人的场面。\n\n- 批评最好能单独进行，如果在公共场合批评，那就太伤你下属的感情了，这样做的结果是让你的下属成为你的刺儿头。如果能单独进行，即使其他人知道，你的下属也会好过点儿。\n\n- 自己身居要职，就注定了要被批评，与其困扰于被批评，还不如想办法习惯它。\n\n- 多在背后赞美，多在第三者面前赞美，是融洽人际关系的好方法。懂得人情世故的人会选择在背后赞美，通过间接的方式让人接受赞美，不仅避免了当面说好话的尴尬，还能够放大赞美的效果，从而达到润滑彼此关系的目的。\n\n- 我们要尽量避开背后议论、评价他人，若迫不得已参与评论，则应多说一些中肯的话，而要避免说坏话。如果可能的话，最好避开背后议论他人，无论你是说好话还是说坏话。\n\n- 在做事情的时候，将丑话说在前头，能够让人的态度更加认真和慎重，而不会掉以轻心、马虎了事。同时，也能够避免一些纠纷。丑话虽然不受听、扎耳朵，但却是超越流俗、突破情面把本相说到底、把前景想周全，既重人情，更重信义的真话。\n\n- 多聊对方关心和得意的事，是懂得人情世故的做法，但是有不少人不懂得这其中的道理，常常从自身的爱好出发，说自己喜欢的话题，聊自己得意的事，结果让对方缺乏兴趣，甚至不耐烦。所以在与人交流时，尽可能地忘掉自己，不要总是谈自己的事情，你的生活引不起别人的兴趣。\n\n- 如果有人请求你的帮助，即便对方的困境纯属咎由自取，你也不要说他的不是。你可以说自己无能为力，并拒绝他的请求，但不要指责他。请求帮助，承认自己是一个弱者，这已经是丢面子的事情了，如果你还进一步指责对方，则会让对方的脸色更加难看。\n\n- 与人处事就如同下一盘象棋，只有那些阅历不深的人才会一口气赢对方七八盘，让对方抬不起头。事实上人们交际，彼此之间并非比赛，对输赢不必那么认真，主要目的是交流感情，增进友谊，进而发展合作共进的关系。\n\n- 做人要有胸怀，特别是与人相交，不能整日计较鸡毛蒜皮的小事，枉费了许多时间和精力。在生活中应该多理解，在工作上应该多宽容，在待人上应该多温和，在处事上应该多大度。这样的处世原则将让你的朋友如沐春风。\n\n# 感想\n\n内容较多，多思考，多实践，多反思。\n","slug":"别人不说-你一定要懂的人情世故","published":1,"updated":"2022-10-28T14:39:12.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38vx0007q8t78fgn090j","content":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《别人不说，你一定要懂的人情世故》 墨墨 北京理工大学出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li><p>不能主动去接触他人，人脉关系必定不广，人生路程也不会走得太顺遂，唯有怀着主动之心，你才能广交天下的朋友。</p>\n</li>\n<li><p>在职场里，要求我们在即使没有功利、没有收益的时候也要给别人以支持、给人以帮助，更不能砸别人的场面。</p>\n</li>\n<li><p>批评最好能单独进行，如果在公共场合批评，那就太伤你下属的感情了，这样做的结果是让你的下属成为你的刺儿头。如果能单独进行，即使其他人知道，你的下属也会好过点儿。</p>\n</li>\n<li><p>自己身居要职，就注定了要被批评，与其困扰于被批评，还不如想办法习惯它。</p>\n</li>\n<li><p>多在背后赞美，多在第三者面前赞美，是融洽人际关系的好方法。懂得人情世故的人会选择在背后赞美，通过间接的方式让人接受赞美，不仅避免了当面说好话的尴尬，还能够放大赞美的效果，从而达到润滑彼此关系的目的。</p>\n</li>\n<li><p>我们要尽量避开背后议论、评价他人，若迫不得已参与评论，则应多说一些中肯的话，而要避免说坏话。如果可能的话，最好避开背后议论他人，无论你是说好话还是说坏话。</p>\n</li>\n<li><p>在做事情的时候，将丑话说在前头，能够让人的态度更加认真和慎重，而不会掉以轻心、马虎了事。同时，也能够避免一些纠纷。丑话虽然不受听、扎耳朵，但却是超越流俗、突破情面把本相说到底、把前景想周全，既重人情，更重信义的真话。</p>\n</li>\n<li><p>多聊对方关心和得意的事，是懂得人情世故的做法，但是有不少人不懂得这其中的道理，常常从自身的爱好出发，说自己喜欢的话题，聊自己得意的事，结果让对方缺乏兴趣，甚至不耐烦。所以在与人交流时，尽可能地忘掉自己，不要总是谈自己的事情，你的生活引不起别人的兴趣。</p>\n</li>\n<li><p>如果有人请求你的帮助，即便对方的困境纯属咎由自取，你也不要说他的不是。你可以说自己无能为力，并拒绝他的请求，但不要指责他。请求帮助，承认自己是一个弱者，这已经是丢面子的事情了，如果你还进一步指责对方，则会让对方的脸色更加难看。</p>\n</li>\n<li><p>与人处事就如同下一盘象棋，只有那些阅历不深的人才会一口气赢对方七八盘，让对方抬不起头。事实上人们交际，彼此之间并非比赛，对输赢不必那么认真，主要目的是交流感情，增进友谊，进而发展合作共进的关系。</p>\n</li>\n<li><p>做人要有胸怀，特别是与人相交，不能整日计较鸡毛蒜皮的小事，枉费了许多时间和精力。在生活中应该多理解，在工作上应该多宽容，在待人上应该多温和，在处事上应该多大度。这样的处世原则将让你的朋友如沐春风。</p>\n</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>内容较多，多思考，多实践，多反思。</p>\n","site":{"data":{}},"wordcount":983,"excerpt":"","more":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《别人不说，你一定要懂的人情世故》 墨墨 北京理工大学出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li><p>不能主动去接触他人，人脉关系必定不广，人生路程也不会走得太顺遂，唯有怀着主动之心，你才能广交天下的朋友。</p>\n</li>\n<li><p>在职场里，要求我们在即使没有功利、没有收益的时候也要给别人以支持、给人以帮助，更不能砸别人的场面。</p>\n</li>\n<li><p>批评最好能单独进行，如果在公共场合批评，那就太伤你下属的感情了，这样做的结果是让你的下属成为你的刺儿头。如果能单独进行，即使其他人知道，你的下属也会好过点儿。</p>\n</li>\n<li><p>自己身居要职，就注定了要被批评，与其困扰于被批评，还不如想办法习惯它。</p>\n</li>\n<li><p>多在背后赞美，多在第三者面前赞美，是融洽人际关系的好方法。懂得人情世故的人会选择在背后赞美，通过间接的方式让人接受赞美，不仅避免了当面说好话的尴尬，还能够放大赞美的效果，从而达到润滑彼此关系的目的。</p>\n</li>\n<li><p>我们要尽量避开背后议论、评价他人，若迫不得已参与评论，则应多说一些中肯的话，而要避免说坏话。如果可能的话，最好避开背后议论他人，无论你是说好话还是说坏话。</p>\n</li>\n<li><p>在做事情的时候，将丑话说在前头，能够让人的态度更加认真和慎重，而不会掉以轻心、马虎了事。同时，也能够避免一些纠纷。丑话虽然不受听、扎耳朵，但却是超越流俗、突破情面把本相说到底、把前景想周全，既重人情，更重信义的真话。</p>\n</li>\n<li><p>多聊对方关心和得意的事，是懂得人情世故的做法，但是有不少人不懂得这其中的道理，常常从自身的爱好出发，说自己喜欢的话题，聊自己得意的事，结果让对方缺乏兴趣，甚至不耐烦。所以在与人交流时，尽可能地忘掉自己，不要总是谈自己的事情，你的生活引不起别人的兴趣。</p>\n</li>\n<li><p>如果有人请求你的帮助，即便对方的困境纯属咎由自取，你也不要说他的不是。你可以说自己无能为力，并拒绝他的请求，但不要指责他。请求帮助，承认自己是一个弱者，这已经是丢面子的事情了，如果你还进一步指责对方，则会让对方的脸色更加难看。</p>\n</li>\n<li><p>与人处事就如同下一盘象棋，只有那些阅历不深的人才会一口气赢对方七八盘，让对方抬不起头。事实上人们交际，彼此之间并非比赛，对输赢不必那么认真，主要目的是交流感情，增进友谊，进而发展合作共进的关系。</p>\n</li>\n<li><p>做人要有胸怀，特别是与人相交，不能整日计较鸡毛蒜皮的小事，枉费了许多时间和精力。在生活中应该多理解，在工作上应该多宽容，在待人上应该多温和，在处事上应该多大度。这样的处世原则将让你的朋友如沐春风。</p>\n</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>内容较多，多思考，多实践，多反思。</p>\n"},{"title":"Windows环境基于GitHub和Hexo搭建个人博客","date":"2022-09-06T15:20:03.000Z","_content":"\n# 前言\n\n周末参照网上教程基于GitHub和Hexo搭建个人博客，中间踩了不少的坑花了很多时间，所以将他人教程转载过来并加上一些修订内容记录下来。\n\n# 步骤\n\n## 安装Node.js和Git\n\n- Node.js：[https://nodejs.org/zh-cn](https://link.zhihu.com/?target=https%3A//nodejs.org/zh-cn)\n- Git：[https://git-scm.com/downloads](https://link.zhihu.com/?target=https%3A//git-scm.com/downloads)\n\n基于上面两个网站下载最新的Node.js和Git安装包，基于默认配置一路点下去安装Node.js和Git。安装完成后，在cmd中依次执行 `node -v`、`npm -v` 和 `git --version`，看到类似以下版本号说明安装成功\n\n![](./基于GitHub和Hexo搭建博客/组件版本.png)\n\n## 连接 Github\n\n使用邮箱注册 [GitHub](https://link.zhihu.com/?target=https%3A//github.com/) 账户，选择免费账户（Free），并完成邮件验证。\n\n在Windows桌面右键 -> Git Bash Here，设置用户名和邮箱(此处的“GitHub 用户名”和\"GitHub 邮箱\"分别替换成个人的GitHub用户名和邮箱，下同）\n\n```powershell\ngit config --global user.name \"GitHub 用户名\"\ngit config --global user.email \"GitHub 邮箱\"\n```\n\n**创建 SSH 密匙**：\n\n输入 `ssh-keygen -t rsa -C \"GitHub 邮箱\"`，然后一路回车。\n\n**添加密匙：**\n\n进入 [C:\\Users\\用户名\\.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。\n\n登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。\n\nTitle 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。\n\n**验证连接：**\n\n打开 Git Bash，输入 `ssh -T git@github.com` 出现 “Are you sure……”，输入 yes 回车确认。显示 “Hi xxx! You've successfully……” 即连接成功。如果没有出现“Hi xxx! You've successfully……”字样，可以再次输入 `ssh -T git@github.com`尝试。\n\n## 创建 Github Pages 仓库\n\nGitHub 主页右上角加号 -> New repository：\n\n- Repository name 中输入 `用户名.github.io`\n- 勾选 “Initialize this repository with a README”\n- Description 选填\n\n填好后点击 Create repository 创建。\n\n创建后默认自动启用 HTTPS，博客地址为：`https://用户名.github.io`\n\n## 本地安装 Hexo 博客程序\n\n新建一个文件夹用来存放 Hexo 的程序文件，如 hexoblog。打开该文件夹，右键 -> Git Bash Here。\n\n使用 npm 一键安装 Hexo 博客程序：\n\n```git\nnpm install -g hexo-cli\n```\n\n初始化并安装所需组件：\n\n```git\nhexo init      # 初始化\nnpm install    # 安装组件\n```\n\n完成后依次输入下面命令，启动本地服务器进行预览：\n\n```git\nhexo g   # 生成页面\nhexo s   # 启动预览\n```\n\n**访问** `http://localhost:4000`**，出现 Hexo 默认页面，本地博客安装成功！**\n\n## 部署 Hexo 到 GitHub Pages\n\n本地博客测试成功后就是上传到 GitHub 进行部署，使其能够在网络上访问。\n\n首先安装 hexo-deployer-git：\n\n```git\nnpm install hexo-deployer-git --save\n```\n\n然后修改hexo程序文件夹中的_config.yml文件末尾的 deploy部分(建议使用notepad++打开)，修改成如下（注意替换GitHub用户名）：\n\n```yml\ndeploy:\n  type: git\n  repository: git@github.com:用户名/用户名.github.io.git\n  branch: main\n```\n\n完成后运行 `hexo d` 将网站上传部署到 GitHub Pages。\n\n完成！这时访问我们的 GitHub 域名 `https://用户名.github.io` 就可以看到 Hexo 网站了。\n\n## 博客图片问题处理\n\n本人采用开源软件MarkText软件进行本地博客编辑，该软件可以在GitHub下载。需要在本地编辑博客和上传部署后的博客上都正常阅览图片，需要安装一些插件来实现该需求，具体操作如下：\n\n* 在hexo主目录安装插件，在GitBash中输入：`npm install hexo-asset-image-for-hexo5 --save`  \n\n* 在主目录的`_config.yml`文件中查找并修改`post_asset_folder`值为`true`：\n  \n  ```yml\n  post_asset_folder: true\n  ```\n\n这样在使用`hexo new \"article\"`创建新博客文章的时候，就会发现在文章的同级目录出现和md文件名相同的文件夹，可以在这个文件夹中放该文章的图片，例如test.png。例：\n\n| 1  <br>2  <br>3 | ├─article  <br>├──test.png  <br>└─article.md |\n| --------------- | -------------------------------------------- |\n\n* 写法：在文章里即可使用`![](./article/test.png)`在本地显示图片`test.png`，同时在静态网页中也可以正常显示。\n\n**注意：**本文的hexo版本为6.2.0（可以通过hexo v查看），这里安装的图像插件为hexo-asset-image-for-hexo5是适用的（hexo5版本以上建议使用 hexo-asset-image-for-hexo5 ），网上绝大部分博客说的`npm install hexo-asset-image --save`经本人测试并不适配6.2.0版本的hexo。\n\n## 开始使用\n\n**发布文章**\n\n进入博客所在目录，右键打开 Git Bash Here，创建博文：\n\n```git\nhexo new \"My New Post\"\n```\n\n然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用MarkText在该文件中撰写文章了。\n\n写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。**以后每次发布文章都是这三条命令。**\n\n```git\nhexo clean   # 清除缓存和已生成的静态文件\nhexo g   # 生成页面\nhexo d   # 部署发布\n```\n\n也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 `hexo clean、hexo g` 和 `hexo d` 发布。\n\n```markdown\n---\ntitle: Hello World # 标题\ndate: 2019/3/26 hh:mm:ss # 时间\ncategories: # 分类\n- Diary\ntags: # 标签\n- PS3\n- Games\n---\n\n摘要\n<!--more-->\n正文\n```\n\n## 更换主题\n\n在 [Themes | Hexo](https://link.zhihu.com/?target=https%3A//hexo.io/themes/) 选择一个喜欢的主题，并参照主题的文档来安装和配置主题。\n\n## 常用命令\n\n```git\nhexo new \"name\"       # 新建文章\nhexo new page \"name\"  # 新建页面\nhexo g                # 生成页面\nhexo d                # 部署\nhexo g -d             # 生成页面并部署\nhexo s                # 本地预览\nhexo clean            # 清除缓存和已生成的静态文件\nhexo help             # 帮助\n```\n\n# 参考资料\n\n[使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/60578464)\n\n[在Hexo中使用本地图片 - 个人学习 (idealx.cn)](https://www.idealx.cn/post/Hexo/hexo-asset-image/)\n\n[fluid-dev/hexo-theme-fluid: 一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design theme for Hexo (github.com)](https://github.com/fluid-dev/hexo-theme-fluid)\n","source":"_posts/基于GitHub和Hexo搭建博客.md","raw":"---\ntitle: Windows环境基于GitHub和Hexo搭建个人博客\ndate: 2022-09-06 23:20:03\ncategories: \n- 其他\ntags: \n- 博客搭建\n---\n\n# 前言\n\n周末参照网上教程基于GitHub和Hexo搭建个人博客，中间踩了不少的坑花了很多时间，所以将他人教程转载过来并加上一些修订内容记录下来。\n\n# 步骤\n\n## 安装Node.js和Git\n\n- Node.js：[https://nodejs.org/zh-cn](https://link.zhihu.com/?target=https%3A//nodejs.org/zh-cn)\n- Git：[https://git-scm.com/downloads](https://link.zhihu.com/?target=https%3A//git-scm.com/downloads)\n\n基于上面两个网站下载最新的Node.js和Git安装包，基于默认配置一路点下去安装Node.js和Git。安装完成后，在cmd中依次执行 `node -v`、`npm -v` 和 `git --version`，看到类似以下版本号说明安装成功\n\n![](./基于GitHub和Hexo搭建博客/组件版本.png)\n\n## 连接 Github\n\n使用邮箱注册 [GitHub](https://link.zhihu.com/?target=https%3A//github.com/) 账户，选择免费账户（Free），并完成邮件验证。\n\n在Windows桌面右键 -> Git Bash Here，设置用户名和邮箱(此处的“GitHub 用户名”和\"GitHub 邮箱\"分别替换成个人的GitHub用户名和邮箱，下同）\n\n```powershell\ngit config --global user.name \"GitHub 用户名\"\ngit config --global user.email \"GitHub 邮箱\"\n```\n\n**创建 SSH 密匙**：\n\n输入 `ssh-keygen -t rsa -C \"GitHub 邮箱\"`，然后一路回车。\n\n**添加密匙：**\n\n进入 [C:\\Users\\用户名\\.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。\n\n登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。\n\nTitle 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。\n\n**验证连接：**\n\n打开 Git Bash，输入 `ssh -T git@github.com` 出现 “Are you sure……”，输入 yes 回车确认。显示 “Hi xxx! You've successfully……” 即连接成功。如果没有出现“Hi xxx! You've successfully……”字样，可以再次输入 `ssh -T git@github.com`尝试。\n\n## 创建 Github Pages 仓库\n\nGitHub 主页右上角加号 -> New repository：\n\n- Repository name 中输入 `用户名.github.io`\n- 勾选 “Initialize this repository with a README”\n- Description 选填\n\n填好后点击 Create repository 创建。\n\n创建后默认自动启用 HTTPS，博客地址为：`https://用户名.github.io`\n\n## 本地安装 Hexo 博客程序\n\n新建一个文件夹用来存放 Hexo 的程序文件，如 hexoblog。打开该文件夹，右键 -> Git Bash Here。\n\n使用 npm 一键安装 Hexo 博客程序：\n\n```git\nnpm install -g hexo-cli\n```\n\n初始化并安装所需组件：\n\n```git\nhexo init      # 初始化\nnpm install    # 安装组件\n```\n\n完成后依次输入下面命令，启动本地服务器进行预览：\n\n```git\nhexo g   # 生成页面\nhexo s   # 启动预览\n```\n\n**访问** `http://localhost:4000`**，出现 Hexo 默认页面，本地博客安装成功！**\n\n## 部署 Hexo 到 GitHub Pages\n\n本地博客测试成功后就是上传到 GitHub 进行部署，使其能够在网络上访问。\n\n首先安装 hexo-deployer-git：\n\n```git\nnpm install hexo-deployer-git --save\n```\n\n然后修改hexo程序文件夹中的_config.yml文件末尾的 deploy部分(建议使用notepad++打开)，修改成如下（注意替换GitHub用户名）：\n\n```yml\ndeploy:\n  type: git\n  repository: git@github.com:用户名/用户名.github.io.git\n  branch: main\n```\n\n完成后运行 `hexo d` 将网站上传部署到 GitHub Pages。\n\n完成！这时访问我们的 GitHub 域名 `https://用户名.github.io` 就可以看到 Hexo 网站了。\n\n## 博客图片问题处理\n\n本人采用开源软件MarkText软件进行本地博客编辑，该软件可以在GitHub下载。需要在本地编辑博客和上传部署后的博客上都正常阅览图片，需要安装一些插件来实现该需求，具体操作如下：\n\n* 在hexo主目录安装插件，在GitBash中输入：`npm install hexo-asset-image-for-hexo5 --save`  \n\n* 在主目录的`_config.yml`文件中查找并修改`post_asset_folder`值为`true`：\n  \n  ```yml\n  post_asset_folder: true\n  ```\n\n这样在使用`hexo new \"article\"`创建新博客文章的时候，就会发现在文章的同级目录出现和md文件名相同的文件夹，可以在这个文件夹中放该文章的图片，例如test.png。例：\n\n| 1  <br>2  <br>3 | ├─article  <br>├──test.png  <br>└─article.md |\n| --------------- | -------------------------------------------- |\n\n* 写法：在文章里即可使用`![](./article/test.png)`在本地显示图片`test.png`，同时在静态网页中也可以正常显示。\n\n**注意：**本文的hexo版本为6.2.0（可以通过hexo v查看），这里安装的图像插件为hexo-asset-image-for-hexo5是适用的（hexo5版本以上建议使用 hexo-asset-image-for-hexo5 ），网上绝大部分博客说的`npm install hexo-asset-image --save`经本人测试并不适配6.2.0版本的hexo。\n\n## 开始使用\n\n**发布文章**\n\n进入博客所在目录，右键打开 Git Bash Here，创建博文：\n\n```git\nhexo new \"My New Post\"\n```\n\n然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用MarkText在该文件中撰写文章了。\n\n写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。**以后每次发布文章都是这三条命令。**\n\n```git\nhexo clean   # 清除缓存和已生成的静态文件\nhexo g   # 生成页面\nhexo d   # 部署发布\n```\n\n也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 `hexo clean、hexo g` 和 `hexo d` 发布。\n\n```markdown\n---\ntitle: Hello World # 标题\ndate: 2019/3/26 hh:mm:ss # 时间\ncategories: # 分类\n- Diary\ntags: # 标签\n- PS3\n- Games\n---\n\n摘要\n<!--more-->\n正文\n```\n\n## 更换主题\n\n在 [Themes | Hexo](https://link.zhihu.com/?target=https%3A//hexo.io/themes/) 选择一个喜欢的主题，并参照主题的文档来安装和配置主题。\n\n## 常用命令\n\n```git\nhexo new \"name\"       # 新建文章\nhexo new page \"name\"  # 新建页面\nhexo g                # 生成页面\nhexo d                # 部署\nhexo g -d             # 生成页面并部署\nhexo s                # 本地预览\nhexo clean            # 清除缓存和已生成的静态文件\nhexo help             # 帮助\n```\n\n# 参考资料\n\n[使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/60578464)\n\n[在Hexo中使用本地图片 - 个人学习 (idealx.cn)](https://www.idealx.cn/post/Hexo/hexo-asset-image/)\n\n[fluid-dev/hexo-theme-fluid: 一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design theme for Hexo (github.com)](https://github.com/fluid-dev/hexo-theme-fluid)\n","slug":"基于GitHub和Hexo搭建博客","published":1,"updated":"2022-10-28T14:51:14.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38vz000bq8t77ihncz17","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>周末参照网上教程基于GitHub和Hexo搭建个人博客，中间踩了不少的坑花了很多时间，所以将他人教程转载过来并加上一些修订内容记录下来。</p>\n<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><h2 id=\"安装Node-js和Git\"><a href=\"#安装Node-js和Git\" class=\"headerlink\" title=\"安装Node.js和Git\"></a>安装Node.js和Git</h2><ul>\n<li>Node.js：<a href=\"https://link.zhihu.com/?target=https://nodejs.org/zh-cn\">https://nodejs.org/zh-cn</a></li>\n<li>Git：<a href=\"https://link.zhihu.com/?target=https://git-scm.com/downloads\">https://git-scm.com/downloads</a></li>\n</ul>\n<p>基于上面两个网站下载最新的Node.js和Git安装包，基于默认配置一路点下去安装Node.js和Git。安装完成后，在cmd中依次执行 <code>node -v</code>、<code>npm -v</code> 和 <code>git --version</code>，看到类似以下版本号说明安装成功</p>\n<p><img src=\"/2022/09/06/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC.png\"></p>\n<h2 id=\"连接-Github\"><a href=\"#连接-Github\" class=\"headerlink\" title=\"连接 Github\"></a>连接 Github</h2><p>使用邮箱注册 <a href=\"https://link.zhihu.com/?target=https://github.com/\">GitHub</a> 账户，选择免费账户（Free），并完成邮件验证。</p>\n<p>在Windows桌面右键 -&gt; Git Bash Here，设置用户名和邮箱(此处的“GitHub 用户名”和”GitHub 邮箱”分别替换成个人的GitHub用户名和邮箱，下同）</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">git config <span class=\"hljs-literal\">--global</span> user.name <span class=\"hljs-string\">&quot;GitHub 用户名&quot;</span><br>git config <span class=\"hljs-literal\">--global</span> user.email <span class=\"hljs-string\">&quot;GitHub 邮箱&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>创建 SSH 密匙</strong>：</p>\n<p>输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车。</p>\n<p><strong>添加密匙：</strong></p>\n<p>进入 [C:\\Users\\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p>\n<p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p>\n<p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p>\n<p><strong>验证连接：</strong></p>\n<p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认。显示 “Hi xxx! You’ve successfully……” 即连接成功。如果没有出现“Hi xxx! You’ve successfully……”字样，可以再次输入 <code>ssh -T git@github.com</code>尝试。</p>\n<h2 id=\"创建-Github-Pages-仓库\"><a href=\"#创建-Github-Pages-仓库\" class=\"headerlink\" title=\"创建 Github Pages 仓库\"></a>创建 Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p>\n<ul>\n<li>Repository name 中输入 <code>用户名.github.io</code></li>\n<li>勾选 “Initialize this repository with a README”</li>\n<li>Description 选填</li>\n</ul>\n<p>填好后点击 Create repository 创建。</p>\n<p>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p>\n<h2 id=\"本地安装-Hexo-博客程序\"><a href=\"#本地安装-Hexo-博客程序\" class=\"headerlink\" title=\"本地安装 Hexo 博客程序\"></a>本地安装 Hexo 博客程序</h2><p>新建一个文件夹用来存放 Hexo 的程序文件，如 hexoblog。打开该文件夹，右键 -&gt; Git Bash Here。</p>\n<p>使用 npm 一键安装 Hexo 博客程序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">npm install -g hexo-cli<br></code></pre></td></tr></table></figure>\n\n<p>初始化并安装所需组件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">hexo init      # 初始化<br>npm install    # 安装组件<br></code></pre></td></tr></table></figure>\n\n<p>完成后依次输入下面命令，启动本地服务器进行预览：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">hexo g   # 生成页面<br>hexo s   # 启动预览<br></code></pre></td></tr></table></figure>\n\n<p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p>\n<h2 id=\"部署-Hexo-到-GitHub-Pages\"><a href=\"#部署-Hexo-到-GitHub-Pages\" class=\"headerlink\" title=\"部署 Hexo 到 GitHub Pages\"></a>部署 Hexo 到 GitHub Pages</h2><p>本地博客测试成功后就是上传到 GitHub 进行部署，使其能够在网络上访问。</p>\n<p>首先安装 hexo-deployer-git：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>\n\n<p>然后修改hexo程序文件夹中的_config.yml文件末尾的 deploy部分(建议使用notepad++打开)，修改成如下（注意替换GitHub用户名）：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">deploy:</span><br>  <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">git</span><br>  <span class=\"hljs-attr\">repository:</span> <span class=\"hljs-string\">git@github.com:用户名/用户名.github.io.git</span><br>  <span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">main</span><br></code></pre></td></tr></table></figure>\n\n<p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p>\n<p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p>\n<h2 id=\"博客图片问题处理\"><a href=\"#博客图片问题处理\" class=\"headerlink\" title=\"博客图片问题处理\"></a>博客图片问题处理</h2><p>本人采用开源软件MarkText软件进行本地博客编辑，该软件可以在GitHub下载。需要在本地编辑博客和上传部署后的博客上都正常阅览图片，需要安装一些插件来实现该需求，具体操作如下：</p>\n<ul>\n<li><p>在hexo主目录安装插件，在GitBash中输入：<code>npm install hexo-asset-image-for-hexo5 --save</code>  </p>\n</li>\n<li><p>在主目录的<code>_config.yml</code>文件中查找并修改<code>post_asset_folder</code>值为<code>true</code>：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">post_asset_folder:</span> <span class=\"hljs-literal\">true</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>这样在使用<code>hexo new &quot;article&quot;</code>创建新博客文章的时候，就会发现在文章的同级目录出现和md文件名相同的文件夹，可以在这个文件夹中放该文章的图片，例如test.png。例：</p>\n<table>\n<thead>\n<tr>\n<th>1  <br>2  <br>3</th>\n<th>├─article  <br>├──test.png  <br>└─article.md</th>\n</tr>\n</thead>\n</table>\n<ul>\n<li>写法：在文章里即可使用<code>![](./article/test.png)</code>在本地显示图片<code>test.png</code>，同时在静态网页中也可以正常显示。</li>\n</ul>\n<p><strong>注意：</strong>本文的hexo版本为6.2.0（可以通过hexo v查看），这里安装的图像插件为hexo-asset-image-for-hexo5是适用的（hexo5版本以上建议使用 hexo-asset-image-for-hexo5 ），网上绝大部分博客说的<code>npm install hexo-asset-image --save</code>经本人测试并不适配6.2.0版本的hexo。</p>\n<h2 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h2><p><strong>发布文章</strong></p>\n<p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">hexo new &quot;My New Post&quot;<br></code></pre></td></tr></table></figure>\n\n<p>然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用MarkText在该文件中撰写文章了。</p>\n<p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。<strong>以后每次发布文章都是这三条命令。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">hexo clean   # 清除缓存和已生成的静态文件<br>hexo g   # 生成页面<br>hexo d   # 部署发布<br></code></pre></td></tr></table></figure>\n\n<p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo clean、hexo g</code> 和 <code>hexo d</code> 发布。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">---<br>title: Hello World # 标题<br>date: 2019/3/26 hh:mm:ss # 时间<br>categories: # 分类<br><span class=\"hljs-bullet\">-</span> Diary<br>tags: # 标签<br><span class=\"hljs-bullet\">-</span> PS3<br><span class=\"hljs-section\">- Games</span><br><span class=\"hljs-section\">---</span><br><br>摘要<br>&lt;!--more--&gt;<br>正文<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"更换主题\"><a href=\"#更换主题\" class=\"headerlink\" title=\"更换主题\"></a>更换主题</h2><p>在 <a href=\"https://link.zhihu.com/?target=https://hexo.io/themes/\">Themes | Hexo</a> 选择一个喜欢的主题，并参照主题的文档来安装和配置主题。</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">hexo new &quot;name&quot;       # 新建文章<br>hexo new page &quot;name&quot;  # 新建页面<br>hexo g                # 生成页面<br>hexo d                # 部署<br>hexo g -d             # 生成页面并部署<br>hexo s                # 本地预览<br>hexo clean            # 清除缓存和已生成的静态文件<br>hexo help             # 帮助<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://zhuanlan.zhihu.com/p/60578464\">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.idealx.cn/post/Hexo/hexo-asset-image/\">在Hexo中使用本地图片 - 个人学习 (idealx.cn)</a></p>\n<p><a href=\"https://github.com/fluid-dev/hexo-theme-fluid\">fluid-dev&#x2F;hexo-theme-fluid: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo (github.com)</a></p>\n","site":{"data":{}},"wordcount":3076,"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>周末参照网上教程基于GitHub和Hexo搭建个人博客，中间踩了不少的坑花了很多时间，所以将他人教程转载过来并加上一些修订内容记录下来。</p>\n<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><h2 id=\"安装Node-js和Git\"><a href=\"#安装Node-js和Git\" class=\"headerlink\" title=\"安装Node.js和Git\"></a>安装Node.js和Git</h2><ul>\n<li>Node.js：<a href=\"https://link.zhihu.com/?target=https://nodejs.org/zh-cn\">https://nodejs.org/zh-cn</a></li>\n<li>Git：<a href=\"https://link.zhihu.com/?target=https://git-scm.com/downloads\">https://git-scm.com/downloads</a></li>\n</ul>\n<p>基于上面两个网站下载最新的Node.js和Git安装包，基于默认配置一路点下去安装Node.js和Git。安装完成后，在cmd中依次执行 <code>node -v</code>、<code>npm -v</code> 和 <code>git --version</code>，看到类似以下版本号说明安装成功</p>\n<p><img src=\"/2022/09/06/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC.png\"></p>\n<h2 id=\"连接-Github\"><a href=\"#连接-Github\" class=\"headerlink\" title=\"连接 Github\"></a>连接 Github</h2><p>使用邮箱注册 <a href=\"https://link.zhihu.com/?target=https://github.com/\">GitHub</a> 账户，选择免费账户（Free），并完成邮件验证。</p>\n<p>在Windows桌面右键 -&gt; Git Bash Here，设置用户名和邮箱(此处的“GitHub 用户名”和”GitHub 邮箱”分别替换成个人的GitHub用户名和邮箱，下同）</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">git config <span class=\"hljs-literal\">--global</span> user.name <span class=\"hljs-string\">&quot;GitHub 用户名&quot;</span><br>git config <span class=\"hljs-literal\">--global</span> user.email <span class=\"hljs-string\">&quot;GitHub 邮箱&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>创建 SSH 密匙</strong>：</p>\n<p>输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车。</p>\n<p><strong>添加密匙：</strong></p>\n<p>进入 [C:\\Users\\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p>\n<p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p>\n<p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p>\n<p><strong>验证连接：</strong></p>\n<p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认。显示 “Hi xxx! You’ve successfully……” 即连接成功。如果没有出现“Hi xxx! You’ve successfully……”字样，可以再次输入 <code>ssh -T git@github.com</code>尝试。</p>\n<h2 id=\"创建-Github-Pages-仓库\"><a href=\"#创建-Github-Pages-仓库\" class=\"headerlink\" title=\"创建 Github Pages 仓库\"></a>创建 Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p>\n<ul>\n<li>Repository name 中输入 <code>用户名.github.io</code></li>\n<li>勾选 “Initialize this repository with a README”</li>\n<li>Description 选填</li>\n</ul>\n<p>填好后点击 Create repository 创建。</p>\n<p>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p>\n<h2 id=\"本地安装-Hexo-博客程序\"><a href=\"#本地安装-Hexo-博客程序\" class=\"headerlink\" title=\"本地安装 Hexo 博客程序\"></a>本地安装 Hexo 博客程序</h2><p>新建一个文件夹用来存放 Hexo 的程序文件，如 hexoblog。打开该文件夹，右键 -&gt; Git Bash Here。</p>\n<p>使用 npm 一键安装 Hexo 博客程序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">npm install -g hexo-cli<br></code></pre></td></tr></table></figure>\n\n<p>初始化并安装所需组件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">hexo init      # 初始化<br>npm install    # 安装组件<br></code></pre></td></tr></table></figure>\n\n<p>完成后依次输入下面命令，启动本地服务器进行预览：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">hexo g   # 生成页面<br>hexo s   # 启动预览<br></code></pre></td></tr></table></figure>\n\n<p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p>\n<h2 id=\"部署-Hexo-到-GitHub-Pages\"><a href=\"#部署-Hexo-到-GitHub-Pages\" class=\"headerlink\" title=\"部署 Hexo 到 GitHub Pages\"></a>部署 Hexo 到 GitHub Pages</h2><p>本地博客测试成功后就是上传到 GitHub 进行部署，使其能够在网络上访问。</p>\n<p>首先安装 hexo-deployer-git：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>\n\n<p>然后修改hexo程序文件夹中的_config.yml文件末尾的 deploy部分(建议使用notepad++打开)，修改成如下（注意替换GitHub用户名）：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">deploy:</span><br>  <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">git</span><br>  <span class=\"hljs-attr\">repository:</span> <span class=\"hljs-string\">git@github.com:用户名/用户名.github.io.git</span><br>  <span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">main</span><br></code></pre></td></tr></table></figure>\n\n<p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p>\n<p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p>\n<h2 id=\"博客图片问题处理\"><a href=\"#博客图片问题处理\" class=\"headerlink\" title=\"博客图片问题处理\"></a>博客图片问题处理</h2><p>本人采用开源软件MarkText软件进行本地博客编辑，该软件可以在GitHub下载。需要在本地编辑博客和上传部署后的博客上都正常阅览图片，需要安装一些插件来实现该需求，具体操作如下：</p>\n<ul>\n<li><p>在hexo主目录安装插件，在GitBash中输入：<code>npm install hexo-asset-image-for-hexo5 --save</code>  </p>\n</li>\n<li><p>在主目录的<code>_config.yml</code>文件中查找并修改<code>post_asset_folder</code>值为<code>true</code>：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">post_asset_folder:</span> <span class=\"hljs-literal\">true</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>这样在使用<code>hexo new &quot;article&quot;</code>创建新博客文章的时候，就会发现在文章的同级目录出现和md文件名相同的文件夹，可以在这个文件夹中放该文章的图片，例如test.png。例：</p>\n<table>\n<thead>\n<tr>\n<th>1  <br>2  <br>3</th>\n<th>├─article  <br>├──test.png  <br>└─article.md</th>\n</tr>\n</thead>\n</table>\n<ul>\n<li>写法：在文章里即可使用<code>![](./article/test.png)</code>在本地显示图片<code>test.png</code>，同时在静态网页中也可以正常显示。</li>\n</ul>\n<p><strong>注意：</strong>本文的hexo版本为6.2.0（可以通过hexo v查看），这里安装的图像插件为hexo-asset-image-for-hexo5是适用的（hexo5版本以上建议使用 hexo-asset-image-for-hexo5 ），网上绝大部分博客说的<code>npm install hexo-asset-image --save</code>经本人测试并不适配6.2.0版本的hexo。</p>\n<h2 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h2><p><strong>发布文章</strong></p>\n<p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">hexo new &quot;My New Post&quot;<br></code></pre></td></tr></table></figure>\n\n<p>然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用MarkText在该文件中撰写文章了。</p>\n<p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。<strong>以后每次发布文章都是这三条命令。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">hexo clean   # 清除缓存和已生成的静态文件<br>hexo g   # 生成页面<br>hexo d   # 部署发布<br></code></pre></td></tr></table></figure>\n\n<p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo clean、hexo g</code> 和 <code>hexo d</code> 发布。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">---<br>title: Hello World # 标题<br>date: 2019/3/26 hh:mm:ss # 时间<br>categories: # 分类<br><span class=\"hljs-bullet\">-</span> Diary<br>tags: # 标签<br><span class=\"hljs-bullet\">-</span> PS3<br><span class=\"hljs-section\">- Games</span><br><span class=\"hljs-section\">---</span><br><br>摘要<br>&lt;!--more--&gt;<br>正文<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"更换主题\"><a href=\"#更换主题\" class=\"headerlink\" title=\"更换主题\"></a>更换主题</h2><p>在 <a href=\"https://link.zhihu.com/?target=https://hexo.io/themes/\">Themes | Hexo</a> 选择一个喜欢的主题，并参照主题的文档来安装和配置主题。</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">hexo new &quot;name&quot;       # 新建文章<br>hexo new page &quot;name&quot;  # 新建页面<br>hexo g                # 生成页面<br>hexo d                # 部署<br>hexo g -d             # 生成页面并部署<br>hexo s                # 本地预览<br>hexo clean            # 清除缓存和已生成的静态文件<br>hexo help             # 帮助<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://zhuanlan.zhihu.com/p/60578464\">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p>\n<p><a href=\"https://www.idealx.cn/post/Hexo/hexo-asset-image/\">在Hexo中使用本地图片 - 个人学习 (idealx.cn)</a></p>\n<p><a href=\"https://github.com/fluid-dev/hexo-theme-fluid\">fluid-dev&#x2F;hexo-theme-fluid: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo (github.com)</a></p>\n"},{"title":"如何有效阅读一本书","date":"2022-09-11T13:20:31.000Z","_content":"\n# 信息\n\n《如何有效阅读一本书》 奥野宣之 江西人民出版社\n\n# 摘录\n\n- 读书笔记的作用：随想笔记、购书清单、各种报道的剪报、读书笔记\n- 过程中基本上是用不到笔记本的，读书时只需要画出重点做好记号，日后只需要确认想要落实的内容，记在读书笔记里就好\n- 读书的过程：选书、购书、读书、笔记、活用\n- 读书清单包括书名、作者、出版社、备注\n- 在某种意义上，购书清单并不只是单纯的“购物备忘录”，而是为了促进主观购书的矫正装置\n- 为了写出精练而深刻的读书笔记，你应该在读完一本书以后认真回想需要摘抄哪一\n   页哪一 行，思考怎样撰写读书笔记，然后严格地筛选需要摘抄的内容，尽量提炼自己的感想，争取用最短的语句表达深刻的含义\n- 写读书笔记感想的时候，不要写一些揣测的或者外来的想法，而是因该写自己的心声\n- 可以考虑定期进行读书笔记的重读工作\n- 多使用参考书：·地图 ·图鉴 ·统计数据 ·百科全书 ·年表 ·词典\n\n# 感想\n\n本书介绍了读书的一般流程和注意事项，关键点在于要有目的的读书，以做读书笔记为导向进行读书，精简读书笔记，适当重读活学活用\n","source":"_posts/如何有效阅读一本书.md","raw":"---\ntitle: 如何有效阅读一本书\ndate: 2022-09-11 21:20:31\ncategories: \n- 读书\ntags: \n- 读书与做人\n\n---\n\n# 信息\n\n《如何有效阅读一本书》 奥野宣之 江西人民出版社\n\n# 摘录\n\n- 读书笔记的作用：随想笔记、购书清单、各种报道的剪报、读书笔记\n- 过程中基本上是用不到笔记本的，读书时只需要画出重点做好记号，日后只需要确认想要落实的内容，记在读书笔记里就好\n- 读书的过程：选书、购书、读书、笔记、活用\n- 读书清单包括书名、作者、出版社、备注\n- 在某种意义上，购书清单并不只是单纯的“购物备忘录”，而是为了促进主观购书的矫正装置\n- 为了写出精练而深刻的读书笔记，你应该在读完一本书以后认真回想需要摘抄哪一\n   页哪一 行，思考怎样撰写读书笔记，然后严格地筛选需要摘抄的内容，尽量提炼自己的感想，争取用最短的语句表达深刻的含义\n- 写读书笔记感想的时候，不要写一些揣测的或者外来的想法，而是因该写自己的心声\n- 可以考虑定期进行读书笔记的重读工作\n- 多使用参考书：·地图 ·图鉴 ·统计数据 ·百科全书 ·年表 ·词典\n\n# 感想\n\n本书介绍了读书的一般流程和注意事项，关键点在于要有目的的读书，以做读书笔记为导向进行读书，精简读书笔记，适当重读活学活用\n","slug":"如何有效阅读一本书","published":1,"updated":"2022-10-28T14:47:40.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38w0000cq8t7cnxr85kw","content":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《如何有效阅读一本书》 奥野宣之 江西人民出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li>读书笔记的作用：随想笔记、购书清单、各种报道的剪报、读书笔记</li>\n<li>过程中基本上是用不到笔记本的，读书时只需要画出重点做好记号，日后只需要确认想要落实的内容，记在读书笔记里就好</li>\n<li>读书的过程：选书、购书、读书、笔记、活用</li>\n<li>读书清单包括书名、作者、出版社、备注</li>\n<li>在某种意义上，购书清单并不只是单纯的“购物备忘录”，而是为了促进主观购书的矫正装置</li>\n<li>为了写出精练而深刻的读书笔记，你应该在读完一本书以后认真回想需要摘抄哪一<br> 页哪一 行，思考怎样撰写读书笔记，然后严格地筛选需要摘抄的内容，尽量提炼自己的感想，争取用最短的语句表达深刻的含义</li>\n<li>写读书笔记感想的时候，不要写一些揣测的或者外来的想法，而是因该写自己的心声</li>\n<li>可以考虑定期进行读书笔记的重读工作</li>\n<li>多使用参考书：·地图 ·图鉴 ·统计数据 ·百科全书 ·年表 ·词典</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>本书介绍了读书的一般流程和注意事项，关键点在于要有目的的读书，以做读书笔记为导向进行读书，精简读书笔记，适当重读活学活用</p>\n","site":{"data":{}},"wordcount":426,"excerpt":"","more":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《如何有效阅读一本书》 奥野宣之 江西人民出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li>读书笔记的作用：随想笔记、购书清单、各种报道的剪报、读书笔记</li>\n<li>过程中基本上是用不到笔记本的，读书时只需要画出重点做好记号，日后只需要确认想要落实的内容，记在读书笔记里就好</li>\n<li>读书的过程：选书、购书、读书、笔记、活用</li>\n<li>读书清单包括书名、作者、出版社、备注</li>\n<li>在某种意义上，购书清单并不只是单纯的“购物备忘录”，而是为了促进主观购书的矫正装置</li>\n<li>为了写出精练而深刻的读书笔记，你应该在读完一本书以后认真回想需要摘抄哪一<br> 页哪一 行，思考怎样撰写读书笔记，然后严格地筛选需要摘抄的内容，尽量提炼自己的感想，争取用最短的语句表达深刻的含义</li>\n<li>写读书笔记感想的时候，不要写一些揣测的或者外来的想法，而是因该写自己的心声</li>\n<li>可以考虑定期进行读书笔记的重读工作</li>\n<li>多使用参考书：·地图 ·图鉴 ·统计数据 ·百科全书 ·年表 ·词典</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>本书介绍了读书的一般流程和注意事项，关键点在于要有目的的读书，以做读书笔记为导向进行读书，精简读书笔记，适当重读活学活用</p>\n"},{"title":"小狗钱钱","date":"2022-10-28T14:10:16.000Z","_content":"\n# 信息\n\n《小狗钱钱》 舍费尔 四川少年儿童出版社\n\n# 摘录\n\n- 永远不要在背后说别人的坏话\n- 不能总是抱怨命运的不公。在我们的生活中不是所有的事情都是公平的，不公平的情况很常见。但这并不意味着你就应该放弃，因为成功并不取决于你是否受到了公平的对待\n- 尊重他人和对人有礼貌是成功的重要因素。如果有人不喜欢你，很大程度上是因为你表现得不够友好。这会损害一个人的声誉，所以你不能那么做。另外，彬彬有礼也可以让以前并不信任你的人接纳\n- 我们推崇一种聪明的、简朴的生活方式。也就是说，宁愿购买一件一流产品，也不要不停地买许多的二流产品。而且，不要仅仅因为一件产品的外观不再时髦而新产品正在流行，就不断追逐新鲜的东西。生活质量不是由越来越多的高科技产品堆砌而成的，而体现在一些别的方面，比如悠闲地享受一下生活，增进邻里关系，表达感情或者从事艺术性和创造性的活动。\n- 出于分散风险的考虑，你应该把一部分钱投资在绝对安全的地方，应该始终储备一些现金。决不能把你全部的钱都投资在股票或者基金上面。\n- 只有当你把股票实际卖出的时候，才会有损失。\n- 没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。\n\n# 感想\n\n理财启蒙书籍，不过书中除了理财的其他的内容也具有一定的启发意义，以后可以让小朋友读一读。\n","source":"_posts/小狗钱钱.md","raw":"---\ntitle: 小狗钱钱\ndate: 2022-10-28 22:10:16\ncategories: \n- 读书\ntags: \n- 理财\n---\n\n# 信息\n\n《小狗钱钱》 舍费尔 四川少年儿童出版社\n\n# 摘录\n\n- 永远不要在背后说别人的坏话\n- 不能总是抱怨命运的不公。在我们的生活中不是所有的事情都是公平的，不公平的情况很常见。但这并不意味着你就应该放弃，因为成功并不取决于你是否受到了公平的对待\n- 尊重他人和对人有礼貌是成功的重要因素。如果有人不喜欢你，很大程度上是因为你表现得不够友好。这会损害一个人的声誉，所以你不能那么做。另外，彬彬有礼也可以让以前并不信任你的人接纳\n- 我们推崇一种聪明的、简朴的生活方式。也就是说，宁愿购买一件一流产品，也不要不停地买许多的二流产品。而且，不要仅仅因为一件产品的外观不再时髦而新产品正在流行，就不断追逐新鲜的东西。生活质量不是由越来越多的高科技产品堆砌而成的，而体现在一些别的方面，比如悠闲地享受一下生活，增进邻里关系，表达感情或者从事艺术性和创造性的活动。\n- 出于分散风险的考虑，你应该把一部分钱投资在绝对安全的地方，应该始终储备一些现金。决不能把你全部的钱都投资在股票或者基金上面。\n- 只有当你把股票实际卖出的时候，才会有损失。\n- 没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。\n\n# 感想\n\n理财启蒙书籍，不过书中除了理财的其他的内容也具有一定的启发意义，以后可以让小朋友读一读。\n","slug":"小狗钱钱","published":1,"updated":"2022-10-28T14:17:59.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38w1000gq8t7dpnrgcz2","content":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《小狗钱钱》 舍费尔 四川少年儿童出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li>永远不要在背后说别人的坏话</li>\n<li>不能总是抱怨命运的不公。在我们的生活中不是所有的事情都是公平的，不公平的情况很常见。但这并不意味着你就应该放弃，因为成功并不取决于你是否受到了公平的对待</li>\n<li>尊重他人和对人有礼貌是成功的重要因素。如果有人不喜欢你，很大程度上是因为你表现得不够友好。这会损害一个人的声誉，所以你不能那么做。另外，彬彬有礼也可以让以前并不信任你的人接纳</li>\n<li>我们推崇一种聪明的、简朴的生活方式。也就是说，宁愿购买一件一流产品，也不要不停地买许多的二流产品。而且，不要仅仅因为一件产品的外观不再时髦而新产品正在流行，就不断追逐新鲜的东西。生活质量不是由越来越多的高科技产品堆砌而成的，而体现在一些别的方面，比如悠闲地享受一下生活，增进邻里关系，表达感情或者从事艺术性和创造性的活动。</li>\n<li>出于分散风险的考虑，你应该把一部分钱投资在绝对安全的地方，应该始终储备一些现金。决不能把你全部的钱都投资在股票或者基金上面。</li>\n<li>只有当你把股票实际卖出的时候，才会有损失。</li>\n<li>没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>理财启蒙书籍，不过书中除了理财的其他的内容也具有一定的启发意义，以后可以让小朋友读一读。</p>\n","site":{"data":{}},"wordcount":565,"excerpt":"","more":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《小狗钱钱》 舍费尔 四川少年儿童出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li>永远不要在背后说别人的坏话</li>\n<li>不能总是抱怨命运的不公。在我们的生活中不是所有的事情都是公平的，不公平的情况很常见。但这并不意味着你就应该放弃，因为成功并不取决于你是否受到了公平的对待</li>\n<li>尊重他人和对人有礼貌是成功的重要因素。如果有人不喜欢你，很大程度上是因为你表现得不够友好。这会损害一个人的声誉，所以你不能那么做。另外，彬彬有礼也可以让以前并不信任你的人接纳</li>\n<li>我们推崇一种聪明的、简朴的生活方式。也就是说，宁愿购买一件一流产品，也不要不停地买许多的二流产品。而且，不要仅仅因为一件产品的外观不再时髦而新产品正在流行，就不断追逐新鲜的东西。生活质量不是由越来越多的高科技产品堆砌而成的，而体现在一些别的方面，比如悠闲地享受一下生活，增进邻里关系，表达感情或者从事艺术性和创造性的活动。</li>\n<li>出于分散风险的考虑，你应该把一部分钱投资在绝对安全的地方，应该始终储备一些现金。决不能把你全部的钱都投资在股票或者基金上面。</li>\n<li>只有当你把股票实际卖出的时候，才会有损失。</li>\n<li>没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>理财启蒙书籍，不过书中除了理财的其他的内容也具有一定的启发意义，以后可以让小朋友读一读。</p>\n"},{"title":"排序算法记录","date":"2022-10-14T14:28:57.000Z","_content":"\n# 排序算法\n\n## 快速排序\n\n```java\n    public static void quickSort(int[] nums, int start , int end){\n        if (nums == null || nums.length <= 1 || start >= end){\n            return;\n        }\n        int i = start;\n        int j = end;\n        int target = nums[i];\n        while (i < j){\n            while (nums[j] >= target && i < j){\n                j--;\n            }\n            if (i < j){\n                nums[i] = nums[j];\n                i++;\n            }\n            while (nums[i] <= target && i < j){\n                i++;\n            }\n            if (i < j){\n                nums[j] = nums[i];\n                j--;\n            }\n            nums[i] = target;\n        }\n        quickSort(nums, start, i - 1);\n        quickSort(nums, i + 1, end);\n    }\n```\n\n# 相关题目\n\n## 力扣215--数组中的第K个最大元素\n\n* 题目\n\n给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。\n\n* 堆排序\n\n利用优先队列来实现堆排序，时间复杂度 O(NlogK)，空间复杂度 O(K)\n\n```java\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        PriorityQueue<Integer> q = new PriorityQueue<>();\n        for (int i = 0 ;i < k; i++){\n            q.add(nums[i]);\n        }\n        for (int i = k; i < nums.length; i++){\n            if (nums[i] > q.peek()){\n                q.add(nums[i]);\n                q.poll();\n            }\n        }\n        return q.peek();\n    }\n}\n```\n\n* 快速选择法\n\n化用于快排，时间复杂度最差为O(N^2)，时间复杂度期望为O(N)，空间复杂度O(1)，对于不随机样本，可以人为加入随机选择的过程\n\n```java\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int l = 0;\n        int r = nums.length - 1;\n        k = nums.length - k;\n        while(l < r){\n            int p = setP(nums, l, r);\n            if (p == k){\n                return nums[p];\n            } else if (p < k){\n                l = p + 1;\n            } else {\n                r = p - 1;\n            }\n        }\n        return nums[l];\n    }\n\n    public int setP(int[] nums, int l, int r){\n        //在样本不具备随机性的情况下，可以人为加入随机性，提高计算效率\n        //int tempI = (int)(Math.random() * (r - l)) + l;\n        //int tempV = nums[l];\n        //nums[l] = nums[tempI];\n        //nums[tempI] = tempV;\n        int i = l;\n        int j = r;\n        int target = nums[i];\n        while (i < j){\n            while (i < j && nums[j] >= target){\n                j--;\n            }\n            if (i < j){\n                nums[i] = nums[j];\n                i++;\n            }\n            while (i < j && nums[i] <= target){\n                i++;\n            }\n            if (i < j){\n               nums[j] = nums[i];\n               j--;\n            }\n        }\n        nums[i] = target;\n        return i;\n    }\n}\n```\n\n## 力扣347--前 K 个高频元素\n\n* 题目\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。\n\n* 桶排序\n\n构建一个数组，将频数相同的元素放在同一个数组里\n\n```java\npublic int[] topKFrequent(int[] nums, int k) {\n        List<Integer> resList = new ArrayList<>(k);\n        int count = k;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums){\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        List<Integer>[] arr = new ArrayList[nums.length + 1];\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()){\n            if (arr[entry.getValue()] == null){\n                arr[entry.getValue()] = new ArrayList<>();\n            }\n            arr[entry.getValue()].add(entry.getKey());\n        }\n        for (int i = arr.length - 1; i >= 0; i--){\n            if (arr[i] == null){\n                continue;\n            }\n            for (int num : arr[i]){\n                resList.add(num);\n                count--;\n            }\n            if (count == 0){\n                break; \n            }\n        }\n        int[] res = new int[resList.size()];\n        for (int i = 0; i < resList.size(); i++){\n            res[i] = resList.get(i);\n        }\n        return res;\n    }\n```\n\n## 力扣451--根据字符出现频率排序\n\n类似347\n\n## 力扣75--颜色分类\n\n* 题目\n\n给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n* 三向切分快速排序\n\n注意，one和zero交换后，one需要加一，以保障one始终在zero前面，否则会出现异常。\n\n```java\npublic void sortColors(int[] nums) {\n    int zero = -1, one = 0, two = nums.length;\n    while (one < two) {\n        if (nums[one] == 0) {\n            swap(nums, ++zero, one++);\n        } else if (nums[one] == 2) {\n            swap(nums, --two, one);\n        } else {\n            ++one;\n        }\n    }\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int t = nums[i];\n    nums[i] = nums[j];\n    nums[j] = t;\n}\n```\n\n# 参考资料\n\nhttps://www.cyc2018.xyz/\n\nLeetcode\n","source":"_posts/排序算法记录.md","raw":"---\ntitle: 排序算法记录\ndate: 2022-10-14 22:28:57\ncategories: \n- 数据结构与算法\ntags: \n- 排序\n---\n\n# 排序算法\n\n## 快速排序\n\n```java\n    public static void quickSort(int[] nums, int start , int end){\n        if (nums == null || nums.length <= 1 || start >= end){\n            return;\n        }\n        int i = start;\n        int j = end;\n        int target = nums[i];\n        while (i < j){\n            while (nums[j] >= target && i < j){\n                j--;\n            }\n            if (i < j){\n                nums[i] = nums[j];\n                i++;\n            }\n            while (nums[i] <= target && i < j){\n                i++;\n            }\n            if (i < j){\n                nums[j] = nums[i];\n                j--;\n            }\n            nums[i] = target;\n        }\n        quickSort(nums, start, i - 1);\n        quickSort(nums, i + 1, end);\n    }\n```\n\n# 相关题目\n\n## 力扣215--数组中的第K个最大元素\n\n* 题目\n\n给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。\n\n* 堆排序\n\n利用优先队列来实现堆排序，时间复杂度 O(NlogK)，空间复杂度 O(K)\n\n```java\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        PriorityQueue<Integer> q = new PriorityQueue<>();\n        for (int i = 0 ;i < k; i++){\n            q.add(nums[i]);\n        }\n        for (int i = k; i < nums.length; i++){\n            if (nums[i] > q.peek()){\n                q.add(nums[i]);\n                q.poll();\n            }\n        }\n        return q.peek();\n    }\n}\n```\n\n* 快速选择法\n\n化用于快排，时间复杂度最差为O(N^2)，时间复杂度期望为O(N)，空间复杂度O(1)，对于不随机样本，可以人为加入随机选择的过程\n\n```java\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int l = 0;\n        int r = nums.length - 1;\n        k = nums.length - k;\n        while(l < r){\n            int p = setP(nums, l, r);\n            if (p == k){\n                return nums[p];\n            } else if (p < k){\n                l = p + 1;\n            } else {\n                r = p - 1;\n            }\n        }\n        return nums[l];\n    }\n\n    public int setP(int[] nums, int l, int r){\n        //在样本不具备随机性的情况下，可以人为加入随机性，提高计算效率\n        //int tempI = (int)(Math.random() * (r - l)) + l;\n        //int tempV = nums[l];\n        //nums[l] = nums[tempI];\n        //nums[tempI] = tempV;\n        int i = l;\n        int j = r;\n        int target = nums[i];\n        while (i < j){\n            while (i < j && nums[j] >= target){\n                j--;\n            }\n            if (i < j){\n                nums[i] = nums[j];\n                i++;\n            }\n            while (i < j && nums[i] <= target){\n                i++;\n            }\n            if (i < j){\n               nums[j] = nums[i];\n               j--;\n            }\n        }\n        nums[i] = target;\n        return i;\n    }\n}\n```\n\n## 力扣347--前 K 个高频元素\n\n* 题目\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。\n\n* 桶排序\n\n构建一个数组，将频数相同的元素放在同一个数组里\n\n```java\npublic int[] topKFrequent(int[] nums, int k) {\n        List<Integer> resList = new ArrayList<>(k);\n        int count = k;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums){\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        List<Integer>[] arr = new ArrayList[nums.length + 1];\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()){\n            if (arr[entry.getValue()] == null){\n                arr[entry.getValue()] = new ArrayList<>();\n            }\n            arr[entry.getValue()].add(entry.getKey());\n        }\n        for (int i = arr.length - 1; i >= 0; i--){\n            if (arr[i] == null){\n                continue;\n            }\n            for (int num : arr[i]){\n                resList.add(num);\n                count--;\n            }\n            if (count == 0){\n                break; \n            }\n        }\n        int[] res = new int[resList.size()];\n        for (int i = 0; i < resList.size(); i++){\n            res[i] = resList.get(i);\n        }\n        return res;\n    }\n```\n\n## 力扣451--根据字符出现频率排序\n\n类似347\n\n## 力扣75--颜色分类\n\n* 题目\n\n给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n* 三向切分快速排序\n\n注意，one和zero交换后，one需要加一，以保障one始终在zero前面，否则会出现异常。\n\n```java\npublic void sortColors(int[] nums) {\n    int zero = -1, one = 0, two = nums.length;\n    while (one < two) {\n        if (nums[one] == 0) {\n            swap(nums, ++zero, one++);\n        } else if (nums[one] == 2) {\n            swap(nums, --two, one);\n        } else {\n            ++one;\n        }\n    }\n}\n\nprivate void swap(int[] nums, int i, int j) {\n    int t = nums[i];\n    nums[i] = nums[j];\n    nums[j] = t;\n}\n```\n\n# 参考资料\n\nhttps://www.cyc2018.xyz/\n\nLeetcode\n","slug":"排序算法记录","published":1,"updated":"2022-10-16T08:14:17.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38w3000iq8t703w5gi4o","content":"<h1 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h1><h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">quickSort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> start , <span class=\"hljs-type\">int</span> end)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (nums == <span class=\"hljs-literal\">null</span> || nums.length &lt;= <span class=\"hljs-number\">1</span> || start &gt;= end)&#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> start;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> end;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">target</span> <span class=\"hljs-operator\">=</span> nums[i];<br>    <span class=\"hljs-keyword\">while</span> (i &lt; j)&#123;<br>        <span class=\"hljs-keyword\">while</span> (nums[j] &gt;= target &amp;&amp; i &lt; j)&#123;<br>            j--;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (i &lt; j)&#123;<br>            nums[i] = nums[j];<br>            i++;<br>        &#125;<br>        <span class=\"hljs-keyword\">while</span> (nums[i] &lt;= target &amp;&amp; i &lt; j)&#123;<br>            i++;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (i &lt; j)&#123;<br>            nums[j] = nums[i];<br>            j--;<br>        &#125;<br>        nums[i] = target;<br>    &#125;<br>    quickSort(nums, start, i - <span class=\"hljs-number\">1</span>);<br>    quickSort(nums, i + <span class=\"hljs-number\">1</span>, end);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"相关题目\"><a href=\"#相关题目\" class=\"headerlink\" title=\"相关题目\"></a>相关题目</h1><h2 id=\"力扣215–数组中的第K个最大元素\"><a href=\"#力扣215–数组中的第K个最大元素\" class=\"headerlink\" title=\"力扣215–数组中的第K个最大元素\"></a>力扣215–数组中的第K个最大元素</h2><ul>\n<li>题目</li>\n</ul>\n<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p>\n<ul>\n<li>堆排序</li>\n</ul>\n<p>利用优先队列来实现堆排序，时间复杂度 O(NlogK)，空间复杂度 O(K)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">findKthLargest</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; q = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PriorityQueue</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> ;i &lt; k; i++)&#123;<br>            q.add(nums[i]);<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> k; i &lt; nums.length; i++)&#123;<br>            <span class=\"hljs-keyword\">if</span> (nums[i] &gt; q.peek())&#123;<br>                q.add(nums[i]);<br>                q.poll();<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> q.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>快速选择法</li>\n</ul>\n<p>化用于快排，时间复杂度最差为O(N^2)，时间复杂度期望为O(N)，空间复杂度O(1)，对于不随机样本，可以人为加入随机选择的过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">findKthLargest</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> k)</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">l</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">r</span> <span class=\"hljs-operator\">=</span> nums.length - <span class=\"hljs-number\">1</span>;<br>        k = nums.length - k;<br>        <span class=\"hljs-keyword\">while</span>(l &lt; r)&#123;<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> setP(nums, l, r);<br>            <span class=\"hljs-keyword\">if</span> (p == k)&#123;<br>                <span class=\"hljs-keyword\">return</span> nums[p];<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (p &lt; k)&#123;<br>                l = p + <span class=\"hljs-number\">1</span>;<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                r = p - <span class=\"hljs-number\">1</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> nums[l];<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">setP</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> l, <span class=\"hljs-type\">int</span> r)</span>&#123;<br>        <span class=\"hljs-comment\">//在样本不具备随机性的情况下，可以人为加入随机性，提高计算效率</span><br>        <span class=\"hljs-comment\">//int tempI = (int)(Math.random() * (r - l)) + l;</span><br>        <span class=\"hljs-comment\">//int tempV = nums[l];</span><br>        <span class=\"hljs-comment\">//nums[l] = nums[tempI];</span><br>        <span class=\"hljs-comment\">//nums[tempI] = tempV;</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> l;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> r;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">target</span> <span class=\"hljs-operator\">=</span> nums[i];<br>        <span class=\"hljs-keyword\">while</span> (i &lt; j)&#123;<br>            <span class=\"hljs-keyword\">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= target)&#123;<br>                j--;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (i &lt; j)&#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>            <span class=\"hljs-keyword\">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= target)&#123;<br>                i++;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (i &lt; j)&#123;<br>               nums[j] = nums[i];<br>               j--;<br>            &#125;<br>        &#125;<br>        nums[i] = target;<br>        <span class=\"hljs-keyword\">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"力扣347–前-K-个高频元素\"><a href=\"#力扣347–前-K-个高频元素\" class=\"headerlink\" title=\"力扣347–前 K 个高频元素\"></a>力扣347–前 K 个高频元素</h2><ul>\n<li>题目</li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。</p>\n<ul>\n<li>桶排序</li>\n</ul>\n<p>构建一个数组，将频数相同的元素放在同一个数组里</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span>[] topKFrequent(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> k) &#123;<br>        List&lt;Integer&gt; resList = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;(k);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> k;<br>        Map&lt;Integer, Integer&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : nums)&#123;<br>            map.put(num, map.getOrDefault(num, <span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">1</span>);<br>        &#125;<br>        List&lt;Integer&gt;[] arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>[nums.length + <span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[entry.getValue()] == <span class=\"hljs-literal\">null</span>)&#123;<br>                arr[entry.getValue()] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>            &#125;<br>            arr[entry.getValue()].add(entry.getKey());<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> arr.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)&#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[i] == <span class=\"hljs-literal\">null</span>)&#123;<br>                <span class=\"hljs-keyword\">continue</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : arr[i])&#123;<br>                resList.add(num);<br>                count--;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (count == <span class=\"hljs-number\">0</span>)&#123;<br>                <span class=\"hljs-keyword\">break</span>; <br>            &#125;<br>        &#125;<br>        <span class=\"hljs-type\">int</span>[] res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[resList.size()];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; resList.size(); i++)&#123;<br>            res[i] = resList.get(i);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"力扣451–根据字符出现频率排序\"><a href=\"#力扣451–根据字符出现频率排序\" class=\"headerlink\" title=\"力扣451–根据字符出现频率排序\"></a>力扣451–根据字符出现频率排序</h2><p>类似347</p>\n<h2 id=\"力扣75–颜色分类\"><a href=\"#力扣75–颜色分类\" class=\"headerlink\" title=\"力扣75–颜色分类\"></a>力扣75–颜色分类</h2><ul>\n<li>题目</li>\n</ul>\n<p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>\n<ul>\n<li>三向切分快速排序</li>\n</ul>\n<p>注意，one和zero交换后，one需要加一，以保障one始终在zero前面，否则会出现异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sortColors</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums)</span> &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">zero</span> <span class=\"hljs-operator\">=</span> -<span class=\"hljs-number\">1</span>, one = <span class=\"hljs-number\">0</span>, two = nums.length;<br>    <span class=\"hljs-keyword\">while</span> (one &lt; two) &#123;<br>        <span class=\"hljs-keyword\">if</span> (nums[one] == <span class=\"hljs-number\">0</span>) &#123;<br>            swap(nums, ++zero, one++);<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nums[one] == <span class=\"hljs-number\">2</span>) &#123;<br>            swap(nums, --two, one);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            ++one;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> i, <span class=\"hljs-type\">int</span> j)</span> &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">t</span> <span class=\"hljs-operator\">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = t;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.cyc2018.xyz/\">https://www.cyc2018.xyz/</a></p>\n<p>Leetcode</p>\n","site":{"data":{}},"wordcount":3257,"excerpt":"","more":"<h1 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h1><h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">quickSort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> start , <span class=\"hljs-type\">int</span> end)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (nums == <span class=\"hljs-literal\">null</span> || nums.length &lt;= <span class=\"hljs-number\">1</span> || start &gt;= end)&#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> start;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> end;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">target</span> <span class=\"hljs-operator\">=</span> nums[i];<br>    <span class=\"hljs-keyword\">while</span> (i &lt; j)&#123;<br>        <span class=\"hljs-keyword\">while</span> (nums[j] &gt;= target &amp;&amp; i &lt; j)&#123;<br>            j--;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (i &lt; j)&#123;<br>            nums[i] = nums[j];<br>            i++;<br>        &#125;<br>        <span class=\"hljs-keyword\">while</span> (nums[i] &lt;= target &amp;&amp; i &lt; j)&#123;<br>            i++;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (i &lt; j)&#123;<br>            nums[j] = nums[i];<br>            j--;<br>        &#125;<br>        nums[i] = target;<br>    &#125;<br>    quickSort(nums, start, i - <span class=\"hljs-number\">1</span>);<br>    quickSort(nums, i + <span class=\"hljs-number\">1</span>, end);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"相关题目\"><a href=\"#相关题目\" class=\"headerlink\" title=\"相关题目\"></a>相关题目</h1><h2 id=\"力扣215–数组中的第K个最大元素\"><a href=\"#力扣215–数组中的第K个最大元素\" class=\"headerlink\" title=\"力扣215–数组中的第K个最大元素\"></a>力扣215–数组中的第K个最大元素</h2><ul>\n<li>题目</li>\n</ul>\n<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p>\n<ul>\n<li>堆排序</li>\n</ul>\n<p>利用优先队列来实现堆排序，时间复杂度 O(NlogK)，空间复杂度 O(K)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">findKthLargest</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; q = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PriorityQueue</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> ;i &lt; k; i++)&#123;<br>            q.add(nums[i]);<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> k; i &lt; nums.length; i++)&#123;<br>            <span class=\"hljs-keyword\">if</span> (nums[i] &gt; q.peek())&#123;<br>                q.add(nums[i]);<br>                q.poll();<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> q.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>快速选择法</li>\n</ul>\n<p>化用于快排，时间复杂度最差为O(N^2)，时间复杂度期望为O(N)，空间复杂度O(1)，对于不随机样本，可以人为加入随机选择的过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">findKthLargest</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> k)</span> &#123;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">l</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">r</span> <span class=\"hljs-operator\">=</span> nums.length - <span class=\"hljs-number\">1</span>;<br>        k = nums.length - k;<br>        <span class=\"hljs-keyword\">while</span>(l &lt; r)&#123;<br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> setP(nums, l, r);<br>            <span class=\"hljs-keyword\">if</span> (p == k)&#123;<br>                <span class=\"hljs-keyword\">return</span> nums[p];<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (p &lt; k)&#123;<br>                l = p + <span class=\"hljs-number\">1</span>;<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                r = p - <span class=\"hljs-number\">1</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> nums[l];<br>    &#125;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">setP</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> l, <span class=\"hljs-type\">int</span> r)</span>&#123;<br>        <span class=\"hljs-comment\">//在样本不具备随机性的情况下，可以人为加入随机性，提高计算效率</span><br>        <span class=\"hljs-comment\">//int tempI = (int)(Math.random() * (r - l)) + l;</span><br>        <span class=\"hljs-comment\">//int tempV = nums[l];</span><br>        <span class=\"hljs-comment\">//nums[l] = nums[tempI];</span><br>        <span class=\"hljs-comment\">//nums[tempI] = tempV;</span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> l;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> r;<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">target</span> <span class=\"hljs-operator\">=</span> nums[i];<br>        <span class=\"hljs-keyword\">while</span> (i &lt; j)&#123;<br>            <span class=\"hljs-keyword\">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= target)&#123;<br>                j--;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (i &lt; j)&#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>            <span class=\"hljs-keyword\">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= target)&#123;<br>                i++;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (i &lt; j)&#123;<br>               nums[j] = nums[i];<br>               j--;<br>            &#125;<br>        &#125;<br>        nums[i] = target;<br>        <span class=\"hljs-keyword\">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"力扣347–前-K-个高频元素\"><a href=\"#力扣347–前-K-个高频元素\" class=\"headerlink\" title=\"力扣347–前 K 个高频元素\"></a>力扣347–前 K 个高频元素</h2><ul>\n<li>题目</li>\n</ul>\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。</p>\n<ul>\n<li>桶排序</li>\n</ul>\n<p>构建一个数组，将频数相同的元素放在同一个数组里</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span>[] topKFrequent(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> k) &#123;<br>        List&lt;Integer&gt; resList = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;(k);<br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> k;<br>        Map&lt;Integer, Integer&gt; map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : nums)&#123;<br>            map.put(num, map.getOrDefault(num, <span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">1</span>);<br>        &#125;<br>        List&lt;Integer&gt;[] arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>[nums.length + <span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[entry.getValue()] == <span class=\"hljs-literal\">null</span>)&#123;<br>                arr[entry.getValue()] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();<br>            &#125;<br>            arr[entry.getValue()].add(entry.getKey());<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> arr.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)&#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[i] == <span class=\"hljs-literal\">null</span>)&#123;<br>                <span class=\"hljs-keyword\">continue</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : arr[i])&#123;<br>                resList.add(num);<br>                count--;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (count == <span class=\"hljs-number\">0</span>)&#123;<br>                <span class=\"hljs-keyword\">break</span>; <br>            &#125;<br>        &#125;<br>        <span class=\"hljs-type\">int</span>[] res = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[resList.size()];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; resList.size(); i++)&#123;<br>            res[i] = resList.get(i);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"力扣451–根据字符出现频率排序\"><a href=\"#力扣451–根据字符出现频率排序\" class=\"headerlink\" title=\"力扣451–根据字符出现频率排序\"></a>力扣451–根据字符出现频率排序</h2><p>类似347</p>\n<h2 id=\"力扣75–颜色分类\"><a href=\"#力扣75–颜色分类\" class=\"headerlink\" title=\"力扣75–颜色分类\"></a>力扣75–颜色分类</h2><ul>\n<li>题目</li>\n</ul>\n<p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>\n<ul>\n<li>三向切分快速排序</li>\n</ul>\n<p>注意，one和zero交换后，one需要加一，以保障one始终在zero前面，否则会出现异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sortColors</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums)</span> &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">zero</span> <span class=\"hljs-operator\">=</span> -<span class=\"hljs-number\">1</span>, one = <span class=\"hljs-number\">0</span>, two = nums.length;<br>    <span class=\"hljs-keyword\">while</span> (one &lt; two) &#123;<br>        <span class=\"hljs-keyword\">if</span> (nums[one] == <span class=\"hljs-number\">0</span>) &#123;<br>            swap(nums, ++zero, one++);<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nums[one] == <span class=\"hljs-number\">2</span>) &#123;<br>            swap(nums, --two, one);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            ++one;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] nums, <span class=\"hljs-type\">int</span> i, <span class=\"hljs-type\">int</span> j)</span> &#123;<br>    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">t</span> <span class=\"hljs-operator\">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = t;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://www.cyc2018.xyz/\">https://www.cyc2018.xyz/</a></p>\n<p>Leetcode</p>\n"},{"title":"胃靠养,肠靠清","date":"2022-10-09T14:02:15.000Z","_content":"\n# 1 信息\n\n《胃靠养，肠靠清》李博 江苏凤凰科学技术出版社\n\n# 2 摘录\n\n- 现代社会营养不良导致的疾病几乎消失了，取而代之的是营养过剩引起的各种疾病。所以，少吃一些，才是不浪费，才是对身体负责。\n- 能真正起到保健作用的，就是自然天赐的食物、平和的内心，以及适度的运动。\n- 垃圾食品中排在第一位的是油炸品，第二位是腌制品。\n- 晚餐应该遵循“四少”，即少盐少油少脂肪少辣的基本原则。不要忽视每一餐饭，日积月累，影响深远。如果能做到这“晚餐四少”，就代表着我们离高血压、高血脂、胃食管反流和痔疮等一系列病症都远了很多。\n- 不生气不代表憋着，而是要正确地疏导和发泄，这样才是对身体有利的，比如去旅游、参加户外活动等。\n- 早餐的鸡蛋必不可少，可以吃烧饼，不要吃油条、油饼之类的，豆腐脑不如喝粥和豆浆。中午的肉类多吃一些牛肉，蔬菜可以考虑胡萝卜、西红柿、土豆及各种新鲜的绿叶菜。晚餐推荐豆粥，加入薏米、山药和红枣有利于慢性胃炎的恢复。\n- 还是希望大家做个“有心人”，密切关注自己的身体情况，长时间不适时千万不要忍着，越早去医院诊断越好。\n- 要想远离胃癌以及各种癌症，起码要做到以下3点：\n   ①保持心情舒畅，让身体的内分泌系统处于良性循环。②均衡饮食，避免胃癌的外界因素。还要特别说一句，不要乱吃补品。就算是维生素，也不是多多益善，过量进补有害无益。有研究表明，β-胡萝卜素摄入过量有引起胃癌的风险。③坚持体育锻炼，促进新陈代谢。\n- 胆结石、胆囊炎这俩“坏小子”是怎么成长起来的？\n   不吃早饭是“主犯”\n- 与疾病化敌为友，或者和谐共处，是很多疾病治疗的思路。如果能够保持一个平静的心态，允许身体的不完美，完全可以生活得更好，不必纠结于每天与疾病的斗争。\n- 推荐早晨起来先饮用一杯凉开水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。\n- 强烈推荐有氧运动，有时运动治疗便秘的效果是您意想不到的。每周运动3次为宜，每次1小时。除以有氧运动为主外，还可以增加仰卧起坐等腹部局部锻炼。运动的强度以出汗30分钟以上为宜。\n\n# 3 感想\n\n- 饮食方面的注意事项：避免油炸、腌制品；做饭少盐少油少脂肪少辣；早餐鸡蛋和豆浆配主食，中午建议牛肉和蔬菜，晚餐建议薏米、山药、红枣豆粥，吃八分饱；推荐早晨起来先饮用一杯温水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。\n- 其他方面注意：坚持有氧锻炼；保持平和心态，适当旅游户外运动调整情绪；长期不适及时就医\n","source":"_posts/胃靠养-肠靠清.md","raw":"---\ntitle: 胃靠养,肠靠清\ndate: 2022-10-09 22:02:15\ncategories: \n- 读书\ntags: \n- 养生\n---\n\n# 1 信息\n\n《胃靠养，肠靠清》李博 江苏凤凰科学技术出版社\n\n# 2 摘录\n\n- 现代社会营养不良导致的疾病几乎消失了，取而代之的是营养过剩引起的各种疾病。所以，少吃一些，才是不浪费，才是对身体负责。\n- 能真正起到保健作用的，就是自然天赐的食物、平和的内心，以及适度的运动。\n- 垃圾食品中排在第一位的是油炸品，第二位是腌制品。\n- 晚餐应该遵循“四少”，即少盐少油少脂肪少辣的基本原则。不要忽视每一餐饭，日积月累，影响深远。如果能做到这“晚餐四少”，就代表着我们离高血压、高血脂、胃食管反流和痔疮等一系列病症都远了很多。\n- 不生气不代表憋着，而是要正确地疏导和发泄，这样才是对身体有利的，比如去旅游、参加户外活动等。\n- 早餐的鸡蛋必不可少，可以吃烧饼，不要吃油条、油饼之类的，豆腐脑不如喝粥和豆浆。中午的肉类多吃一些牛肉，蔬菜可以考虑胡萝卜、西红柿、土豆及各种新鲜的绿叶菜。晚餐推荐豆粥，加入薏米、山药和红枣有利于慢性胃炎的恢复。\n- 还是希望大家做个“有心人”，密切关注自己的身体情况，长时间不适时千万不要忍着，越早去医院诊断越好。\n- 要想远离胃癌以及各种癌症，起码要做到以下3点：\n   ①保持心情舒畅，让身体的内分泌系统处于良性循环。②均衡饮食，避免胃癌的外界因素。还要特别说一句，不要乱吃补品。就算是维生素，也不是多多益善，过量进补有害无益。有研究表明，β-胡萝卜素摄入过量有引起胃癌的风险。③坚持体育锻炼，促进新陈代谢。\n- 胆结石、胆囊炎这俩“坏小子”是怎么成长起来的？\n   不吃早饭是“主犯”\n- 与疾病化敌为友，或者和谐共处，是很多疾病治疗的思路。如果能够保持一个平静的心态，允许身体的不完美，完全可以生活得更好，不必纠结于每天与疾病的斗争。\n- 推荐早晨起来先饮用一杯凉开水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。\n- 强烈推荐有氧运动，有时运动治疗便秘的效果是您意想不到的。每周运动3次为宜，每次1小时。除以有氧运动为主外，还可以增加仰卧起坐等腹部局部锻炼。运动的强度以出汗30分钟以上为宜。\n\n# 3 感想\n\n- 饮食方面的注意事项：避免油炸、腌制品；做饭少盐少油少脂肪少辣；早餐鸡蛋和豆浆配主食，中午建议牛肉和蔬菜，晚餐建议薏米、山药、红枣豆粥，吃八分饱；推荐早晨起来先饮用一杯温水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。\n- 其他方面注意：坚持有氧锻炼；保持平和心态，适当旅游户外运动调整情绪；长期不适及时就医\n","slug":"胃靠养-肠靠清","published":1,"updated":"2022-10-28T14:51:14.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38w4000nq8t7bp032856","content":"<h1 id=\"1-信息\"><a href=\"#1-信息\" class=\"headerlink\" title=\"1 信息\"></a>1 信息</h1><p>《胃靠养，肠靠清》李博 江苏凤凰科学技术出版社</p>\n<h1 id=\"2-摘录\"><a href=\"#2-摘录\" class=\"headerlink\" title=\"2 摘录\"></a>2 摘录</h1><ul>\n<li>现代社会营养不良导致的疾病几乎消失了，取而代之的是营养过剩引起的各种疾病。所以，少吃一些，才是不浪费，才是对身体负责。</li>\n<li>能真正起到保健作用的，就是自然天赐的食物、平和的内心，以及适度的运动。</li>\n<li>垃圾食品中排在第一位的是油炸品，第二位是腌制品。</li>\n<li>晚餐应该遵循“四少”，即少盐少油少脂肪少辣的基本原则。不要忽视每一餐饭，日积月累，影响深远。如果能做到这“晚餐四少”，就代表着我们离高血压、高血脂、胃食管反流和痔疮等一系列病症都远了很多。</li>\n<li>不生气不代表憋着，而是要正确地疏导和发泄，这样才是对身体有利的，比如去旅游、参加户外活动等。</li>\n<li>早餐的鸡蛋必不可少，可以吃烧饼，不要吃油条、油饼之类的，豆腐脑不如喝粥和豆浆。中午的肉类多吃一些牛肉，蔬菜可以考虑胡萝卜、西红柿、土豆及各种新鲜的绿叶菜。晚餐推荐豆粥，加入薏米、山药和红枣有利于慢性胃炎的恢复。</li>\n<li>还是希望大家做个“有心人”，密切关注自己的身体情况，长时间不适时千万不要忍着，越早去医院诊断越好。</li>\n<li>要想远离胃癌以及各种癌症，起码要做到以下3点：<br> ①保持心情舒畅，让身体的内分泌系统处于良性循环。②均衡饮食，避免胃癌的外界因素。还要特别说一句，不要乱吃补品。就算是维生素，也不是多多益善，过量进补有害无益。有研究表明，β-胡萝卜素摄入过量有引起胃癌的风险。③坚持体育锻炼，促进新陈代谢。</li>\n<li>胆结石、胆囊炎这俩“坏小子”是怎么成长起来的？<br> 不吃早饭是“主犯”</li>\n<li>与疾病化敌为友，或者和谐共处，是很多疾病治疗的思路。如果能够保持一个平静的心态，允许身体的不完美，完全可以生活得更好，不必纠结于每天与疾病的斗争。</li>\n<li>推荐早晨起来先饮用一杯凉开水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。</li>\n<li>强烈推荐有氧运动，有时运动治疗便秘的效果是您意想不到的。每周运动3次为宜，每次1小时。除以有氧运动为主外，还可以增加仰卧起坐等腹部局部锻炼。运动的强度以出汗30分钟以上为宜。</li>\n</ul>\n<h1 id=\"3-感想\"><a href=\"#3-感想\" class=\"headerlink\" title=\"3 感想\"></a>3 感想</h1><ul>\n<li>饮食方面的注意事项：避免油炸、腌制品；做饭少盐少油少脂肪少辣；早餐鸡蛋和豆浆配主食，中午建议牛肉和蔬菜，晚餐建议薏米、山药、红枣豆粥，吃八分饱；推荐早晨起来先饮用一杯温水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。</li>\n<li>其他方面注意：坚持有氧锻炼；保持平和心态，适当旅游户外运动调整情绪；长期不适及时就医</li>\n</ul>\n","site":{"data":{}},"wordcount":1010,"excerpt":"","more":"<h1 id=\"1-信息\"><a href=\"#1-信息\" class=\"headerlink\" title=\"1 信息\"></a>1 信息</h1><p>《胃靠养，肠靠清》李博 江苏凤凰科学技术出版社</p>\n<h1 id=\"2-摘录\"><a href=\"#2-摘录\" class=\"headerlink\" title=\"2 摘录\"></a>2 摘录</h1><ul>\n<li>现代社会营养不良导致的疾病几乎消失了，取而代之的是营养过剩引起的各种疾病。所以，少吃一些，才是不浪费，才是对身体负责。</li>\n<li>能真正起到保健作用的，就是自然天赐的食物、平和的内心，以及适度的运动。</li>\n<li>垃圾食品中排在第一位的是油炸品，第二位是腌制品。</li>\n<li>晚餐应该遵循“四少”，即少盐少油少脂肪少辣的基本原则。不要忽视每一餐饭，日积月累，影响深远。如果能做到这“晚餐四少”，就代表着我们离高血压、高血脂、胃食管反流和痔疮等一系列病症都远了很多。</li>\n<li>不生气不代表憋着，而是要正确地疏导和发泄，这样才是对身体有利的，比如去旅游、参加户外活动等。</li>\n<li>早餐的鸡蛋必不可少，可以吃烧饼，不要吃油条、油饼之类的，豆腐脑不如喝粥和豆浆。中午的肉类多吃一些牛肉，蔬菜可以考虑胡萝卜、西红柿、土豆及各种新鲜的绿叶菜。晚餐推荐豆粥，加入薏米、山药和红枣有利于慢性胃炎的恢复。</li>\n<li>还是希望大家做个“有心人”，密切关注自己的身体情况，长时间不适时千万不要忍着，越早去医院诊断越好。</li>\n<li>要想远离胃癌以及各种癌症，起码要做到以下3点：<br> ①保持心情舒畅，让身体的内分泌系统处于良性循环。②均衡饮食，避免胃癌的外界因素。还要特别说一句，不要乱吃补品。就算是维生素，也不是多多益善，过量进补有害无益。有研究表明，β-胡萝卜素摄入过量有引起胃癌的风险。③坚持体育锻炼，促进新陈代谢。</li>\n<li>胆结石、胆囊炎这俩“坏小子”是怎么成长起来的？<br> 不吃早饭是“主犯”</li>\n<li>与疾病化敌为友，或者和谐共处，是很多疾病治疗的思路。如果能够保持一个平静的心态，允许身体的不完美，完全可以生活得更好，不必纠结于每天与疾病的斗争。</li>\n<li>推荐早晨起来先饮用一杯凉开水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。</li>\n<li>强烈推荐有氧运动，有时运动治疗便秘的效果是您意想不到的。每周运动3次为宜，每次1小时。除以有氧运动为主外，还可以增加仰卧起坐等腹部局部锻炼。运动的强度以出汗30分钟以上为宜。</li>\n</ul>\n<h1 id=\"3-感想\"><a href=\"#3-感想\" class=\"headerlink\" title=\"3 感想\"></a>3 感想</h1><ul>\n<li>饮食方面的注意事项：避免油炸、腌制品；做饭少盐少油少脂肪少辣；早餐鸡蛋和豆浆配主食，中午建议牛肉和蔬菜，晚餐建议薏米、山药、红枣豆粥，吃八分饱；推荐早晨起来先饮用一杯温水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。</li>\n<li>其他方面注意：坚持有氧锻炼；保持平和心态，适当旅游户外运动调整情绪；长期不适及时就医</li>\n</ul>\n"},{"title":"自控力","date":"2022-09-11T13:41:08.000Z","_content":"\n# 信息\n\n《自控力》 麦格尼格尔 印刷工业出版社\n\n# 摘录\n\n- 如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做\n- 大多数心理学家和营养学家推荐低血糖饮食，因为它能让你的血糖稳定。低血糖食品包括瘦肉蛋白、坚果和豆类、粗纤维谷类和麦片、大多数的水果和蔬菜。\n- 美国心理学家协会的调查发现，最有效的解压方法包括：锻炼、阅读、听音乐、与家人朋友相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。最没效果的缓解压力的方法则包括：赌博、购物、抽烟、喝酒、暴饮暴食、玩游戏、上网、花两小时以上看电视或电影。\n\n# 感想\n\n书籍实用性不强，参照建议展开冥想确实对身心有一定帮助。\n","source":"_posts/自控力.md","raw":"---\ntitle: 自控力\ndate: 2022-09-11 21:41:08\ncategories: \n- 读书\ntags: \n- 心理\n---\n\n# 信息\n\n《自控力》 麦格尼格尔 印刷工业出版社\n\n# 摘录\n\n- 如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做\n- 大多数心理学家和营养学家推荐低血糖饮食，因为它能让你的血糖稳定。低血糖食品包括瘦肉蛋白、坚果和豆类、粗纤维谷类和麦片、大多数的水果和蔬菜。\n- 美国心理学家协会的调查发现，最有效的解压方法包括：锻炼、阅读、听音乐、与家人朋友相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。最没效果的缓解压力的方法则包括：赌博、购物、抽烟、喝酒、暴饮暴食、玩游戏、上网、花两小时以上看电视或电影。\n\n# 感想\n\n书籍实用性不强，参照建议展开冥想确实对身心有一定帮助。\n","slug":"自控力","published":1,"updated":"2022-10-16T08:14:24.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38w6000qq8t72by07n55","content":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《自控力》 麦格尼格尔 印刷工业出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li>如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做</li>\n<li>大多数心理学家和营养学家推荐低血糖饮食，因为它能让你的血糖稳定。低血糖食品包括瘦肉蛋白、坚果和豆类、粗纤维谷类和麦片、大多数的水果和蔬菜。</li>\n<li>美国心理学家协会的调查发现，最有效的解压方法包括：锻炼、阅读、听音乐、与家人朋友相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。最没效果的缓解压力的方法则包括：赌博、购物、抽烟、喝酒、暴饮暴食、玩游戏、上网、花两小时以上看电视或电影。</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>书籍实用性不强，参照建议展开冥想确实对身心有一定帮助。</p>\n","site":{"data":{}},"wordcount":284,"excerpt":"","more":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《自控力》 麦格尼格尔 印刷工业出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li>如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做</li>\n<li>大多数心理学家和营养学家推荐低血糖饮食，因为它能让你的血糖稳定。低血糖食品包括瘦肉蛋白、坚果和豆类、粗纤维谷类和麦片、大多数的水果和蔬菜。</li>\n<li>美国心理学家协会的调查发现，最有效的解压方法包括：锻炼、阅读、听音乐、与家人朋友相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。最没效果的缓解压力的方法则包括：赌博、购物、抽烟、喝酒、暴饮暴食、玩游戏、上网、花两小时以上看电视或电影。</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>书籍实用性不强，参照建议展开冥想确实对身心有一定帮助。</p>\n"},{"title":"计算机组成原理与汇编语言程序设计","date":"2022-11-01T14:52:03.000Z","_content":"\n# 信息\n\n《计算机组成原理与汇编语言程序设计（第4版）(高等学校规划教材)》 徐洁 电子工业出版社\n\n# 摘录\n\n## 硬件组成\n\n在早期，冯·诺依曼将计算机的硬件组成分为5大部件。几十年来，计算机硬件系统已有了许多重大变化。首先，现在采用的大规模及超大规模集成电路，可将运算器和控制器集成在一块芯片上，合称为中央处理器（CPU）。它是负责执行程序，实现运算处理，控制整个系统的部件。相应地，原来的运算器现在作为CPU中的运算部件（又称为算术逻辑部件），它与控制器之间的界限已不像原来那样分明。其次，存储器分为高速缓存、主存储器、外存储器三个层次。其中高速缓存常集成在CPU内部，作为CPU的一个部分，也可以在CPU之外再设置一级高速缓存。通常将CPU与主存储器合在一起称为主机，主存储器（简称主存）就是因为位于主机之内而得名，有的书中又称它为内存储器（内存）。位于主机之外的磁盘、光盘、磁带等，则作为外存储器（外存）。还有，输入设备的任务是将外部信息输入主机，输出设备则是将主机的运算处理结果或其他信息从主机输出。但从信息传送控制的角度看，它们并无多大区别，不过是传送方向不同而已。有些设备还兼有输入与输出两种功能，所以在描述系统结构时常将它们合称为输入/输出设备，简称I/O设备。 \n\n![](./计算机组成原理与汇编语言程序设计/1.jpg)\n\n### cpu\n\nCPU（CentralProcessingUnit）即中央处理器，是硬件系统的核心部件，负责读取并执行指令，也就是执行程序。\n在CPU中有一个程序计数器PC（ProgramCounter），它存放着当前指令所在存储单元的地址。如果程序是顺序执行，在读取一个或连续几个存储单元的指令代码后，PC的内容就加1或加几，以指出下一条指令的地址；如果程序需要转移，则将转移地址送入PC。因此，PC就像一个指针，指引着程序的执行顺序。虽然指令与数据都采用二进制代码表示，在外形上没有区别，但可按照PC中的中的地址信息去读取指令，再按照指令给出的操作数地址去读取数据。\nCPU内有一个或多个算术逻辑部件ALU（ArithmeticLogicUnit）。通常按照指令的要求将有关数据送入ALU，进行指定的算术或逻辑运算，然后将运算结果送到主存单元，或暂存在CPU内的寄存器中。CPU内的主要部分是控制器（又称为控制部件），它的任务是控制整个系统的工作，决定在什么时候，根据什么，发出什么命令，做什么操作。例如它控制着从主存中读取指令，根据指令代码分时地发出一些最基本的控制信号即微命令，控制存储器的读写、ALU的运算处理、数据的输入/输出等。按照产生微命令的方式不同，控制器可分为两大类：组合逻辑控制器及微程序控制器。\n组合逻辑控制器完全靠若干组合逻辑电路（即硬件）产生微命令序列，将指令代码、状态信息、时序信号等输入到这些组合逻辑电路，电路将分时产生相应的微操作命令。这种控制器又称硬连逻辑控制器，其优点是形成微命令的速度快，常用于精简指令系统计算机（RISC）中。\n微程序控制器是将微命令序列以代码形式编制成微程序，存入一个控制存储器中；当CPU执行指令时，通过读取并执行对应的一段微程序，产生微命令序列，控制完成指定的操作。微程序控制方式比较规整，硬件代价较小，易于扩充功能，但速度较慢。\n\n### 主存储器\n\n我们总是希望计算机系统中的存储器容量大，存取速度快，但这往往是有矛盾的，所以常将存储器分为几级。其中主存储器用半导体存储器构成，工作速度较高，也有一定的存储容量。外存储器为主存提供后援，由磁盘、光盘、磁带等构成，其存储容量很大，但速度较主存储器低。高速缓冲存储器、主存储器和外存储器，组合成一个完整的多级存储系统，使得整个系统既有很大的存储容量，而CPU又可以高速地访问存储器。主存储器用来存放需要执行的程序及需要处理的数据，能由CPU直接读出或写入。\n主存储器的一项重要特性是：能按地址（单元编号）存放或读取内容，也就是允许CPU直接编址访问，通常以字节为编址单位。对主存储器来说，寻找存储单元（寻址）的依据是地址码，所存取的内容是指令或数据。\n\n### 外存储器\n\n外存储器用来存放那些需要联机存放，但暂不执行的程序和数据，当需要运行它们时再由外存调入主存。例如在光盘中存放着几个备用的软件，但当前暂时只用得着用得着其中的一个，我们先将它调入主存，其余软件仍存放在光盘上。又如一个信息管理系统所保存的数据很多，可将它们存放在磁盘之中，只将当前需要查询的部分调入主存，以后再调换。这样，主存的容量就不需要很大，可以做到速度比较快。而由磁盘、光盘等构成的外存储器容量很大，可为整个系统提供后援支持，其速度要求可以比主存低一些。\n由于外存储器不由CPU直接编址访问，也就是说不需要按字节地从外存储器读取或写入，因此外存储器中的内容一般都按文件的形式进行组织，一个文件常分解为若干数据块，可以包含许多字节的信息。用户按文件名进行调用，CPU找到该文件在外存中的存放位置，以数据块为单位进行读写。\n\n### 输入/输出设备\n\n计算机系统大多配备了键盘、鼠标、显示器、打印机等常规输入/输出设备，简称I/O设备。\n\n### 总线\n\n怎样将CPU、主存、多台I/O设备连接成整机系统呢？现在普遍采用总线结构。所谓总线是指一组能为多个部件分时共享的信息传输线。\n\n### 接口\n\n一台计算机系统需连接哪些I/O设备，这要根据该系统的应用场合而定，因此通过系统总线连接的设备，其类型与数量都应当可以扩充。某种型号的计算机系统，其系统总线往往是标准的，也就是说，有多少根地址线、数据线，有哪些控制信号线，每个信号的名称及作用等，都是规定好的。\n\n概括地说，计算机硬件系统是由三大子系统：CPU、存储系统（包括高速缓存、主存和外存）、输入/输出系统（包括输入/输出设备和接口），以及连接它们的总线构成。\n\n## 计算机软件系统\n\n### 系统软件\n\n- 操作系统\n\n- 编译程序与解释程序\n\n计算机硬件能够直接识别的是数字代码，所以让计算机硬件执行的基本命令，如传送、加、减等，必须用0、1这样的数字编码来表示。由硬件执行的程序的最终形态是由若干指令组成的序列，即指令是程序（可执行形态）的基本单位。一般地，一条指令规定了一种基本操作（如传送、加、减），并提供操作数地址或直接提供操作数，这些信息都由数字代码表示。一台计算机可以执行的各种指令的集合，称为这种计算机的指令系统。显然，不同的机型往往具有不同的指令系统，以及相应的指令格式约定，所以机器指令代码又称为机器语言，即面向特定机器结构的一种内部语言。\n如果直接用机器语言（0、1代码）编制程序，将非常不便，于是人们想到用一些约定的符号，如英文缩写的字符串，去表示操作含义、操作数、地址等，这就产生了汇编语言。汇编语言是一种用符号表示的与机器指令基本对应的程序设计语言，它专属于某种机型或某种系列机，其他计算机不能直接使用，所以是一种面向机器结构的程序设计语言，不是通用语言。\n为了便于编制程序，现在所使用的绝大多数编程语言是高级程序设计语言，这是一些面向用户，与特定机器属性相分离的语言。高级程序设计语言与机器指令之间没有直接的对应关系，所以它可以在各种机型中通用，编程者使用高级语言也不必了解具体的机器指令系统及其他硬件属性。高级程序设计语言需要遵循一定的严格语法规定与格式，才能为语言处理程序（编译、解释）所识别。\n机器语言是机器内部使用的、用数字代码表示的指令代码，面向某一特定机型，可由硬件直接识别并执行。汇编语言是一种用符号表示的，面向某一特定机型的程序设计语言，它的指令语句与机器指令一一对应。高级程序设计语言则是面向用户，与特定机器属性相分离的程序设计语言，具有通用性。\n大多数情况下，用户采用高级程序设计语言编写程序，个别情况采用汇编语言编写程序。用这些程序设计语言编写出的程序叫做源程序，它们由一些语句组成。将源程序输入计算机后，计算机先执行一种语言处理程序，将源程序转换为机器语言代码序列，即机器语言程序，然后由计算机硬件执行这些用机器语言代码表示的指令序列，从而完成用户程序的执行过程。这种语言处理程序也是一种必需的系统软件。\n语言处理方式有两种类型：解释与编译。解释方式是边解释边执行，为此需要一种针对某种程序设计语言的解释程序（又称解释器）作为系统软件的组成部分之一。将源程序输入计算机后，启动并执行相应的解释程序，它的作用是逐步分析源程序中的语句，按照源程序描述的过程，执行一个与此等价的机器语言指令序列，直到整个源程序都被扫描一遍，并被解释执行完毕为止。这有点像口译外语的情形，边说边翻译。解释方式适用于比较简单的程序设计语言，如BASIC。它的优点是支持人机对话方式的程序设计，可以边执行边修改；所需要的主存空间较小。但是这种方式的执行速度较慢，不能解释那些前后关联较多、较难理解的程序设计语言。大多数程序设计语言采用编译方式。将源程序输入计算机后，先启动并执行相应的编译程序（又称编译器），将源程序全部翻译成目标程序（目标代码）的机器语言指令序列。执行时，计算机将直接执行目标程序，不再需要源程序与翻译程序。因此，这种编译方式有点像笔译，得到完整的译文后就可以不要原文与译者了。在编译过程中，它所需的主存空间比解释方式多些，既要容纳源程序又要容纳一个比较大的编译程序；需花费的时间也要长些。但运行用户程序时，所需的主存空间比较小，执行速度也较快。\n将汇编语言源程序转换为机器代码的目标程序的过程也是一种编译，人们将它专门称为“汇编”，相应的翻译程序称为汇编程序（又称汇编器）。它的逆过程叫做“反汇编”，即将用机器代码表示的目标程序（指令序列）反汇编成用汇编语言描述的程序。为利于二次开发，在剖析一些已有的重要软件时，常常需要进行反汇编。\n\n- 各种软件平台\n\n### 应用软件\n\n应用软件不胜枚举，它一般包括：①科学计算类；②数据处理类；③自动控制类；④计算机辅助设计类；⑤人工智能类；等等。\n\n## 计算机系统层次\n\n### 从计算机系统组成角度划分层次结构\n\n![](./计算机组成原理与汇编语言程序设计/2.jpg)\n\n1. 微体系结构层\n   微体系结构层是具体存在的硬件层次，在这一层我们看到的不是由大部件（即CPU、存储系统、输入/输出系统及互连机构）构成的计算机，而是更细微的机器结构。微体系结构层执行机器指令，它可看作是指令系统层指令的解释器。在由微程序控制数据通路的计算机上，微程序就是上一层指令的解释器。它通过数据通路逐条对指令进行取指、译码和执行。例如，对加法ADD指令，将首先取出指令进行译码分析，然后找到操作数送入寄存器，由ALU求和，最后存结果。结果到指定地方，如某个存储器单元。而在硬件直接控制数据通路的计算机上，执行的步骤与此类似，但是由硬件直接解释执行指令，并不存在一个真正的程序来解释上一层的指令。\n\n2. 指令系统层\n   原则上，指令系统层是机器语言程序员眼中所看到的计算机，当然现在人们并不使用机器语言编程。指令系统层位于微体系结构层之上，是一个抽象的层次，其主要特征就是指令系统。指令系统（又称指令集）是指一台计算机所能执行的全部指令的集合。其指令是由微体系结构层的微程序解释执行或硬件电路直接执行的。\n   指令系统是计算机软件与硬件之间的一种接口。硬件系统的基本任务是实现指令系统所规定的各种指令功能，而各种程序只有最终转化为用机器语言（即代码表示的指令序列）才能被硬件执行。尽管现在已广泛应用各种高级语言编程，但需通过编译器或解释器将高级语言程序转换为硬件可以识别与执行的机器指令序列。\n   指令系统层定义了硬件和编译器之间的接口，它是一种硬件和编译器都能理解的语言。一方面，指令系统表明了一台计算机具有哪些硬件功能，是硬件逻辑设计的基础。因此，在指令系统层，应该定义一套在当前和将来的技术条件下能够高效率实现的指令集，从而使高效率的设计可用于今后的若干代计算机中。另一方面，指令系统层应该为编译器提供明确的编译目标，使编译结果具有规律性和完整性。\n\n3. 操作系统层\n   从程序员的观点来看，操作系统是一个在指令系统层提供的指令和特性之上又增加了新指令和特性的程序。这一层有新的指令集，有不同的存储器结构，有同时运行两个或多个程序的能力，以及其他一些特性。\n   尽管操作系统层和指令系统层都是抽象层次，但它们之间具有重要的区别。操作系统层指令集是系统程序员完全可用的指令集。它包括几乎所有的指令系统层的指令和操作系统层增加的新指令。这些新指令称为系统调用（SystemCall），如DOS操作系统的系统功能调用“INT21H”用于设备、文件和目录等管理，Linux操作系统的系统调用“fork()”用来创建一个进程。一个系统调用使用一条新指令调用一个预先定义好的操作系统服务，这样效率很高。一个典型的系统调用是从一个文件中读取数据。这一层增加的系统调用是由运行在指令系统层上的操作系统解释执行的。当一个用户程序执行一个系统调用时，比如从一个文件中读取数据，操作系统将一步步地执行这个调用。但是，那些和第2层指令相同的本层指令将直接交给微体系结构层执行，而不是由操作系统执行。换句话说，本层的新增指令由操作系统解释，而其他指令由微体系结构层直接执行，因此又将本层称为“混合层”。\n   这一层并不是为普通程序员的使用而设计的，主要是为支持高层所需的解释器或翻译器运行而设计的。\n\n4. 汇编语言层\n   微体系结构层可看作指令系统层指令的解释器，使指令系统的功能得以实现。但是，直接用机器指令代码编程是非常困难的，而让微体系结构层直接执行高级语言也不是好办法。因此，人们为所有的计算机都设计了一个汇编语言层，它位于指令系统层、操作系统层与面向问题语言层之间。从这一层看去，每一种计算机都有一套自己的汇编语言、解释它的汇编器，以及相应的程序设计与开发方法。汇编语言层以及上层是提供给解决应用问题的应用程序员使用的。第1、2、3层提供的机器语言都是二进制代码，适合机器执行，但不容易被人理解。从第4层开始，其提供的语言是人们能理解的单词和缩略语。汇编语言实际就是“符号化”的机器语言，每一条汇编指令语句都对应一条机器语言指令，它是它是面向机器结构的语言。用汇编语言编写的程序先由汇编器翻译成机器语言程序，然后由微体系结构层解释执行。这一层支持上层的方法与低层不同。第2层和第3层主要用的是解释；而第4层和第5层通常用的是编译。\n\n5. 面向问题语言层\n   BASIC、C、C++、Java、LISP等\n\n### 从语言功能角度划分层次结构\n\n![](./计算机组成原理与汇编语言程序设计/3.jpg)\n\n如果将计算机功能描述为“能执行用某些程序设计语言编写的程序”，那么用户看到的就是上图的语言功能层次模型。计算机硬件的物理功能是执行机器语言，称为机器语言物理机，从这一级看到的是一台实际的机器。而用户看到的是能执行某种语言程序的虚拟机，即通过配置某种语言处理程序后所形成的一台计算机。\n与机器语言最接近的是汇编语言，它的基本成分是与指令系统一一对应的用助记符描述的汇编语句。与算法、数学模型甚至自然语言接近的，称为高级语言，它具有较强的通用性，在这一范畴内已推出了多种通用的高级程序设计语言。针对某些特定应用领域与用户，也可使用某种专用语言，它们一般面向应用，如所要求解的问题。\n大多数计算机都是先将用程序设计语言编写的程序翻译为机器语言，然后才能执行。一般是直接翻译为机器语言。但当高级语言较复杂时，也可能分级编译，即先翻译为层次低些的某种中间语言，再将中间语言进一步翻译为机器语言，如上图虚线所示。\n所谓虚拟机，通常是指通过配置软件（如某种语言的编译器或解释器）扩充机器功能后所形成的一台计算机。实际硬件在物理功能级上并不具备这种机器功能，因而称为虚拟机。采用虚拟机概念是计算机设计中的又一重要策略，它将提供给用户的功能抽象出来，使其脱离具体的物理机器，这有利于让用户摆脱真实物理机细节的束缚，获得超越物理机的功能。\n广泛使用的Java虚拟机（JavaVirtualMachine，JVM）的概念。为了使Java程序能在不同的计算机上运行，Sun公司定义了一种称为Java虚拟机的虚拟体系结构。它有32位字组成的内存，能执行226条指令。大多数指令都很简单，只有一些比较复杂，需要多次内存循环。\n\n### 软硬件逻辑上等价\n\n如果说系统设计者必须关心软、硬件之间的界面，即哪些功能由硬件实现，哪些由软件实现；用户则更关心系统究竟能提供哪些功能。至于这些功能是由硬件还是软件实现，在逻辑功能上则是等价的，只是执行速度有差别而已。\n\n### 计算机的性能指标\n\n- 基本字长\n\n- 数据通路宽度\n\n- 运算速度\n\n- 主存储器容量\n\n- 外存容量\n\n- 配置的外围设备及其性能\n\n- 系统软件配置\n\n### 提高计算机性能的若干技术\n\n- 提高单CPU性能的若干技术\n  （1）流水线处理技术\n  （2）RISC（精简指令系统计算机）技术\n  （3）超标量技术\n  （4）平衡不同子系统的数据吞吐率\n\n- 并行计算机\n\n### 精简指令集计算机（RISC）\n\n- 概念\n\n随着超大规模集成电路VLSI技术的迅速发展，计算机系统的硬件成本不断下降，而软件成本却在不断上升。因此，人们热衷于在指令系统中增加更多的指令和更复杂的指令，以适应不同应用领域的需要，并考虑尽量缩短指令系统与高级语言之间的语义差异，以便于实现高级语言的编译和降低软件成本。另外，为了维护系列机的软件兼容性，也使指令系统变得越来越庞大。在系列机中，为了使老用户在软件上的投资不受损失，新机型必须继承老机器指令系统中的全部指令，这种情况使同一系列计算机的指令系统越来越复杂。一般来说，人们在计算机设计方面的传统想法和做法是：字长愈长、性能愈高的计算机，其指令系统就应该愈复杂，按这种传统方法设计的计算机系统称为复杂指令系统计算机，简称CISC。指令系统很复杂、功能很强并不一定能提高机器的速度，CISC中采用很多复杂的寻址方式，为了计算有效地址需花费一定的时间；有的指令需要多次访问主存储器，所以执行速度会降低。\n\n复杂指令系统的实现需要复杂的控制器来支持，并且系列机为实现兼容，其控制部件多用微程序控制方式来实现，以便于指令系统的扩展。但微程序控制部件执行一条机器指令通常需要几个微周期，因此严重降低了指令的执行速度。为了提高指令的执行速度，CISC中常采用流水线技术。但由于存在很多问题，例如指令系统采用变字长指令、不同指令争用共同资源以及转移指令等，使流水线的效率不高。以上情况表明，传统的CISC设计思想并不利于提高计算机的速度。而且复杂的指令系统必然增加硬件实现的复杂性，从而使计算机的研制周期长、投资大。因此人们开始研究指令系统的合理性问题。对CISC指令系统运行的统计分析表明，各种指令的使用频率相差悬殊，最常用的是一些比较简单的指令，仅占指令总数的20%，但在程序中出现的频率却占80%。1975年，IBM公司提出了精简指令系统的想法。后来美国加利福尼亚大学伯克利分校的RISCI和RISCII、斯坦福大学的MIPS机的研制成功，为精简指令系统计算机（简称RISC）的诞生与发展起了很大作用。\n\n- RISC的特点\n\n精简指令系统计算机的着眼点不是简单地放在简化指令系统上，而是通过简化指令使计算机的结构更加简单合理，更易于流水线的实现，从而提高处理速度。\n  （1）面向寄存器的结构所有运算使用的数据都来自寄存器，运算结果也都写入寄存器。寄存器的典型长度是32位或64位。通常CPU内应设置大量的通用寄存器，以减少访问主存储器。\n  （2）采用LOAD/STORE结构\n  （3）较少的指令数和寻址方式\n  选取使用频率最高的一些简单指令，以及很有用但不复杂的指令，可简化控制部件。选用简单的寻址方式，有利于减少指令的执行周期数。\n  （4）所有指令长度相同\n  （5）硬布线控制逻辑\n  （6）注重编译的优化\n  RISC指令系统的简化，必然使编译生成的代码长度增长。但通过编译优化技术，将编译初步生成的代码重新组织，调度指令的执行次序，以充分发挥内部操作的并行性，从而进一步提高流水线的执行效率。虽然编译优化技术使编译时间拉长，但这种代价的结果是使程序的执行时间缩短。而且程序的编译工作只需一次，编译后生成的优化执行代码却可以高效率地执行多次。因此这个代价是值得的。\n\n### 存储系统\n\n在物理构成上，存储系统通常分为3层：高速缓冲存储器Cache、主存和外存。Cache与主存常由半导体存储器构成；外存常由磁盘及光盘构成，也可以看作是I/O设备。一个高性能的计算机系统要求存储器的存储容量大，存取速度快，成本低廉，能支持复杂系统结构。这些要求往往相互矛盾，彼此形成制约。因此在一个计算机系统中，常采用几种不同的存储器，构成多级存储体系，以适应不同层次的需要。通常，对CPU直接访问的一级，其速度尽可能快些，而容量相对有限；作为后援的一级其容量尽可能大些，而速度可以相对慢些。经过合理的搭配和组织，对用户来说，整个存储系统能够提供足够大的存储容量和较快的存取速度。\n从用户的角度看，存储器还可以形成另一种层次结构，即物理存储器与虚拟存储器。物理存储器是指系统的物理组成中实际存在的主存，主存容量决定了实存空间的大小。在高档计算机中，依靠操作系统的软件支持及部分硬件的支持，可以使用户访问的编程空间远比实际主存空间大，用户感觉自己可编程访问一个很大的存储器，这个存储器称为虚拟存储器。\n\n#### 存储器的分类\n\n- 按存储器在计算机系统中的作用分类\n  （1）内部存储器内部存储器（简称内存或主存）是计算机主机的组成部分，用来存储当前运行所需要的程序和数据，CPU可以直接访问内存并与其交换信息。相对外部存储器而言，内存的容量小、存取速度快。由于CPU要频繁地访问内存，所以内存的性能在很大程度上影响了整个计算机系统的性能。\n  （2）外部存储器外部存储器也称辅助存储器或后援存储器，简称外存或辅存。外存用于存放当前不参加运行的程序和数据，以及一些需要永久保存的信息。外存设在设在主机外部，其容量大，但存取速度相对较慢，CPU不能直接访问它，而必须通过专门的设备才能对它进行读写（如磁盘驱动器等），这是它与内存之间的一个本质区别。\n  （3）高速缓冲存储器高速缓冲存储器（Cache）位于主存和CPU之间，用来存放正在执行的程序和数据，以便CPU能高速地访问它们。Cache的存取速度可以与CPU的速度相匹配，但其价格昂贵，存储容量较小。目前的微处理器通常将Cache或Cache的一部分制作在CPU芯片中。\n\n- 按存取方式分类\n  （1）随机存取存储器RAM（RandomAccessMemory）随机存取存储器是可读可写的存储器，CPU可以对RAM单元的内容随机地读/写访问，对任一单元的读出和写入的时间是一样的，即存取时间相同，并且与存储单元在存储器中所处的位置无关。RAM读/写方便，使用灵活，但断电后信息会丢失。RAM主要用作主存，也可用作高速缓存。\n  （2）只读存储器ROM（ReadOnlyMemory）只读存储器可以看作RAM的一种特殊形式，其特点是：存储器的内容只能随机读出而不能写入。这类存储器用来存放那些不需要改变的信息。由于信息一旦写入存储器就固定不变了，即使断电信息也不会丢失，所以又称它为固定存储器。ROM除了存放某些系统程序外，还用来存放专门的子程序，或用作函数发生器、字符发生器及微程序控制器中的控制存储器。有些ROM在特定条件下用特殊的装置或程序可以重新写入。\n  （3）顺序存取存储器SAM（SequentialAccessMemory）顺序存取存储器的存取方式与前两种完全不同，它的内容只能按某种顺序存取，存取时间的长短与信息在存储器上的物理位置有关，所以SAM只能用平均存取时间作为衡量存取速度的指标。磁带机就是典型的顺序存取存储器。\n  （4）直接存取存储器DAM（DirectAccessMemory）直接存取存储器既不像RAM那样能随机地访问存储器\n  存储器的任何一个存储单元，也不像SAM那样完全按顺序存取，而是介于两者之间。存取信息时，第1步直接指向存储器的某个小区域（如磁盘上的磁道）；第2步在小区域内顺序检索或等待，直到找到目的地后再进行读/写操作。这种存储器的存取时间也与信息所在的物理位置有关，但比SAM的存取时间要短。磁盘是最常见的直接存取存储器。\n\n- 按存储介质分类\n  （1）磁芯存储器\n  （2）半导体存储器\n  （3）磁表面存储器\n  （4）光盘存储器\n\n- 按信息的可保存性分类\n  断电后存储信息即消失的存储器，称为易失性存储器或挥发性存储器，RAM是易失性存储器。断电后信息仍然保存的存储器，称为非易失性存储器，也称为非挥发性存储器或永久性存储器，ROM、磁芯存储器、磁表面存储器和光盘存储器都是非易失性存储器。\n\n#### 主存的主要技术指标\n\n- 存储容量\n- 存取速度\n- 可靠性\n- 存取宽度\n\n#### 高速缓冲存储器Cache\n\n计算机系统整体性能的高低与许多因素有关，如CPU的主频、存储器的存取速度、系统架构、指令结构、信息在各部件之间的传送速度等。而CPU与主存之间的存取速度是一个很重要的因素。如果只是CPU工作速度很高，而主存的存取速度较低，就会造成CPU经常处于等待状态，既降低了处理速度，又浪费了CPU能力。为了减小CPU与主存之间的速度差异，现代微机中通常在慢速的DRAM和快速的CPU之间插入一个速度较快、容量较小的SRAM，起到缓冲作用，使CPU既能以较快速度存取SRAM中的数据，又不使系统成本上升过高，这就是Cache技术。\n\n![](./计算机组成原理与汇编语言程序设计/4.jpg)\n\n由此可以想到，如果把一段时间内在一定地址范围中被频繁访问的信息集合成批地从主存读到一个能高速存取的小容量存储器中存放起来，供程序在这段时间内随时使用，从而尽量减少访问速度较慢的主存的次数，可以加快程序的运行速度，这就是Cache的设计思想，即在CPU和主存之间设置一个小容量的高速缓冲存储器（Cache）。  Cache中存放着最近要使用的程序与数据，作为主存中当前最急需执行信息的副本。其容量约为数KB到数百KB，由于容量较小，可以选用高速半导体存储器，使CPU访存速度得到提高。在高档微处理器中，在CPU芯片内集成了1～2个高速缓存，称为片内Cache，还允许在CPU芯片外扩充Cache。\n有了Cache，系统在工作时总是不断地将与当前指令集相关联的一个不太大的后继指令集从主存读到Cache，然后再向CPU高速传送，从而达到速度匹配。当CPU需要访存时，同时将地址送往主存与Cache。若所需访问的内容已经在Cache中，则可直接从Cache中快速读取信息，这称为访问Cache命中；若访问的内容不在Cache中，即未命中，则从主存中读取信息，并考虑更新Cache，使其成为当前最急需部分。为此需要实现访存地址与Cache物理地址间的映像变换。\n由于局部性原理不能保证所请求的数据百分之百地在Cache中，这里便存在一个命中率问题。所谓命中率，就是在CPU访问Cache时，所需信息恰好在Cache中的概率。命中率越高，正确获取数据的可能性就越大，目前Cache的访问命中率可达到90%以上。因此只要合理组织三级存储体系，从整体上讲，CPU就能以接近Cache的速度访问存储器，而总存储容量相当于联机外存的总容量。\n一般来说，Cache的存储容量比主存的容量小得多，但不能太小，太小会使命中率太低。但也没有必要过大，过大不仅会增加成本，而且当Cache容量超过一定值后，命中率随容量的增加将不会有明显增长。所以Cache的空间与主存空间在一定范围内应保持适当比例的映射关系，以保证Cache有较高的命中率，且系统成本不会过多地增加。Cache的命中率与Cache的映像方式、替换算法、程序特性等因素有关。\n\n#### 存储系统的层次结构\n\n![](./计算机组成原理与汇编语言程序设计/5.jpg)\n\n 要真正解决存储器的容量、速度、价格之间的矛盾，不能只是将上面的各个层次的存储器进行简单组合，必须在系统结构上采取措施，采用不同速度、不同容量和不同价格的多种存储器件，按层次组成存储系统。各个层次的存储器之间通过硬件和软件有机地结合成一个统一的整体，无需程序员的干预而由计算机自动地实现调度，向程序员提供足够大的存储空间，同时最大限度地与CPU速度相匹配。按这样的思想组成的存储层次结构，称为存储体系结构。\n典型的三级存储体系结构，分为“高速缓存—主存—辅存”三个层次。现在的计算机系统大多具备这三级存储结构。三级存储体系又分为两个层次，高速缓存和主存之间形成Cache-主存层次，主存和辅存之间形成主存-辅存层次。 \n\n![](./计算机组成原理与汇编语言程序设计/6.jpg)\n\n- Cache-主存层次　\n  通过辅助硬件将Cache和主存构成一个整体，如上图所示。从整体上看，该层次具有接近于Cache的存取速度、主存容量和平均位价格，解决了存储器高速与低成本之间的矛盾。这个层次完全由硬件实现，不受软件的干预，因此对所有程序员都是透明的。\n- 主存-辅存层次　\n  随着操作系统和硬件技术的发展，利用附加硬件及存储管理软件，使主存和辅存构成一个整体，形成主存-辅存层次，如图上图所示。辅存只与主存交换信息，不能直接由CPU访问。从整体上看，该层次的存取速度接近于主存的存取速度，容量则接近于辅存的容量，而位价格也接近于廉价的辅存平均价格，从而解决了大容量和低成本之间的矛盾。三级存储体系结构的总的效果是：存取速度接近于Cache，存储容量接近于辅存容量，整体价格也比较合理。\n\n#### 磁盘冗余阵列\n\n廉价冗余磁盘阵列（RedundantArraysofInexpensiveDisk，RAID）是用多台磁盘存储器组成的大容量外存子系统，它是由多台磁盘机按一定规则（如分条、分块、交叉存取等）组合在一起构成的。通过阵列控制器的控制和管理，磁盘阵列系统能够将几个、几十个甚至几百个硬盘组合起来，使其容量高达几百GB甚至上千GB。其基础是数据分块技术，即在多个磁盘上交错存放数据，通过阵列控制器实现数据的并行、交叉存储或单独存储操作。由于阵列中的一部分磁盘存有冗余信息，一旦系统中某一磁盘失效，可以利用冗余信息重建用户数据。\n\n- RAID0级（无冗余和无校验的数据分块）\n  数据分布在阵列中的所有磁盘上，与单个大容量磁盘相比，它的显著优点是：如果两个I/O请求正在等待不同的数据块，则被请求的块有可能在不同的盘上。因此，两个请求能够并行发出，减少了I/O的排队时间。RAID0级具有最高的I/O性能和磁盘空间利用率，但无容错能力，增加了系统出故障的几率。若阵列中有一块磁盘损坏，将造成不可弥补的损失。其安全性甚至低于常规的硬盘系统，所以不适于对数据稳定性要求高的应用。\n- RAID1级（镜像磁盘阵列）\n  由磁盘对组成，每个工作盘都有对应的镜像盘，上面保存着与工作盘完全相同的数据。如果镜像盘组中一个物理磁盘出现故障，系统可以使用未受影响的另一个磁盘继续操作，数据不会丢失，但磁盘空间的利用率只有50%。RAID1级的安全性高，而主要缺点是价格昂贵，它需要支持2倍于逻辑磁盘的磁盘空间。因此，RAID1级的配置只限于存储系统软件、数据和其他关键文件的驱动器中。在这种情况下，RAID1级对所有的数据提供实时备份，在磁盘损坏时，所有的关键数据仍立即可用。\n- RAID2级（具有纠错海明码的磁盘阵列）\n- RAID3、4、5、6、7级\n- RAID10级（RAID0级+RAID1级）\n  这是一种复合的RAID模式，将RAID0的速度与RAID1的冗余特性相结合，既可提供数据分块，又能提供镜像功能，是所有RAID中性能最好的磁盘阵列，但每次写入时要写两个互为镜像的盘，价格高。这种结构特别适用于既有大量数据需要存取，同时又对数据安全性要求严格的领域，如银行、金融、商业超市、仓储库房、各种档案管理等。\n\n#### 虚拟存储系统的组织\n\n虚拟存储系统建立在主存-辅存层次上，是由附加硬件装置及存储管理软件组成的存储体系，它使计算机具有接近主存的存取速度，并具有辅存的容量和位成本。\n在采用磁盘作为后援存储器后，可以在存储管理部件和操作系统存储管理软件的支持下，将主存和辅存的地址空间统一编址，使用户获得一个很大的编程空间，其容量大大超过实际的主存储器。这个在用户界面上看到的存储器，被称为虚拟存储器（VirtualMemory，VM），这样的虚拟存储技术对用户来说，自然是极有价值的，因而已在计算机系统中广泛使用，高档微处理器芯片也为此提供了有关硬件支撑。从用户界面看，用户可使用位数较长的编程地址进行编程，这种地址面向程序的需要，不必考虑程序将来在主存储器中的实际位置，因而称为逻辑地址。它是面向虚拟存储器的，所以又称为虚地址。在用户看来，CPU可按虚地址访问一个很大的存储器，其容量甚至可达整个辅存容量，显然这是一种虚拟层次。\n在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前急需运行的部分调入主存，供CPU操作，其余暂不运行部分留在磁盘中，随程序执行的需要，操作系统自动地按一定替换算法进行调度，将当前暂不运行部分调回磁盘，将新的模块由磁盘调入主存。这一层次上的工作，对用户是透明的。CPU执行程序时，需将程序提供的虚地址变换为主存的实际地址（实地址、物理地址）。一般是先由存储管理部件判断该地址的内容是否在主存中，若已调入主存，则通过地址变换机制将虚地址转换为实地址，然后访问主存单元；若尚未调入主存，则通过缺页中断程序，以页为单位调入或实现主存内容调换。从原理上看，虚拟存储器与Cache-主存层次有很多相似之处，如地址映像方式和替换策略。但是，Cache-主存层次的控制完全由硬件实现，它对各类程序员都是透明的；而虚拟存储器的控制是由硬件与软件结合实现，对应用程序员来说是透明的，但对于设计存储器管理软件的系统程序员来说是不透明的。\n\n# 感想\n\n无\n","source":"_posts/计算机组成原理与汇编语言程序设计.md","raw":"---\ntitle: 计算机组成原理与汇编语言程序设计\ndate: 2022-11-01 22:52:03\ncategories: \n- 读书\ntags: \n- 计算机结构\n---\n\n# 信息\n\n《计算机组成原理与汇编语言程序设计（第4版）(高等学校规划教材)》 徐洁 电子工业出版社\n\n# 摘录\n\n## 硬件组成\n\n在早期，冯·诺依曼将计算机的硬件组成分为5大部件。几十年来，计算机硬件系统已有了许多重大变化。首先，现在采用的大规模及超大规模集成电路，可将运算器和控制器集成在一块芯片上，合称为中央处理器（CPU）。它是负责执行程序，实现运算处理，控制整个系统的部件。相应地，原来的运算器现在作为CPU中的运算部件（又称为算术逻辑部件），它与控制器之间的界限已不像原来那样分明。其次，存储器分为高速缓存、主存储器、外存储器三个层次。其中高速缓存常集成在CPU内部，作为CPU的一个部分，也可以在CPU之外再设置一级高速缓存。通常将CPU与主存储器合在一起称为主机，主存储器（简称主存）就是因为位于主机之内而得名，有的书中又称它为内存储器（内存）。位于主机之外的磁盘、光盘、磁带等，则作为外存储器（外存）。还有，输入设备的任务是将外部信息输入主机，输出设备则是将主机的运算处理结果或其他信息从主机输出。但从信息传送控制的角度看，它们并无多大区别，不过是传送方向不同而已。有些设备还兼有输入与输出两种功能，所以在描述系统结构时常将它们合称为输入/输出设备，简称I/O设备。 \n\n![](./计算机组成原理与汇编语言程序设计/1.jpg)\n\n### cpu\n\nCPU（CentralProcessingUnit）即中央处理器，是硬件系统的核心部件，负责读取并执行指令，也就是执行程序。\n在CPU中有一个程序计数器PC（ProgramCounter），它存放着当前指令所在存储单元的地址。如果程序是顺序执行，在读取一个或连续几个存储单元的指令代码后，PC的内容就加1或加几，以指出下一条指令的地址；如果程序需要转移，则将转移地址送入PC。因此，PC就像一个指针，指引着程序的执行顺序。虽然指令与数据都采用二进制代码表示，在外形上没有区别，但可按照PC中的中的地址信息去读取指令，再按照指令给出的操作数地址去读取数据。\nCPU内有一个或多个算术逻辑部件ALU（ArithmeticLogicUnit）。通常按照指令的要求将有关数据送入ALU，进行指定的算术或逻辑运算，然后将运算结果送到主存单元，或暂存在CPU内的寄存器中。CPU内的主要部分是控制器（又称为控制部件），它的任务是控制整个系统的工作，决定在什么时候，根据什么，发出什么命令，做什么操作。例如它控制着从主存中读取指令，根据指令代码分时地发出一些最基本的控制信号即微命令，控制存储器的读写、ALU的运算处理、数据的输入/输出等。按照产生微命令的方式不同，控制器可分为两大类：组合逻辑控制器及微程序控制器。\n组合逻辑控制器完全靠若干组合逻辑电路（即硬件）产生微命令序列，将指令代码、状态信息、时序信号等输入到这些组合逻辑电路，电路将分时产生相应的微操作命令。这种控制器又称硬连逻辑控制器，其优点是形成微命令的速度快，常用于精简指令系统计算机（RISC）中。\n微程序控制器是将微命令序列以代码形式编制成微程序，存入一个控制存储器中；当CPU执行指令时，通过读取并执行对应的一段微程序，产生微命令序列，控制完成指定的操作。微程序控制方式比较规整，硬件代价较小，易于扩充功能，但速度较慢。\n\n### 主存储器\n\n我们总是希望计算机系统中的存储器容量大，存取速度快，但这往往是有矛盾的，所以常将存储器分为几级。其中主存储器用半导体存储器构成，工作速度较高，也有一定的存储容量。外存储器为主存提供后援，由磁盘、光盘、磁带等构成，其存储容量很大，但速度较主存储器低。高速缓冲存储器、主存储器和外存储器，组合成一个完整的多级存储系统，使得整个系统既有很大的存储容量，而CPU又可以高速地访问存储器。主存储器用来存放需要执行的程序及需要处理的数据，能由CPU直接读出或写入。\n主存储器的一项重要特性是：能按地址（单元编号）存放或读取内容，也就是允许CPU直接编址访问，通常以字节为编址单位。对主存储器来说，寻找存储单元（寻址）的依据是地址码，所存取的内容是指令或数据。\n\n### 外存储器\n\n外存储器用来存放那些需要联机存放，但暂不执行的程序和数据，当需要运行它们时再由外存调入主存。例如在光盘中存放着几个备用的软件，但当前暂时只用得着用得着其中的一个，我们先将它调入主存，其余软件仍存放在光盘上。又如一个信息管理系统所保存的数据很多，可将它们存放在磁盘之中，只将当前需要查询的部分调入主存，以后再调换。这样，主存的容量就不需要很大，可以做到速度比较快。而由磁盘、光盘等构成的外存储器容量很大，可为整个系统提供后援支持，其速度要求可以比主存低一些。\n由于外存储器不由CPU直接编址访问，也就是说不需要按字节地从外存储器读取或写入，因此外存储器中的内容一般都按文件的形式进行组织，一个文件常分解为若干数据块，可以包含许多字节的信息。用户按文件名进行调用，CPU找到该文件在外存中的存放位置，以数据块为单位进行读写。\n\n### 输入/输出设备\n\n计算机系统大多配备了键盘、鼠标、显示器、打印机等常规输入/输出设备，简称I/O设备。\n\n### 总线\n\n怎样将CPU、主存、多台I/O设备连接成整机系统呢？现在普遍采用总线结构。所谓总线是指一组能为多个部件分时共享的信息传输线。\n\n### 接口\n\n一台计算机系统需连接哪些I/O设备，这要根据该系统的应用场合而定，因此通过系统总线连接的设备，其类型与数量都应当可以扩充。某种型号的计算机系统，其系统总线往往是标准的，也就是说，有多少根地址线、数据线，有哪些控制信号线，每个信号的名称及作用等，都是规定好的。\n\n概括地说，计算机硬件系统是由三大子系统：CPU、存储系统（包括高速缓存、主存和外存）、输入/输出系统（包括输入/输出设备和接口），以及连接它们的总线构成。\n\n## 计算机软件系统\n\n### 系统软件\n\n- 操作系统\n\n- 编译程序与解释程序\n\n计算机硬件能够直接识别的是数字代码，所以让计算机硬件执行的基本命令，如传送、加、减等，必须用0、1这样的数字编码来表示。由硬件执行的程序的最终形态是由若干指令组成的序列，即指令是程序（可执行形态）的基本单位。一般地，一条指令规定了一种基本操作（如传送、加、减），并提供操作数地址或直接提供操作数，这些信息都由数字代码表示。一台计算机可以执行的各种指令的集合，称为这种计算机的指令系统。显然，不同的机型往往具有不同的指令系统，以及相应的指令格式约定，所以机器指令代码又称为机器语言，即面向特定机器结构的一种内部语言。\n如果直接用机器语言（0、1代码）编制程序，将非常不便，于是人们想到用一些约定的符号，如英文缩写的字符串，去表示操作含义、操作数、地址等，这就产生了汇编语言。汇编语言是一种用符号表示的与机器指令基本对应的程序设计语言，它专属于某种机型或某种系列机，其他计算机不能直接使用，所以是一种面向机器结构的程序设计语言，不是通用语言。\n为了便于编制程序，现在所使用的绝大多数编程语言是高级程序设计语言，这是一些面向用户，与特定机器属性相分离的语言。高级程序设计语言与机器指令之间没有直接的对应关系，所以它可以在各种机型中通用，编程者使用高级语言也不必了解具体的机器指令系统及其他硬件属性。高级程序设计语言需要遵循一定的严格语法规定与格式，才能为语言处理程序（编译、解释）所识别。\n机器语言是机器内部使用的、用数字代码表示的指令代码，面向某一特定机型，可由硬件直接识别并执行。汇编语言是一种用符号表示的，面向某一特定机型的程序设计语言，它的指令语句与机器指令一一对应。高级程序设计语言则是面向用户，与特定机器属性相分离的程序设计语言，具有通用性。\n大多数情况下，用户采用高级程序设计语言编写程序，个别情况采用汇编语言编写程序。用这些程序设计语言编写出的程序叫做源程序，它们由一些语句组成。将源程序输入计算机后，计算机先执行一种语言处理程序，将源程序转换为机器语言代码序列，即机器语言程序，然后由计算机硬件执行这些用机器语言代码表示的指令序列，从而完成用户程序的执行过程。这种语言处理程序也是一种必需的系统软件。\n语言处理方式有两种类型：解释与编译。解释方式是边解释边执行，为此需要一种针对某种程序设计语言的解释程序（又称解释器）作为系统软件的组成部分之一。将源程序输入计算机后，启动并执行相应的解释程序，它的作用是逐步分析源程序中的语句，按照源程序描述的过程，执行一个与此等价的机器语言指令序列，直到整个源程序都被扫描一遍，并被解释执行完毕为止。这有点像口译外语的情形，边说边翻译。解释方式适用于比较简单的程序设计语言，如BASIC。它的优点是支持人机对话方式的程序设计，可以边执行边修改；所需要的主存空间较小。但是这种方式的执行速度较慢，不能解释那些前后关联较多、较难理解的程序设计语言。大多数程序设计语言采用编译方式。将源程序输入计算机后，先启动并执行相应的编译程序（又称编译器），将源程序全部翻译成目标程序（目标代码）的机器语言指令序列。执行时，计算机将直接执行目标程序，不再需要源程序与翻译程序。因此，这种编译方式有点像笔译，得到完整的译文后就可以不要原文与译者了。在编译过程中，它所需的主存空间比解释方式多些，既要容纳源程序又要容纳一个比较大的编译程序；需花费的时间也要长些。但运行用户程序时，所需的主存空间比较小，执行速度也较快。\n将汇编语言源程序转换为机器代码的目标程序的过程也是一种编译，人们将它专门称为“汇编”，相应的翻译程序称为汇编程序（又称汇编器）。它的逆过程叫做“反汇编”，即将用机器代码表示的目标程序（指令序列）反汇编成用汇编语言描述的程序。为利于二次开发，在剖析一些已有的重要软件时，常常需要进行反汇编。\n\n- 各种软件平台\n\n### 应用软件\n\n应用软件不胜枚举，它一般包括：①科学计算类；②数据处理类；③自动控制类；④计算机辅助设计类；⑤人工智能类；等等。\n\n## 计算机系统层次\n\n### 从计算机系统组成角度划分层次结构\n\n![](./计算机组成原理与汇编语言程序设计/2.jpg)\n\n1. 微体系结构层\n   微体系结构层是具体存在的硬件层次，在这一层我们看到的不是由大部件（即CPU、存储系统、输入/输出系统及互连机构）构成的计算机，而是更细微的机器结构。微体系结构层执行机器指令，它可看作是指令系统层指令的解释器。在由微程序控制数据通路的计算机上，微程序就是上一层指令的解释器。它通过数据通路逐条对指令进行取指、译码和执行。例如，对加法ADD指令，将首先取出指令进行译码分析，然后找到操作数送入寄存器，由ALU求和，最后存结果。结果到指定地方，如某个存储器单元。而在硬件直接控制数据通路的计算机上，执行的步骤与此类似，但是由硬件直接解释执行指令，并不存在一个真正的程序来解释上一层的指令。\n\n2. 指令系统层\n   原则上，指令系统层是机器语言程序员眼中所看到的计算机，当然现在人们并不使用机器语言编程。指令系统层位于微体系结构层之上，是一个抽象的层次，其主要特征就是指令系统。指令系统（又称指令集）是指一台计算机所能执行的全部指令的集合。其指令是由微体系结构层的微程序解释执行或硬件电路直接执行的。\n   指令系统是计算机软件与硬件之间的一种接口。硬件系统的基本任务是实现指令系统所规定的各种指令功能，而各种程序只有最终转化为用机器语言（即代码表示的指令序列）才能被硬件执行。尽管现在已广泛应用各种高级语言编程，但需通过编译器或解释器将高级语言程序转换为硬件可以识别与执行的机器指令序列。\n   指令系统层定义了硬件和编译器之间的接口，它是一种硬件和编译器都能理解的语言。一方面，指令系统表明了一台计算机具有哪些硬件功能，是硬件逻辑设计的基础。因此，在指令系统层，应该定义一套在当前和将来的技术条件下能够高效率实现的指令集，从而使高效率的设计可用于今后的若干代计算机中。另一方面，指令系统层应该为编译器提供明确的编译目标，使编译结果具有规律性和完整性。\n\n3. 操作系统层\n   从程序员的观点来看，操作系统是一个在指令系统层提供的指令和特性之上又增加了新指令和特性的程序。这一层有新的指令集，有不同的存储器结构，有同时运行两个或多个程序的能力，以及其他一些特性。\n   尽管操作系统层和指令系统层都是抽象层次，但它们之间具有重要的区别。操作系统层指令集是系统程序员完全可用的指令集。它包括几乎所有的指令系统层的指令和操作系统层增加的新指令。这些新指令称为系统调用（SystemCall），如DOS操作系统的系统功能调用“INT21H”用于设备、文件和目录等管理，Linux操作系统的系统调用“fork()”用来创建一个进程。一个系统调用使用一条新指令调用一个预先定义好的操作系统服务，这样效率很高。一个典型的系统调用是从一个文件中读取数据。这一层增加的系统调用是由运行在指令系统层上的操作系统解释执行的。当一个用户程序执行一个系统调用时，比如从一个文件中读取数据，操作系统将一步步地执行这个调用。但是，那些和第2层指令相同的本层指令将直接交给微体系结构层执行，而不是由操作系统执行。换句话说，本层的新增指令由操作系统解释，而其他指令由微体系结构层直接执行，因此又将本层称为“混合层”。\n   这一层并不是为普通程序员的使用而设计的，主要是为支持高层所需的解释器或翻译器运行而设计的。\n\n4. 汇编语言层\n   微体系结构层可看作指令系统层指令的解释器，使指令系统的功能得以实现。但是，直接用机器指令代码编程是非常困难的，而让微体系结构层直接执行高级语言也不是好办法。因此，人们为所有的计算机都设计了一个汇编语言层，它位于指令系统层、操作系统层与面向问题语言层之间。从这一层看去，每一种计算机都有一套自己的汇编语言、解释它的汇编器，以及相应的程序设计与开发方法。汇编语言层以及上层是提供给解决应用问题的应用程序员使用的。第1、2、3层提供的机器语言都是二进制代码，适合机器执行，但不容易被人理解。从第4层开始，其提供的语言是人们能理解的单词和缩略语。汇编语言实际就是“符号化”的机器语言，每一条汇编指令语句都对应一条机器语言指令，它是它是面向机器结构的语言。用汇编语言编写的程序先由汇编器翻译成机器语言程序，然后由微体系结构层解释执行。这一层支持上层的方法与低层不同。第2层和第3层主要用的是解释；而第4层和第5层通常用的是编译。\n\n5. 面向问题语言层\n   BASIC、C、C++、Java、LISP等\n\n### 从语言功能角度划分层次结构\n\n![](./计算机组成原理与汇编语言程序设计/3.jpg)\n\n如果将计算机功能描述为“能执行用某些程序设计语言编写的程序”，那么用户看到的就是上图的语言功能层次模型。计算机硬件的物理功能是执行机器语言，称为机器语言物理机，从这一级看到的是一台实际的机器。而用户看到的是能执行某种语言程序的虚拟机，即通过配置某种语言处理程序后所形成的一台计算机。\n与机器语言最接近的是汇编语言，它的基本成分是与指令系统一一对应的用助记符描述的汇编语句。与算法、数学模型甚至自然语言接近的，称为高级语言，它具有较强的通用性，在这一范畴内已推出了多种通用的高级程序设计语言。针对某些特定应用领域与用户，也可使用某种专用语言，它们一般面向应用，如所要求解的问题。\n大多数计算机都是先将用程序设计语言编写的程序翻译为机器语言，然后才能执行。一般是直接翻译为机器语言。但当高级语言较复杂时，也可能分级编译，即先翻译为层次低些的某种中间语言，再将中间语言进一步翻译为机器语言，如上图虚线所示。\n所谓虚拟机，通常是指通过配置软件（如某种语言的编译器或解释器）扩充机器功能后所形成的一台计算机。实际硬件在物理功能级上并不具备这种机器功能，因而称为虚拟机。采用虚拟机概念是计算机设计中的又一重要策略，它将提供给用户的功能抽象出来，使其脱离具体的物理机器，这有利于让用户摆脱真实物理机细节的束缚，获得超越物理机的功能。\n广泛使用的Java虚拟机（JavaVirtualMachine，JVM）的概念。为了使Java程序能在不同的计算机上运行，Sun公司定义了一种称为Java虚拟机的虚拟体系结构。它有32位字组成的内存，能执行226条指令。大多数指令都很简单，只有一些比较复杂，需要多次内存循环。\n\n### 软硬件逻辑上等价\n\n如果说系统设计者必须关心软、硬件之间的界面，即哪些功能由硬件实现，哪些由软件实现；用户则更关心系统究竟能提供哪些功能。至于这些功能是由硬件还是软件实现，在逻辑功能上则是等价的，只是执行速度有差别而已。\n\n### 计算机的性能指标\n\n- 基本字长\n\n- 数据通路宽度\n\n- 运算速度\n\n- 主存储器容量\n\n- 外存容量\n\n- 配置的外围设备及其性能\n\n- 系统软件配置\n\n### 提高计算机性能的若干技术\n\n- 提高单CPU性能的若干技术\n  （1）流水线处理技术\n  （2）RISC（精简指令系统计算机）技术\n  （3）超标量技术\n  （4）平衡不同子系统的数据吞吐率\n\n- 并行计算机\n\n### 精简指令集计算机（RISC）\n\n- 概念\n\n随着超大规模集成电路VLSI技术的迅速发展，计算机系统的硬件成本不断下降，而软件成本却在不断上升。因此，人们热衷于在指令系统中增加更多的指令和更复杂的指令，以适应不同应用领域的需要，并考虑尽量缩短指令系统与高级语言之间的语义差异，以便于实现高级语言的编译和降低软件成本。另外，为了维护系列机的软件兼容性，也使指令系统变得越来越庞大。在系列机中，为了使老用户在软件上的投资不受损失，新机型必须继承老机器指令系统中的全部指令，这种情况使同一系列计算机的指令系统越来越复杂。一般来说，人们在计算机设计方面的传统想法和做法是：字长愈长、性能愈高的计算机，其指令系统就应该愈复杂，按这种传统方法设计的计算机系统称为复杂指令系统计算机，简称CISC。指令系统很复杂、功能很强并不一定能提高机器的速度，CISC中采用很多复杂的寻址方式，为了计算有效地址需花费一定的时间；有的指令需要多次访问主存储器，所以执行速度会降低。\n\n复杂指令系统的实现需要复杂的控制器来支持，并且系列机为实现兼容，其控制部件多用微程序控制方式来实现，以便于指令系统的扩展。但微程序控制部件执行一条机器指令通常需要几个微周期，因此严重降低了指令的执行速度。为了提高指令的执行速度，CISC中常采用流水线技术。但由于存在很多问题，例如指令系统采用变字长指令、不同指令争用共同资源以及转移指令等，使流水线的效率不高。以上情况表明，传统的CISC设计思想并不利于提高计算机的速度。而且复杂的指令系统必然增加硬件实现的复杂性，从而使计算机的研制周期长、投资大。因此人们开始研究指令系统的合理性问题。对CISC指令系统运行的统计分析表明，各种指令的使用频率相差悬殊，最常用的是一些比较简单的指令，仅占指令总数的20%，但在程序中出现的频率却占80%。1975年，IBM公司提出了精简指令系统的想法。后来美国加利福尼亚大学伯克利分校的RISCI和RISCII、斯坦福大学的MIPS机的研制成功，为精简指令系统计算机（简称RISC）的诞生与发展起了很大作用。\n\n- RISC的特点\n\n精简指令系统计算机的着眼点不是简单地放在简化指令系统上，而是通过简化指令使计算机的结构更加简单合理，更易于流水线的实现，从而提高处理速度。\n  （1）面向寄存器的结构所有运算使用的数据都来自寄存器，运算结果也都写入寄存器。寄存器的典型长度是32位或64位。通常CPU内应设置大量的通用寄存器，以减少访问主存储器。\n  （2）采用LOAD/STORE结构\n  （3）较少的指令数和寻址方式\n  选取使用频率最高的一些简单指令，以及很有用但不复杂的指令，可简化控制部件。选用简单的寻址方式，有利于减少指令的执行周期数。\n  （4）所有指令长度相同\n  （5）硬布线控制逻辑\n  （6）注重编译的优化\n  RISC指令系统的简化，必然使编译生成的代码长度增长。但通过编译优化技术，将编译初步生成的代码重新组织，调度指令的执行次序，以充分发挥内部操作的并行性，从而进一步提高流水线的执行效率。虽然编译优化技术使编译时间拉长，但这种代价的结果是使程序的执行时间缩短。而且程序的编译工作只需一次，编译后生成的优化执行代码却可以高效率地执行多次。因此这个代价是值得的。\n\n### 存储系统\n\n在物理构成上，存储系统通常分为3层：高速缓冲存储器Cache、主存和外存。Cache与主存常由半导体存储器构成；外存常由磁盘及光盘构成，也可以看作是I/O设备。一个高性能的计算机系统要求存储器的存储容量大，存取速度快，成本低廉，能支持复杂系统结构。这些要求往往相互矛盾，彼此形成制约。因此在一个计算机系统中，常采用几种不同的存储器，构成多级存储体系，以适应不同层次的需要。通常，对CPU直接访问的一级，其速度尽可能快些，而容量相对有限；作为后援的一级其容量尽可能大些，而速度可以相对慢些。经过合理的搭配和组织，对用户来说，整个存储系统能够提供足够大的存储容量和较快的存取速度。\n从用户的角度看，存储器还可以形成另一种层次结构，即物理存储器与虚拟存储器。物理存储器是指系统的物理组成中实际存在的主存，主存容量决定了实存空间的大小。在高档计算机中，依靠操作系统的软件支持及部分硬件的支持，可以使用户访问的编程空间远比实际主存空间大，用户感觉自己可编程访问一个很大的存储器，这个存储器称为虚拟存储器。\n\n#### 存储器的分类\n\n- 按存储器在计算机系统中的作用分类\n  （1）内部存储器内部存储器（简称内存或主存）是计算机主机的组成部分，用来存储当前运行所需要的程序和数据，CPU可以直接访问内存并与其交换信息。相对外部存储器而言，内存的容量小、存取速度快。由于CPU要频繁地访问内存，所以内存的性能在很大程度上影响了整个计算机系统的性能。\n  （2）外部存储器外部存储器也称辅助存储器或后援存储器，简称外存或辅存。外存用于存放当前不参加运行的程序和数据，以及一些需要永久保存的信息。外存设在设在主机外部，其容量大，但存取速度相对较慢，CPU不能直接访问它，而必须通过专门的设备才能对它进行读写（如磁盘驱动器等），这是它与内存之间的一个本质区别。\n  （3）高速缓冲存储器高速缓冲存储器（Cache）位于主存和CPU之间，用来存放正在执行的程序和数据，以便CPU能高速地访问它们。Cache的存取速度可以与CPU的速度相匹配，但其价格昂贵，存储容量较小。目前的微处理器通常将Cache或Cache的一部分制作在CPU芯片中。\n\n- 按存取方式分类\n  （1）随机存取存储器RAM（RandomAccessMemory）随机存取存储器是可读可写的存储器，CPU可以对RAM单元的内容随机地读/写访问，对任一单元的读出和写入的时间是一样的，即存取时间相同，并且与存储单元在存储器中所处的位置无关。RAM读/写方便，使用灵活，但断电后信息会丢失。RAM主要用作主存，也可用作高速缓存。\n  （2）只读存储器ROM（ReadOnlyMemory）只读存储器可以看作RAM的一种特殊形式，其特点是：存储器的内容只能随机读出而不能写入。这类存储器用来存放那些不需要改变的信息。由于信息一旦写入存储器就固定不变了，即使断电信息也不会丢失，所以又称它为固定存储器。ROM除了存放某些系统程序外，还用来存放专门的子程序，或用作函数发生器、字符发生器及微程序控制器中的控制存储器。有些ROM在特定条件下用特殊的装置或程序可以重新写入。\n  （3）顺序存取存储器SAM（SequentialAccessMemory）顺序存取存储器的存取方式与前两种完全不同，它的内容只能按某种顺序存取，存取时间的长短与信息在存储器上的物理位置有关，所以SAM只能用平均存取时间作为衡量存取速度的指标。磁带机就是典型的顺序存取存储器。\n  （4）直接存取存储器DAM（DirectAccessMemory）直接存取存储器既不像RAM那样能随机地访问存储器\n  存储器的任何一个存储单元，也不像SAM那样完全按顺序存取，而是介于两者之间。存取信息时，第1步直接指向存储器的某个小区域（如磁盘上的磁道）；第2步在小区域内顺序检索或等待，直到找到目的地后再进行读/写操作。这种存储器的存取时间也与信息所在的物理位置有关，但比SAM的存取时间要短。磁盘是最常见的直接存取存储器。\n\n- 按存储介质分类\n  （1）磁芯存储器\n  （2）半导体存储器\n  （3）磁表面存储器\n  （4）光盘存储器\n\n- 按信息的可保存性分类\n  断电后存储信息即消失的存储器，称为易失性存储器或挥发性存储器，RAM是易失性存储器。断电后信息仍然保存的存储器，称为非易失性存储器，也称为非挥发性存储器或永久性存储器，ROM、磁芯存储器、磁表面存储器和光盘存储器都是非易失性存储器。\n\n#### 主存的主要技术指标\n\n- 存储容量\n- 存取速度\n- 可靠性\n- 存取宽度\n\n#### 高速缓冲存储器Cache\n\n计算机系统整体性能的高低与许多因素有关，如CPU的主频、存储器的存取速度、系统架构、指令结构、信息在各部件之间的传送速度等。而CPU与主存之间的存取速度是一个很重要的因素。如果只是CPU工作速度很高，而主存的存取速度较低，就会造成CPU经常处于等待状态，既降低了处理速度，又浪费了CPU能力。为了减小CPU与主存之间的速度差异，现代微机中通常在慢速的DRAM和快速的CPU之间插入一个速度较快、容量较小的SRAM，起到缓冲作用，使CPU既能以较快速度存取SRAM中的数据，又不使系统成本上升过高，这就是Cache技术。\n\n![](./计算机组成原理与汇编语言程序设计/4.jpg)\n\n由此可以想到，如果把一段时间内在一定地址范围中被频繁访问的信息集合成批地从主存读到一个能高速存取的小容量存储器中存放起来，供程序在这段时间内随时使用，从而尽量减少访问速度较慢的主存的次数，可以加快程序的运行速度，这就是Cache的设计思想，即在CPU和主存之间设置一个小容量的高速缓冲存储器（Cache）。  Cache中存放着最近要使用的程序与数据，作为主存中当前最急需执行信息的副本。其容量约为数KB到数百KB，由于容量较小，可以选用高速半导体存储器，使CPU访存速度得到提高。在高档微处理器中，在CPU芯片内集成了1～2个高速缓存，称为片内Cache，还允许在CPU芯片外扩充Cache。\n有了Cache，系统在工作时总是不断地将与当前指令集相关联的一个不太大的后继指令集从主存读到Cache，然后再向CPU高速传送，从而达到速度匹配。当CPU需要访存时，同时将地址送往主存与Cache。若所需访问的内容已经在Cache中，则可直接从Cache中快速读取信息，这称为访问Cache命中；若访问的内容不在Cache中，即未命中，则从主存中读取信息，并考虑更新Cache，使其成为当前最急需部分。为此需要实现访存地址与Cache物理地址间的映像变换。\n由于局部性原理不能保证所请求的数据百分之百地在Cache中，这里便存在一个命中率问题。所谓命中率，就是在CPU访问Cache时，所需信息恰好在Cache中的概率。命中率越高，正确获取数据的可能性就越大，目前Cache的访问命中率可达到90%以上。因此只要合理组织三级存储体系，从整体上讲，CPU就能以接近Cache的速度访问存储器，而总存储容量相当于联机外存的总容量。\n一般来说，Cache的存储容量比主存的容量小得多，但不能太小，太小会使命中率太低。但也没有必要过大，过大不仅会增加成本，而且当Cache容量超过一定值后，命中率随容量的增加将不会有明显增长。所以Cache的空间与主存空间在一定范围内应保持适当比例的映射关系，以保证Cache有较高的命中率，且系统成本不会过多地增加。Cache的命中率与Cache的映像方式、替换算法、程序特性等因素有关。\n\n#### 存储系统的层次结构\n\n![](./计算机组成原理与汇编语言程序设计/5.jpg)\n\n 要真正解决存储器的容量、速度、价格之间的矛盾，不能只是将上面的各个层次的存储器进行简单组合，必须在系统结构上采取措施，采用不同速度、不同容量和不同价格的多种存储器件，按层次组成存储系统。各个层次的存储器之间通过硬件和软件有机地结合成一个统一的整体，无需程序员的干预而由计算机自动地实现调度，向程序员提供足够大的存储空间，同时最大限度地与CPU速度相匹配。按这样的思想组成的存储层次结构，称为存储体系结构。\n典型的三级存储体系结构，分为“高速缓存—主存—辅存”三个层次。现在的计算机系统大多具备这三级存储结构。三级存储体系又分为两个层次，高速缓存和主存之间形成Cache-主存层次，主存和辅存之间形成主存-辅存层次。 \n\n![](./计算机组成原理与汇编语言程序设计/6.jpg)\n\n- Cache-主存层次　\n  通过辅助硬件将Cache和主存构成一个整体，如上图所示。从整体上看，该层次具有接近于Cache的存取速度、主存容量和平均位价格，解决了存储器高速与低成本之间的矛盾。这个层次完全由硬件实现，不受软件的干预，因此对所有程序员都是透明的。\n- 主存-辅存层次　\n  随着操作系统和硬件技术的发展，利用附加硬件及存储管理软件，使主存和辅存构成一个整体，形成主存-辅存层次，如图上图所示。辅存只与主存交换信息，不能直接由CPU访问。从整体上看，该层次的存取速度接近于主存的存取速度，容量则接近于辅存的容量，而位价格也接近于廉价的辅存平均价格，从而解决了大容量和低成本之间的矛盾。三级存储体系结构的总的效果是：存取速度接近于Cache，存储容量接近于辅存容量，整体价格也比较合理。\n\n#### 磁盘冗余阵列\n\n廉价冗余磁盘阵列（RedundantArraysofInexpensiveDisk，RAID）是用多台磁盘存储器组成的大容量外存子系统，它是由多台磁盘机按一定规则（如分条、分块、交叉存取等）组合在一起构成的。通过阵列控制器的控制和管理，磁盘阵列系统能够将几个、几十个甚至几百个硬盘组合起来，使其容量高达几百GB甚至上千GB。其基础是数据分块技术，即在多个磁盘上交错存放数据，通过阵列控制器实现数据的并行、交叉存储或单独存储操作。由于阵列中的一部分磁盘存有冗余信息，一旦系统中某一磁盘失效，可以利用冗余信息重建用户数据。\n\n- RAID0级（无冗余和无校验的数据分块）\n  数据分布在阵列中的所有磁盘上，与单个大容量磁盘相比，它的显著优点是：如果两个I/O请求正在等待不同的数据块，则被请求的块有可能在不同的盘上。因此，两个请求能够并行发出，减少了I/O的排队时间。RAID0级具有最高的I/O性能和磁盘空间利用率，但无容错能力，增加了系统出故障的几率。若阵列中有一块磁盘损坏，将造成不可弥补的损失。其安全性甚至低于常规的硬盘系统，所以不适于对数据稳定性要求高的应用。\n- RAID1级（镜像磁盘阵列）\n  由磁盘对组成，每个工作盘都有对应的镜像盘，上面保存着与工作盘完全相同的数据。如果镜像盘组中一个物理磁盘出现故障，系统可以使用未受影响的另一个磁盘继续操作，数据不会丢失，但磁盘空间的利用率只有50%。RAID1级的安全性高，而主要缺点是价格昂贵，它需要支持2倍于逻辑磁盘的磁盘空间。因此，RAID1级的配置只限于存储系统软件、数据和其他关键文件的驱动器中。在这种情况下，RAID1级对所有的数据提供实时备份，在磁盘损坏时，所有的关键数据仍立即可用。\n- RAID2级（具有纠错海明码的磁盘阵列）\n- RAID3、4、5、6、7级\n- RAID10级（RAID0级+RAID1级）\n  这是一种复合的RAID模式，将RAID0的速度与RAID1的冗余特性相结合，既可提供数据分块，又能提供镜像功能，是所有RAID中性能最好的磁盘阵列，但每次写入时要写两个互为镜像的盘，价格高。这种结构特别适用于既有大量数据需要存取，同时又对数据安全性要求严格的领域，如银行、金融、商业超市、仓储库房、各种档案管理等。\n\n#### 虚拟存储系统的组织\n\n虚拟存储系统建立在主存-辅存层次上，是由附加硬件装置及存储管理软件组成的存储体系，它使计算机具有接近主存的存取速度，并具有辅存的容量和位成本。\n在采用磁盘作为后援存储器后，可以在存储管理部件和操作系统存储管理软件的支持下，将主存和辅存的地址空间统一编址，使用户获得一个很大的编程空间，其容量大大超过实际的主存储器。这个在用户界面上看到的存储器，被称为虚拟存储器（VirtualMemory，VM），这样的虚拟存储技术对用户来说，自然是极有价值的，因而已在计算机系统中广泛使用，高档微处理器芯片也为此提供了有关硬件支撑。从用户界面看，用户可使用位数较长的编程地址进行编程，这种地址面向程序的需要，不必考虑程序将来在主存储器中的实际位置，因而称为逻辑地址。它是面向虚拟存储器的，所以又称为虚地址。在用户看来，CPU可按虚地址访问一个很大的存储器，其容量甚至可达整个辅存容量，显然这是一种虚拟层次。\n在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前急需运行的部分调入主存，供CPU操作，其余暂不运行部分留在磁盘中，随程序执行的需要，操作系统自动地按一定替换算法进行调度，将当前暂不运行部分调回磁盘，将新的模块由磁盘调入主存。这一层次上的工作，对用户是透明的。CPU执行程序时，需将程序提供的虚地址变换为主存的实际地址（实地址、物理地址）。一般是先由存储管理部件判断该地址的内容是否在主存中，若已调入主存，则通过地址变换机制将虚地址转换为实地址，然后访问主存单元；若尚未调入主存，则通过缺页中断程序，以页为单位调入或实现主存内容调换。从原理上看，虚拟存储器与Cache-主存层次有很多相似之处，如地址映像方式和替换策略。但是，Cache-主存层次的控制完全由硬件实现，它对各类程序员都是透明的；而虚拟存储器的控制是由硬件与软件结合实现，对应用程序员来说是透明的，但对于设计存储器管理软件的系统程序员来说是不透明的。\n\n# 感想\n\n无\n","slug":"计算机组成原理与汇编语言程序设计","published":1,"updated":"2022-11-01T15:33:30.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38w7000uq8t73ca4bplc","content":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《计算机组成原理与汇编语言程序设计（第4版）(高等学校规划教材)》 徐洁 电子工业出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><h2 id=\"硬件组成\"><a href=\"#硬件组成\" class=\"headerlink\" title=\"硬件组成\"></a>硬件组成</h2><p>在早期，冯·诺依曼将计算机的硬件组成分为5大部件。几十年来，计算机硬件系统已有了许多重大变化。首先，现在采用的大规模及超大规模集成电路，可将运算器和控制器集成在一块芯片上，合称为中央处理器（CPU）。它是负责执行程序，实现运算处理，控制整个系统的部件。相应地，原来的运算器现在作为CPU中的运算部件（又称为算术逻辑部件），它与控制器之间的界限已不像原来那样分明。其次，存储器分为高速缓存、主存储器、外存储器三个层次。其中高速缓存常集成在CPU内部，作为CPU的一个部分，也可以在CPU之外再设置一级高速缓存。通常将CPU与主存储器合在一起称为主机，主存储器（简称主存）就是因为位于主机之内而得名，有的书中又称它为内存储器（内存）。位于主机之外的磁盘、光盘、磁带等，则作为外存储器（外存）。还有，输入设备的任务是将外部信息输入主机，输出设备则是将主机的运算处理结果或其他信息从主机输出。但从信息传送控制的角度看，它们并无多大区别，不过是传送方向不同而已。有些设备还兼有输入与输出两种功能，所以在描述系统结构时常将它们合称为输入&#x2F;输出设备，简称I&#x2F;O设备。 </p>\n<p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/1.jpg\"></p>\n<h3 id=\"cpu\"><a href=\"#cpu\" class=\"headerlink\" title=\"cpu\"></a>cpu</h3><p>CPU（CentralProcessingUnit）即中央处理器，是硬件系统的核心部件，负责读取并执行指令，也就是执行程序。<br>在CPU中有一个程序计数器PC（ProgramCounter），它存放着当前指令所在存储单元的地址。如果程序是顺序执行，在读取一个或连续几个存储单元的指令代码后，PC的内容就加1或加几，以指出下一条指令的地址；如果程序需要转移，则将转移地址送入PC。因此，PC就像一个指针，指引着程序的执行顺序。虽然指令与数据都采用二进制代码表示，在外形上没有区别，但可按照PC中的中的地址信息去读取指令，再按照指令给出的操作数地址去读取数据。<br>CPU内有一个或多个算术逻辑部件ALU（ArithmeticLogicUnit）。通常按照指令的要求将有关数据送入ALU，进行指定的算术或逻辑运算，然后将运算结果送到主存单元，或暂存在CPU内的寄存器中。CPU内的主要部分是控制器（又称为控制部件），它的任务是控制整个系统的工作，决定在什么时候，根据什么，发出什么命令，做什么操作。例如它控制着从主存中读取指令，根据指令代码分时地发出一些最基本的控制信号即微命令，控制存储器的读写、ALU的运算处理、数据的输入&#x2F;输出等。按照产生微命令的方式不同，控制器可分为两大类：组合逻辑控制器及微程序控制器。<br>组合逻辑控制器完全靠若干组合逻辑电路（即硬件）产生微命令序列，将指令代码、状态信息、时序信号等输入到这些组合逻辑电路，电路将分时产生相应的微操作命令。这种控制器又称硬连逻辑控制器，其优点是形成微命令的速度快，常用于精简指令系统计算机（RISC）中。<br>微程序控制器是将微命令序列以代码形式编制成微程序，存入一个控制存储器中；当CPU执行指令时，通过读取并执行对应的一段微程序，产生微命令序列，控制完成指定的操作。微程序控制方式比较规整，硬件代价较小，易于扩充功能，但速度较慢。</p>\n<h3 id=\"主存储器\"><a href=\"#主存储器\" class=\"headerlink\" title=\"主存储器\"></a>主存储器</h3><p>我们总是希望计算机系统中的存储器容量大，存取速度快，但这往往是有矛盾的，所以常将存储器分为几级。其中主存储器用半导体存储器构成，工作速度较高，也有一定的存储容量。外存储器为主存提供后援，由磁盘、光盘、磁带等构成，其存储容量很大，但速度较主存储器低。高速缓冲存储器、主存储器和外存储器，组合成一个完整的多级存储系统，使得整个系统既有很大的存储容量，而CPU又可以高速地访问存储器。主存储器用来存放需要执行的程序及需要处理的数据，能由CPU直接读出或写入。<br>主存储器的一项重要特性是：能按地址（单元编号）存放或读取内容，也就是允许CPU直接编址访问，通常以字节为编址单位。对主存储器来说，寻找存储单元（寻址）的依据是地址码，所存取的内容是指令或数据。</p>\n<h3 id=\"外存储器\"><a href=\"#外存储器\" class=\"headerlink\" title=\"外存储器\"></a>外存储器</h3><p>外存储器用来存放那些需要联机存放，但暂不执行的程序和数据，当需要运行它们时再由外存调入主存。例如在光盘中存放着几个备用的软件，但当前暂时只用得着用得着其中的一个，我们先将它调入主存，其余软件仍存放在光盘上。又如一个信息管理系统所保存的数据很多，可将它们存放在磁盘之中，只将当前需要查询的部分调入主存，以后再调换。这样，主存的容量就不需要很大，可以做到速度比较快。而由磁盘、光盘等构成的外存储器容量很大，可为整个系统提供后援支持，其速度要求可以比主存低一些。<br>由于外存储器不由CPU直接编址访问，也就是说不需要按字节地从外存储器读取或写入，因此外存储器中的内容一般都按文件的形式进行组织，一个文件常分解为若干数据块，可以包含许多字节的信息。用户按文件名进行调用，CPU找到该文件在外存中的存放位置，以数据块为单位进行读写。</p>\n<h3 id=\"输入-x2F-输出设备\"><a href=\"#输入-x2F-输出设备\" class=\"headerlink\" title=\"输入&#x2F;输出设备\"></a>输入&#x2F;输出设备</h3><p>计算机系统大多配备了键盘、鼠标、显示器、打印机等常规输入&#x2F;输出设备，简称I&#x2F;O设备。</p>\n<h3 id=\"总线\"><a href=\"#总线\" class=\"headerlink\" title=\"总线\"></a>总线</h3><p>怎样将CPU、主存、多台I&#x2F;O设备连接成整机系统呢？现在普遍采用总线结构。所谓总线是指一组能为多个部件分时共享的信息传输线。</p>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>一台计算机系统需连接哪些I&#x2F;O设备，这要根据该系统的应用场合而定，因此通过系统总线连接的设备，其类型与数量都应当可以扩充。某种型号的计算机系统，其系统总线往往是标准的，也就是说，有多少根地址线、数据线，有哪些控制信号线，每个信号的名称及作用等，都是规定好的。</p>\n<p>概括地说，计算机硬件系统是由三大子系统：CPU、存储系统（包括高速缓存、主存和外存）、输入&#x2F;输出系统（包括输入&#x2F;输出设备和接口），以及连接它们的总线构成。</p>\n<h2 id=\"计算机软件系统\"><a href=\"#计算机软件系统\" class=\"headerlink\" title=\"计算机软件系统\"></a>计算机软件系统</h2><h3 id=\"系统软件\"><a href=\"#系统软件\" class=\"headerlink\" title=\"系统软件\"></a>系统软件</h3><ul>\n<li><p>操作系统</p>\n</li>\n<li><p>编译程序与解释程序</p>\n</li>\n</ul>\n<p>计算机硬件能够直接识别的是数字代码，所以让计算机硬件执行的基本命令，如传送、加、减等，必须用0、1这样的数字编码来表示。由硬件执行的程序的最终形态是由若干指令组成的序列，即指令是程序（可执行形态）的基本单位。一般地，一条指令规定了一种基本操作（如传送、加、减），并提供操作数地址或直接提供操作数，这些信息都由数字代码表示。一台计算机可以执行的各种指令的集合，称为这种计算机的指令系统。显然，不同的机型往往具有不同的指令系统，以及相应的指令格式约定，所以机器指令代码又称为机器语言，即面向特定机器结构的一种内部语言。<br>如果直接用机器语言（0、1代码）编制程序，将非常不便，于是人们想到用一些约定的符号，如英文缩写的字符串，去表示操作含义、操作数、地址等，这就产生了汇编语言。汇编语言是一种用符号表示的与机器指令基本对应的程序设计语言，它专属于某种机型或某种系列机，其他计算机不能直接使用，所以是一种面向机器结构的程序设计语言，不是通用语言。<br>为了便于编制程序，现在所使用的绝大多数编程语言是高级程序设计语言，这是一些面向用户，与特定机器属性相分离的语言。高级程序设计语言与机器指令之间没有直接的对应关系，所以它可以在各种机型中通用，编程者使用高级语言也不必了解具体的机器指令系统及其他硬件属性。高级程序设计语言需要遵循一定的严格语法规定与格式，才能为语言处理程序（编译、解释）所识别。<br>机器语言是机器内部使用的、用数字代码表示的指令代码，面向某一特定机型，可由硬件直接识别并执行。汇编语言是一种用符号表示的，面向某一特定机型的程序设计语言，它的指令语句与机器指令一一对应。高级程序设计语言则是面向用户，与特定机器属性相分离的程序设计语言，具有通用性。<br>大多数情况下，用户采用高级程序设计语言编写程序，个别情况采用汇编语言编写程序。用这些程序设计语言编写出的程序叫做源程序，它们由一些语句组成。将源程序输入计算机后，计算机先执行一种语言处理程序，将源程序转换为机器语言代码序列，即机器语言程序，然后由计算机硬件执行这些用机器语言代码表示的指令序列，从而完成用户程序的执行过程。这种语言处理程序也是一种必需的系统软件。<br>语言处理方式有两种类型：解释与编译。解释方式是边解释边执行，为此需要一种针对某种程序设计语言的解释程序（又称解释器）作为系统软件的组成部分之一。将源程序输入计算机后，启动并执行相应的解释程序，它的作用是逐步分析源程序中的语句，按照源程序描述的过程，执行一个与此等价的机器语言指令序列，直到整个源程序都被扫描一遍，并被解释执行完毕为止。这有点像口译外语的情形，边说边翻译。解释方式适用于比较简单的程序设计语言，如BASIC。它的优点是支持人机对话方式的程序设计，可以边执行边修改；所需要的主存空间较小。但是这种方式的执行速度较慢，不能解释那些前后关联较多、较难理解的程序设计语言。大多数程序设计语言采用编译方式。将源程序输入计算机后，先启动并执行相应的编译程序（又称编译器），将源程序全部翻译成目标程序（目标代码）的机器语言指令序列。执行时，计算机将直接执行目标程序，不再需要源程序与翻译程序。因此，这种编译方式有点像笔译，得到完整的译文后就可以不要原文与译者了。在编译过程中，它所需的主存空间比解释方式多些，既要容纳源程序又要容纳一个比较大的编译程序；需花费的时间也要长些。但运行用户程序时，所需的主存空间比较小，执行速度也较快。<br>将汇编语言源程序转换为机器代码的目标程序的过程也是一种编译，人们将它专门称为“汇编”，相应的翻译程序称为汇编程序（又称汇编器）。它的逆过程叫做“反汇编”，即将用机器代码表示的目标程序（指令序列）反汇编成用汇编语言描述的程序。为利于二次开发，在剖析一些已有的重要软件时，常常需要进行反汇编。</p>\n<ul>\n<li>各种软件平台</li>\n</ul>\n<h3 id=\"应用软件\"><a href=\"#应用软件\" class=\"headerlink\" title=\"应用软件\"></a>应用软件</h3><p>应用软件不胜枚举，它一般包括：①科学计算类；②数据处理类；③自动控制类；④计算机辅助设计类；⑤人工智能类；等等。</p>\n<h2 id=\"计算机系统层次\"><a href=\"#计算机系统层次\" class=\"headerlink\" title=\"计算机系统层次\"></a>计算机系统层次</h2><h3 id=\"从计算机系统组成角度划分层次结构\"><a href=\"#从计算机系统组成角度划分层次结构\" class=\"headerlink\" title=\"从计算机系统组成角度划分层次结构\"></a>从计算机系统组成角度划分层次结构</h3><p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/2.jpg\"></p>\n<ol>\n<li><p>微体系结构层<br>微体系结构层是具体存在的硬件层次，在这一层我们看到的不是由大部件（即CPU、存储系统、输入&#x2F;输出系统及互连机构）构成的计算机，而是更细微的机器结构。微体系结构层执行机器指令，它可看作是指令系统层指令的解释器。在由微程序控制数据通路的计算机上，微程序就是上一层指令的解释器。它通过数据通路逐条对指令进行取指、译码和执行。例如，对加法ADD指令，将首先取出指令进行译码分析，然后找到操作数送入寄存器，由ALU求和，最后存结果。结果到指定地方，如某个存储器单元。而在硬件直接控制数据通路的计算机上，执行的步骤与此类似，但是由硬件直接解释执行指令，并不存在一个真正的程序来解释上一层的指令。</p>\n</li>\n<li><p>指令系统层<br>原则上，指令系统层是机器语言程序员眼中所看到的计算机，当然现在人们并不使用机器语言编程。指令系统层位于微体系结构层之上，是一个抽象的层次，其主要特征就是指令系统。指令系统（又称指令集）是指一台计算机所能执行的全部指令的集合。其指令是由微体系结构层的微程序解释执行或硬件电路直接执行的。<br>指令系统是计算机软件与硬件之间的一种接口。硬件系统的基本任务是实现指令系统所规定的各种指令功能，而各种程序只有最终转化为用机器语言（即代码表示的指令序列）才能被硬件执行。尽管现在已广泛应用各种高级语言编程，但需通过编译器或解释器将高级语言程序转换为硬件可以识别与执行的机器指令序列。<br>指令系统层定义了硬件和编译器之间的接口，它是一种硬件和编译器都能理解的语言。一方面，指令系统表明了一台计算机具有哪些硬件功能，是硬件逻辑设计的基础。因此，在指令系统层，应该定义一套在当前和将来的技术条件下能够高效率实现的指令集，从而使高效率的设计可用于今后的若干代计算机中。另一方面，指令系统层应该为编译器提供明确的编译目标，使编译结果具有规律性和完整性。</p>\n</li>\n<li><p>操作系统层<br>从程序员的观点来看，操作系统是一个在指令系统层提供的指令和特性之上又增加了新指令和特性的程序。这一层有新的指令集，有不同的存储器结构，有同时运行两个或多个程序的能力，以及其他一些特性。<br>尽管操作系统层和指令系统层都是抽象层次，但它们之间具有重要的区别。操作系统层指令集是系统程序员完全可用的指令集。它包括几乎所有的指令系统层的指令和操作系统层增加的新指令。这些新指令称为系统调用（SystemCall），如DOS操作系统的系统功能调用“INT21H”用于设备、文件和目录等管理，Linux操作系统的系统调用“fork()”用来创建一个进程。一个系统调用使用一条新指令调用一个预先定义好的操作系统服务，这样效率很高。一个典型的系统调用是从一个文件中读取数据。这一层增加的系统调用是由运行在指令系统层上的操作系统解释执行的。当一个用户程序执行一个系统调用时，比如从一个文件中读取数据，操作系统将一步步地执行这个调用。但是，那些和第2层指令相同的本层指令将直接交给微体系结构层执行，而不是由操作系统执行。换句话说，本层的新增指令由操作系统解释，而其他指令由微体系结构层直接执行，因此又将本层称为“混合层”。<br>这一层并不是为普通程序员的使用而设计的，主要是为支持高层所需的解释器或翻译器运行而设计的。</p>\n</li>\n<li><p>汇编语言层<br>微体系结构层可看作指令系统层指令的解释器，使指令系统的功能得以实现。但是，直接用机器指令代码编程是非常困难的，而让微体系结构层直接执行高级语言也不是好办法。因此，人们为所有的计算机都设计了一个汇编语言层，它位于指令系统层、操作系统层与面向问题语言层之间。从这一层看去，每一种计算机都有一套自己的汇编语言、解释它的汇编器，以及相应的程序设计与开发方法。汇编语言层以及上层是提供给解决应用问题的应用程序员使用的。第1、2、3层提供的机器语言都是二进制代码，适合机器执行，但不容易被人理解。从第4层开始，其提供的语言是人们能理解的单词和缩略语。汇编语言实际就是“符号化”的机器语言，每一条汇编指令语句都对应一条机器语言指令，它是它是面向机器结构的语言。用汇编语言编写的程序先由汇编器翻译成机器语言程序，然后由微体系结构层解释执行。这一层支持上层的方法与低层不同。第2层和第3层主要用的是解释；而第4层和第5层通常用的是编译。</p>\n</li>\n<li><p>面向问题语言层<br>BASIC、C、C++、Java、LISP等</p>\n</li>\n</ol>\n<h3 id=\"从语言功能角度划分层次结构\"><a href=\"#从语言功能角度划分层次结构\" class=\"headerlink\" title=\"从语言功能角度划分层次结构\"></a>从语言功能角度划分层次结构</h3><p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/3.jpg\"></p>\n<p>如果将计算机功能描述为“能执行用某些程序设计语言编写的程序”，那么用户看到的就是上图的语言功能层次模型。计算机硬件的物理功能是执行机器语言，称为机器语言物理机，从这一级看到的是一台实际的机器。而用户看到的是能执行某种语言程序的虚拟机，即通过配置某种语言处理程序后所形成的一台计算机。<br>与机器语言最接近的是汇编语言，它的基本成分是与指令系统一一对应的用助记符描述的汇编语句。与算法、数学模型甚至自然语言接近的，称为高级语言，它具有较强的通用性，在这一范畴内已推出了多种通用的高级程序设计语言。针对某些特定应用领域与用户，也可使用某种专用语言，它们一般面向应用，如所要求解的问题。<br>大多数计算机都是先将用程序设计语言编写的程序翻译为机器语言，然后才能执行。一般是直接翻译为机器语言。但当高级语言较复杂时，也可能分级编译，即先翻译为层次低些的某种中间语言，再将中间语言进一步翻译为机器语言，如上图虚线所示。<br>所谓虚拟机，通常是指通过配置软件（如某种语言的编译器或解释器）扩充机器功能后所形成的一台计算机。实际硬件在物理功能级上并不具备这种机器功能，因而称为虚拟机。采用虚拟机概念是计算机设计中的又一重要策略，它将提供给用户的功能抽象出来，使其脱离具体的物理机器，这有利于让用户摆脱真实物理机细节的束缚，获得超越物理机的功能。<br>广泛使用的Java虚拟机（JavaVirtualMachine，JVM）的概念。为了使Java程序能在不同的计算机上运行，Sun公司定义了一种称为Java虚拟机的虚拟体系结构。它有32位字组成的内存，能执行226条指令。大多数指令都很简单，只有一些比较复杂，需要多次内存循环。</p>\n<h3 id=\"软硬件逻辑上等价\"><a href=\"#软硬件逻辑上等价\" class=\"headerlink\" title=\"软硬件逻辑上等价\"></a>软硬件逻辑上等价</h3><p>如果说系统设计者必须关心软、硬件之间的界面，即哪些功能由硬件实现，哪些由软件实现；用户则更关心系统究竟能提供哪些功能。至于这些功能是由硬件还是软件实现，在逻辑功能上则是等价的，只是执行速度有差别而已。</p>\n<h3 id=\"计算机的性能指标\"><a href=\"#计算机的性能指标\" class=\"headerlink\" title=\"计算机的性能指标\"></a>计算机的性能指标</h3><ul>\n<li><p>基本字长</p>\n</li>\n<li><p>数据通路宽度</p>\n</li>\n<li><p>运算速度</p>\n</li>\n<li><p>主存储器容量</p>\n</li>\n<li><p>外存容量</p>\n</li>\n<li><p>配置的外围设备及其性能</p>\n</li>\n<li><p>系统软件配置</p>\n</li>\n</ul>\n<h3 id=\"提高计算机性能的若干技术\"><a href=\"#提高计算机性能的若干技术\" class=\"headerlink\" title=\"提高计算机性能的若干技术\"></a>提高计算机性能的若干技术</h3><ul>\n<li><p>提高单CPU性能的若干技术<br>（1）流水线处理技术<br>（2）RISC（精简指令系统计算机）技术<br>（3）超标量技术<br>（4）平衡不同子系统的数据吞吐率</p>\n</li>\n<li><p>并行计算机</p>\n</li>\n</ul>\n<h3 id=\"精简指令集计算机（RISC）\"><a href=\"#精简指令集计算机（RISC）\" class=\"headerlink\" title=\"精简指令集计算机（RISC）\"></a>精简指令集计算机（RISC）</h3><ul>\n<li>概念</li>\n</ul>\n<p>随着超大规模集成电路VLSI技术的迅速发展，计算机系统的硬件成本不断下降，而软件成本却在不断上升。因此，人们热衷于在指令系统中增加更多的指令和更复杂的指令，以适应不同应用领域的需要，并考虑尽量缩短指令系统与高级语言之间的语义差异，以便于实现高级语言的编译和降低软件成本。另外，为了维护系列机的软件兼容性，也使指令系统变得越来越庞大。在系列机中，为了使老用户在软件上的投资不受损失，新机型必须继承老机器指令系统中的全部指令，这种情况使同一系列计算机的指令系统越来越复杂。一般来说，人们在计算机设计方面的传统想法和做法是：字长愈长、性能愈高的计算机，其指令系统就应该愈复杂，按这种传统方法设计的计算机系统称为复杂指令系统计算机，简称CISC。指令系统很复杂、功能很强并不一定能提高机器的速度，CISC中采用很多复杂的寻址方式，为了计算有效地址需花费一定的时间；有的指令需要多次访问主存储器，所以执行速度会降低。</p>\n<p>复杂指令系统的实现需要复杂的控制器来支持，并且系列机为实现兼容，其控制部件多用微程序控制方式来实现，以便于指令系统的扩展。但微程序控制部件执行一条机器指令通常需要几个微周期，因此严重降低了指令的执行速度。为了提高指令的执行速度，CISC中常采用流水线技术。但由于存在很多问题，例如指令系统采用变字长指令、不同指令争用共同资源以及转移指令等，使流水线的效率不高。以上情况表明，传统的CISC设计思想并不利于提高计算机的速度。而且复杂的指令系统必然增加硬件实现的复杂性，从而使计算机的研制周期长、投资大。因此人们开始研究指令系统的合理性问题。对CISC指令系统运行的统计分析表明，各种指令的使用频率相差悬殊，最常用的是一些比较简单的指令，仅占指令总数的20%，但在程序中出现的频率却占80%。1975年，IBM公司提出了精简指令系统的想法。后来美国加利福尼亚大学伯克利分校的RISCI和RISCII、斯坦福大学的MIPS机的研制成功，为精简指令系统计算机（简称RISC）的诞生与发展起了很大作用。</p>\n<ul>\n<li>RISC的特点</li>\n</ul>\n<p>精简指令系统计算机的着眼点不是简单地放在简化指令系统上，而是通过简化指令使计算机的结构更加简单合理，更易于流水线的实现，从而提高处理速度。<br>  （1）面向寄存器的结构所有运算使用的数据都来自寄存器，运算结果也都写入寄存器。寄存器的典型长度是32位或64位。通常CPU内应设置大量的通用寄存器，以减少访问主存储器。<br>  （2）采用LOAD&#x2F;STORE结构<br>  （3）较少的指令数和寻址方式<br>  选取使用频率最高的一些简单指令，以及很有用但不复杂的指令，可简化控制部件。选用简单的寻址方式，有利于减少指令的执行周期数。<br>  （4）所有指令长度相同<br>  （5）硬布线控制逻辑<br>  （6）注重编译的优化<br>  RISC指令系统的简化，必然使编译生成的代码长度增长。但通过编译优化技术，将编译初步生成的代码重新组织，调度指令的执行次序，以充分发挥内部操作的并行性，从而进一步提高流水线的执行效率。虽然编译优化技术使编译时间拉长，但这种代价的结果是使程序的执行时间缩短。而且程序的编译工作只需一次，编译后生成的优化执行代码却可以高效率地执行多次。因此这个代价是值得的。</p>\n<h3 id=\"存储系统\"><a href=\"#存储系统\" class=\"headerlink\" title=\"存储系统\"></a>存储系统</h3><p>在物理构成上，存储系统通常分为3层：高速缓冲存储器Cache、主存和外存。Cache与主存常由半导体存储器构成；外存常由磁盘及光盘构成，也可以看作是I&#x2F;O设备。一个高性能的计算机系统要求存储器的存储容量大，存取速度快，成本低廉，能支持复杂系统结构。这些要求往往相互矛盾，彼此形成制约。因此在一个计算机系统中，常采用几种不同的存储器，构成多级存储体系，以适应不同层次的需要。通常，对CPU直接访问的一级，其速度尽可能快些，而容量相对有限；作为后援的一级其容量尽可能大些，而速度可以相对慢些。经过合理的搭配和组织，对用户来说，整个存储系统能够提供足够大的存储容量和较快的存取速度。<br>从用户的角度看，存储器还可以形成另一种层次结构，即物理存储器与虚拟存储器。物理存储器是指系统的物理组成中实际存在的主存，主存容量决定了实存空间的大小。在高档计算机中，依靠操作系统的软件支持及部分硬件的支持，可以使用户访问的编程空间远比实际主存空间大，用户感觉自己可编程访问一个很大的存储器，这个存储器称为虚拟存储器。</p>\n<h4 id=\"存储器的分类\"><a href=\"#存储器的分类\" class=\"headerlink\" title=\"存储器的分类\"></a>存储器的分类</h4><ul>\n<li><p>按存储器在计算机系统中的作用分类<br>（1）内部存储器内部存储器（简称内存或主存）是计算机主机的组成部分，用来存储当前运行所需要的程序和数据，CPU可以直接访问内存并与其交换信息。相对外部存储器而言，内存的容量小、存取速度快。由于CPU要频繁地访问内存，所以内存的性能在很大程度上影响了整个计算机系统的性能。<br>（2）外部存储器外部存储器也称辅助存储器或后援存储器，简称外存或辅存。外存用于存放当前不参加运行的程序和数据，以及一些需要永久保存的信息。外存设在设在主机外部，其容量大，但存取速度相对较慢，CPU不能直接访问它，而必须通过专门的设备才能对它进行读写（如磁盘驱动器等），这是它与内存之间的一个本质区别。<br>（3）高速缓冲存储器高速缓冲存储器（Cache）位于主存和CPU之间，用来存放正在执行的程序和数据，以便CPU能高速地访问它们。Cache的存取速度可以与CPU的速度相匹配，但其价格昂贵，存储容量较小。目前的微处理器通常将Cache或Cache的一部分制作在CPU芯片中。</p>\n</li>\n<li><p>按存取方式分类<br>（1）随机存取存储器RAM（RandomAccessMemory）随机存取存储器是可读可写的存储器，CPU可以对RAM单元的内容随机地读&#x2F;写访问，对任一单元的读出和写入的时间是一样的，即存取时间相同，并且与存储单元在存储器中所处的位置无关。RAM读&#x2F;写方便，使用灵活，但断电后信息会丢失。RAM主要用作主存，也可用作高速缓存。<br>（2）只读存储器ROM（ReadOnlyMemory）只读存储器可以看作RAM的一种特殊形式，其特点是：存储器的内容只能随机读出而不能写入。这类存储器用来存放那些不需要改变的信息。由于信息一旦写入存储器就固定不变了，即使断电信息也不会丢失，所以又称它为固定存储器。ROM除了存放某些系统程序外，还用来存放专门的子程序，或用作函数发生器、字符发生器及微程序控制器中的控制存储器。有些ROM在特定条件下用特殊的装置或程序可以重新写入。<br>（3）顺序存取存储器SAM（SequentialAccessMemory）顺序存取存储器的存取方式与前两种完全不同，它的内容只能按某种顺序存取，存取时间的长短与信息在存储器上的物理位置有关，所以SAM只能用平均存取时间作为衡量存取速度的指标。磁带机就是典型的顺序存取存储器。<br>（4）直接存取存储器DAM（DirectAccessMemory）直接存取存储器既不像RAM那样能随机地访问存储器<br>存储器的任何一个存储单元，也不像SAM那样完全按顺序存取，而是介于两者之间。存取信息时，第1步直接指向存储器的某个小区域（如磁盘上的磁道）；第2步在小区域内顺序检索或等待，直到找到目的地后再进行读&#x2F;写操作。这种存储器的存取时间也与信息所在的物理位置有关，但比SAM的存取时间要短。磁盘是最常见的直接存取存储器。</p>\n</li>\n<li><p>按存储介质分类<br>（1）磁芯存储器<br>（2）半导体存储器<br>（3）磁表面存储器<br>（4）光盘存储器</p>\n</li>\n<li><p>按信息的可保存性分类<br>断电后存储信息即消失的存储器，称为易失性存储器或挥发性存储器，RAM是易失性存储器。断电后信息仍然保存的存储器，称为非易失性存储器，也称为非挥发性存储器或永久性存储器，ROM、磁芯存储器、磁表面存储器和光盘存储器都是非易失性存储器。</p>\n</li>\n</ul>\n<h4 id=\"主存的主要技术指标\"><a href=\"#主存的主要技术指标\" class=\"headerlink\" title=\"主存的主要技术指标\"></a>主存的主要技术指标</h4><ul>\n<li>存储容量</li>\n<li>存取速度</li>\n<li>可靠性</li>\n<li>存取宽度</li>\n</ul>\n<h4 id=\"高速缓冲存储器Cache\"><a href=\"#高速缓冲存储器Cache\" class=\"headerlink\" title=\"高速缓冲存储器Cache\"></a>高速缓冲存储器Cache</h4><p>计算机系统整体性能的高低与许多因素有关，如CPU的主频、存储器的存取速度、系统架构、指令结构、信息在各部件之间的传送速度等。而CPU与主存之间的存取速度是一个很重要的因素。如果只是CPU工作速度很高，而主存的存取速度较低，就会造成CPU经常处于等待状态，既降低了处理速度，又浪费了CPU能力。为了减小CPU与主存之间的速度差异，现代微机中通常在慢速的DRAM和快速的CPU之间插入一个速度较快、容量较小的SRAM，起到缓冲作用，使CPU既能以较快速度存取SRAM中的数据，又不使系统成本上升过高，这就是Cache技术。</p>\n<p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/4.jpg\"></p>\n<p>由此可以想到，如果把一段时间内在一定地址范围中被频繁访问的信息集合成批地从主存读到一个能高速存取的小容量存储器中存放起来，供程序在这段时间内随时使用，从而尽量减少访问速度较慢的主存的次数，可以加快程序的运行速度，这就是Cache的设计思想，即在CPU和主存之间设置一个小容量的高速缓冲存储器（Cache）。  Cache中存放着最近要使用的程序与数据，作为主存中当前最急需执行信息的副本。其容量约为数KB到数百KB，由于容量较小，可以选用高速半导体存储器，使CPU访存速度得到提高。在高档微处理器中，在CPU芯片内集成了1～2个高速缓存，称为片内Cache，还允许在CPU芯片外扩充Cache。<br>有了Cache，系统在工作时总是不断地将与当前指令集相关联的一个不太大的后继指令集从主存读到Cache，然后再向CPU高速传送，从而达到速度匹配。当CPU需要访存时，同时将地址送往主存与Cache。若所需访问的内容已经在Cache中，则可直接从Cache中快速读取信息，这称为访问Cache命中；若访问的内容不在Cache中，即未命中，则从主存中读取信息，并考虑更新Cache，使其成为当前最急需部分。为此需要实现访存地址与Cache物理地址间的映像变换。<br>由于局部性原理不能保证所请求的数据百分之百地在Cache中，这里便存在一个命中率问题。所谓命中率，就是在CPU访问Cache时，所需信息恰好在Cache中的概率。命中率越高，正确获取数据的可能性就越大，目前Cache的访问命中率可达到90%以上。因此只要合理组织三级存储体系，从整体上讲，CPU就能以接近Cache的速度访问存储器，而总存储容量相当于联机外存的总容量。<br>一般来说，Cache的存储容量比主存的容量小得多，但不能太小，太小会使命中率太低。但也没有必要过大，过大不仅会增加成本，而且当Cache容量超过一定值后，命中率随容量的增加将不会有明显增长。所以Cache的空间与主存空间在一定范围内应保持适当比例的映射关系，以保证Cache有较高的命中率，且系统成本不会过多地增加。Cache的命中率与Cache的映像方式、替换算法、程序特性等因素有关。</p>\n<h4 id=\"存储系统的层次结构\"><a href=\"#存储系统的层次结构\" class=\"headerlink\" title=\"存储系统的层次结构\"></a>存储系统的层次结构</h4><p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/5.jpg\"></p>\n<p> 要真正解决存储器的容量、速度、价格之间的矛盾，不能只是将上面的各个层次的存储器进行简单组合，必须在系统结构上采取措施，采用不同速度、不同容量和不同价格的多种存储器件，按层次组成存储系统。各个层次的存储器之间通过硬件和软件有机地结合成一个统一的整体，无需程序员的干预而由计算机自动地实现调度，向程序员提供足够大的存储空间，同时最大限度地与CPU速度相匹配。按这样的思想组成的存储层次结构，称为存储体系结构。<br>典型的三级存储体系结构，分为“高速缓存—主存—辅存”三个层次。现在的计算机系统大多具备这三级存储结构。三级存储体系又分为两个层次，高速缓存和主存之间形成Cache-主存层次，主存和辅存之间形成主存-辅存层次。 </p>\n<p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/6.jpg\"></p>\n<ul>\n<li>Cache-主存层次　<br>通过辅助硬件将Cache和主存构成一个整体，如上图所示。从整体上看，该层次具有接近于Cache的存取速度、主存容量和平均位价格，解决了存储器高速与低成本之间的矛盾。这个层次完全由硬件实现，不受软件的干预，因此对所有程序员都是透明的。</li>\n<li>主存-辅存层次　<br>随着操作系统和硬件技术的发展，利用附加硬件及存储管理软件，使主存和辅存构成一个整体，形成主存-辅存层次，如图上图所示。辅存只与主存交换信息，不能直接由CPU访问。从整体上看，该层次的存取速度接近于主存的存取速度，容量则接近于辅存的容量，而位价格也接近于廉价的辅存平均价格，从而解决了大容量和低成本之间的矛盾。三级存储体系结构的总的效果是：存取速度接近于Cache，存储容量接近于辅存容量，整体价格也比较合理。</li>\n</ul>\n<h4 id=\"磁盘冗余阵列\"><a href=\"#磁盘冗余阵列\" class=\"headerlink\" title=\"磁盘冗余阵列\"></a>磁盘冗余阵列</h4><p>廉价冗余磁盘阵列（RedundantArraysofInexpensiveDisk，RAID）是用多台磁盘存储器组成的大容量外存子系统，它是由多台磁盘机按一定规则（如分条、分块、交叉存取等）组合在一起构成的。通过阵列控制器的控制和管理，磁盘阵列系统能够将几个、几十个甚至几百个硬盘组合起来，使其容量高达几百GB甚至上千GB。其基础是数据分块技术，即在多个磁盘上交错存放数据，通过阵列控制器实现数据的并行、交叉存储或单独存储操作。由于阵列中的一部分磁盘存有冗余信息，一旦系统中某一磁盘失效，可以利用冗余信息重建用户数据。</p>\n<ul>\n<li>RAID0级（无冗余和无校验的数据分块）<br>数据分布在阵列中的所有磁盘上，与单个大容量磁盘相比，它的显著优点是：如果两个I&#x2F;O请求正在等待不同的数据块，则被请求的块有可能在不同的盘上。因此，两个请求能够并行发出，减少了I&#x2F;O的排队时间。RAID0级具有最高的I&#x2F;O性能和磁盘空间利用率，但无容错能力，增加了系统出故障的几率。若阵列中有一块磁盘损坏，将造成不可弥补的损失。其安全性甚至低于常规的硬盘系统，所以不适于对数据稳定性要求高的应用。</li>\n<li>RAID1级（镜像磁盘阵列）<br>由磁盘对组成，每个工作盘都有对应的镜像盘，上面保存着与工作盘完全相同的数据。如果镜像盘组中一个物理磁盘出现故障，系统可以使用未受影响的另一个磁盘继续操作，数据不会丢失，但磁盘空间的利用率只有50%。RAID1级的安全性高，而主要缺点是价格昂贵，它需要支持2倍于逻辑磁盘的磁盘空间。因此，RAID1级的配置只限于存储系统软件、数据和其他关键文件的驱动器中。在这种情况下，RAID1级对所有的数据提供实时备份，在磁盘损坏时，所有的关键数据仍立即可用。</li>\n<li>RAID2级（具有纠错海明码的磁盘阵列）</li>\n<li>RAID3、4、5、6、7级</li>\n<li>RAID10级（RAID0级+RAID1级）<br>这是一种复合的RAID模式，将RAID0的速度与RAID1的冗余特性相结合，既可提供数据分块，又能提供镜像功能，是所有RAID中性能最好的磁盘阵列，但每次写入时要写两个互为镜像的盘，价格高。这种结构特别适用于既有大量数据需要存取，同时又对数据安全性要求严格的领域，如银行、金融、商业超市、仓储库房、各种档案管理等。</li>\n</ul>\n<h4 id=\"虚拟存储系统的组织\"><a href=\"#虚拟存储系统的组织\" class=\"headerlink\" title=\"虚拟存储系统的组织\"></a>虚拟存储系统的组织</h4><p>虚拟存储系统建立在主存-辅存层次上，是由附加硬件装置及存储管理软件组成的存储体系，它使计算机具有接近主存的存取速度，并具有辅存的容量和位成本。<br>在采用磁盘作为后援存储器后，可以在存储管理部件和操作系统存储管理软件的支持下，将主存和辅存的地址空间统一编址，使用户获得一个很大的编程空间，其容量大大超过实际的主存储器。这个在用户界面上看到的存储器，被称为虚拟存储器（VirtualMemory，VM），这样的虚拟存储技术对用户来说，自然是极有价值的，因而已在计算机系统中广泛使用，高档微处理器芯片也为此提供了有关硬件支撑。从用户界面看，用户可使用位数较长的编程地址进行编程，这种地址面向程序的需要，不必考虑程序将来在主存储器中的实际位置，因而称为逻辑地址。它是面向虚拟存储器的，所以又称为虚地址。在用户看来，CPU可按虚地址访问一个很大的存储器，其容量甚至可达整个辅存容量，显然这是一种虚拟层次。<br>在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前急需运行的部分调入主存，供CPU操作，其余暂不运行部分留在磁盘中，随程序执行的需要，操作系统自动地按一定替换算法进行调度，将当前暂不运行部分调回磁盘，将新的模块由磁盘调入主存。这一层次上的工作，对用户是透明的。CPU执行程序时，需将程序提供的虚地址变换为主存的实际地址（实地址、物理地址）。一般是先由存储管理部件判断该地址的内容是否在主存中，若已调入主存，则通过地址变换机制将虚地址转换为实地址，然后访问主存单元；若尚未调入主存，则通过缺页中断程序，以页为单位调入或实现主存内容调换。从原理上看，虚拟存储器与Cache-主存层次有很多相似之处，如地址映像方式和替换策略。但是，Cache-主存层次的控制完全由硬件实现，它对各类程序员都是透明的；而虚拟存储器的控制是由硬件与软件结合实现，对应用程序员来说是透明的，但对于设计存储器管理软件的系统程序员来说是不透明的。</p>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>无</p>\n","site":{"data":{}},"wordcount":13527,"excerpt":"","more":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《计算机组成原理与汇编语言程序设计（第4版）(高等学校规划教材)》 徐洁 电子工业出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><h2 id=\"硬件组成\"><a href=\"#硬件组成\" class=\"headerlink\" title=\"硬件组成\"></a>硬件组成</h2><p>在早期，冯·诺依曼将计算机的硬件组成分为5大部件。几十年来，计算机硬件系统已有了许多重大变化。首先，现在采用的大规模及超大规模集成电路，可将运算器和控制器集成在一块芯片上，合称为中央处理器（CPU）。它是负责执行程序，实现运算处理，控制整个系统的部件。相应地，原来的运算器现在作为CPU中的运算部件（又称为算术逻辑部件），它与控制器之间的界限已不像原来那样分明。其次，存储器分为高速缓存、主存储器、外存储器三个层次。其中高速缓存常集成在CPU内部，作为CPU的一个部分，也可以在CPU之外再设置一级高速缓存。通常将CPU与主存储器合在一起称为主机，主存储器（简称主存）就是因为位于主机之内而得名，有的书中又称它为内存储器（内存）。位于主机之外的磁盘、光盘、磁带等，则作为外存储器（外存）。还有，输入设备的任务是将外部信息输入主机，输出设备则是将主机的运算处理结果或其他信息从主机输出。但从信息传送控制的角度看，它们并无多大区别，不过是传送方向不同而已。有些设备还兼有输入与输出两种功能，所以在描述系统结构时常将它们合称为输入&#x2F;输出设备，简称I&#x2F;O设备。 </p>\n<p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/1.jpg\"></p>\n<h3 id=\"cpu\"><a href=\"#cpu\" class=\"headerlink\" title=\"cpu\"></a>cpu</h3><p>CPU（CentralProcessingUnit）即中央处理器，是硬件系统的核心部件，负责读取并执行指令，也就是执行程序。<br>在CPU中有一个程序计数器PC（ProgramCounter），它存放着当前指令所在存储单元的地址。如果程序是顺序执行，在读取一个或连续几个存储单元的指令代码后，PC的内容就加1或加几，以指出下一条指令的地址；如果程序需要转移，则将转移地址送入PC。因此，PC就像一个指针，指引着程序的执行顺序。虽然指令与数据都采用二进制代码表示，在外形上没有区别，但可按照PC中的中的地址信息去读取指令，再按照指令给出的操作数地址去读取数据。<br>CPU内有一个或多个算术逻辑部件ALU（ArithmeticLogicUnit）。通常按照指令的要求将有关数据送入ALU，进行指定的算术或逻辑运算，然后将运算结果送到主存单元，或暂存在CPU内的寄存器中。CPU内的主要部分是控制器（又称为控制部件），它的任务是控制整个系统的工作，决定在什么时候，根据什么，发出什么命令，做什么操作。例如它控制着从主存中读取指令，根据指令代码分时地发出一些最基本的控制信号即微命令，控制存储器的读写、ALU的运算处理、数据的输入&#x2F;输出等。按照产生微命令的方式不同，控制器可分为两大类：组合逻辑控制器及微程序控制器。<br>组合逻辑控制器完全靠若干组合逻辑电路（即硬件）产生微命令序列，将指令代码、状态信息、时序信号等输入到这些组合逻辑电路，电路将分时产生相应的微操作命令。这种控制器又称硬连逻辑控制器，其优点是形成微命令的速度快，常用于精简指令系统计算机（RISC）中。<br>微程序控制器是将微命令序列以代码形式编制成微程序，存入一个控制存储器中；当CPU执行指令时，通过读取并执行对应的一段微程序，产生微命令序列，控制完成指定的操作。微程序控制方式比较规整，硬件代价较小，易于扩充功能，但速度较慢。</p>\n<h3 id=\"主存储器\"><a href=\"#主存储器\" class=\"headerlink\" title=\"主存储器\"></a>主存储器</h3><p>我们总是希望计算机系统中的存储器容量大，存取速度快，但这往往是有矛盾的，所以常将存储器分为几级。其中主存储器用半导体存储器构成，工作速度较高，也有一定的存储容量。外存储器为主存提供后援，由磁盘、光盘、磁带等构成，其存储容量很大，但速度较主存储器低。高速缓冲存储器、主存储器和外存储器，组合成一个完整的多级存储系统，使得整个系统既有很大的存储容量，而CPU又可以高速地访问存储器。主存储器用来存放需要执行的程序及需要处理的数据，能由CPU直接读出或写入。<br>主存储器的一项重要特性是：能按地址（单元编号）存放或读取内容，也就是允许CPU直接编址访问，通常以字节为编址单位。对主存储器来说，寻找存储单元（寻址）的依据是地址码，所存取的内容是指令或数据。</p>\n<h3 id=\"外存储器\"><a href=\"#外存储器\" class=\"headerlink\" title=\"外存储器\"></a>外存储器</h3><p>外存储器用来存放那些需要联机存放，但暂不执行的程序和数据，当需要运行它们时再由外存调入主存。例如在光盘中存放着几个备用的软件，但当前暂时只用得着用得着其中的一个，我们先将它调入主存，其余软件仍存放在光盘上。又如一个信息管理系统所保存的数据很多，可将它们存放在磁盘之中，只将当前需要查询的部分调入主存，以后再调换。这样，主存的容量就不需要很大，可以做到速度比较快。而由磁盘、光盘等构成的外存储器容量很大，可为整个系统提供后援支持，其速度要求可以比主存低一些。<br>由于外存储器不由CPU直接编址访问，也就是说不需要按字节地从外存储器读取或写入，因此外存储器中的内容一般都按文件的形式进行组织，一个文件常分解为若干数据块，可以包含许多字节的信息。用户按文件名进行调用，CPU找到该文件在外存中的存放位置，以数据块为单位进行读写。</p>\n<h3 id=\"输入-x2F-输出设备\"><a href=\"#输入-x2F-输出设备\" class=\"headerlink\" title=\"输入&#x2F;输出设备\"></a>输入&#x2F;输出设备</h3><p>计算机系统大多配备了键盘、鼠标、显示器、打印机等常规输入&#x2F;输出设备，简称I&#x2F;O设备。</p>\n<h3 id=\"总线\"><a href=\"#总线\" class=\"headerlink\" title=\"总线\"></a>总线</h3><p>怎样将CPU、主存、多台I&#x2F;O设备连接成整机系统呢？现在普遍采用总线结构。所谓总线是指一组能为多个部件分时共享的信息传输线。</p>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>一台计算机系统需连接哪些I&#x2F;O设备，这要根据该系统的应用场合而定，因此通过系统总线连接的设备，其类型与数量都应当可以扩充。某种型号的计算机系统，其系统总线往往是标准的，也就是说，有多少根地址线、数据线，有哪些控制信号线，每个信号的名称及作用等，都是规定好的。</p>\n<p>概括地说，计算机硬件系统是由三大子系统：CPU、存储系统（包括高速缓存、主存和外存）、输入&#x2F;输出系统（包括输入&#x2F;输出设备和接口），以及连接它们的总线构成。</p>\n<h2 id=\"计算机软件系统\"><a href=\"#计算机软件系统\" class=\"headerlink\" title=\"计算机软件系统\"></a>计算机软件系统</h2><h3 id=\"系统软件\"><a href=\"#系统软件\" class=\"headerlink\" title=\"系统软件\"></a>系统软件</h3><ul>\n<li><p>操作系统</p>\n</li>\n<li><p>编译程序与解释程序</p>\n</li>\n</ul>\n<p>计算机硬件能够直接识别的是数字代码，所以让计算机硬件执行的基本命令，如传送、加、减等，必须用0、1这样的数字编码来表示。由硬件执行的程序的最终形态是由若干指令组成的序列，即指令是程序（可执行形态）的基本单位。一般地，一条指令规定了一种基本操作（如传送、加、减），并提供操作数地址或直接提供操作数，这些信息都由数字代码表示。一台计算机可以执行的各种指令的集合，称为这种计算机的指令系统。显然，不同的机型往往具有不同的指令系统，以及相应的指令格式约定，所以机器指令代码又称为机器语言，即面向特定机器结构的一种内部语言。<br>如果直接用机器语言（0、1代码）编制程序，将非常不便，于是人们想到用一些约定的符号，如英文缩写的字符串，去表示操作含义、操作数、地址等，这就产生了汇编语言。汇编语言是一种用符号表示的与机器指令基本对应的程序设计语言，它专属于某种机型或某种系列机，其他计算机不能直接使用，所以是一种面向机器结构的程序设计语言，不是通用语言。<br>为了便于编制程序，现在所使用的绝大多数编程语言是高级程序设计语言，这是一些面向用户，与特定机器属性相分离的语言。高级程序设计语言与机器指令之间没有直接的对应关系，所以它可以在各种机型中通用，编程者使用高级语言也不必了解具体的机器指令系统及其他硬件属性。高级程序设计语言需要遵循一定的严格语法规定与格式，才能为语言处理程序（编译、解释）所识别。<br>机器语言是机器内部使用的、用数字代码表示的指令代码，面向某一特定机型，可由硬件直接识别并执行。汇编语言是一种用符号表示的，面向某一特定机型的程序设计语言，它的指令语句与机器指令一一对应。高级程序设计语言则是面向用户，与特定机器属性相分离的程序设计语言，具有通用性。<br>大多数情况下，用户采用高级程序设计语言编写程序，个别情况采用汇编语言编写程序。用这些程序设计语言编写出的程序叫做源程序，它们由一些语句组成。将源程序输入计算机后，计算机先执行一种语言处理程序，将源程序转换为机器语言代码序列，即机器语言程序，然后由计算机硬件执行这些用机器语言代码表示的指令序列，从而完成用户程序的执行过程。这种语言处理程序也是一种必需的系统软件。<br>语言处理方式有两种类型：解释与编译。解释方式是边解释边执行，为此需要一种针对某种程序设计语言的解释程序（又称解释器）作为系统软件的组成部分之一。将源程序输入计算机后，启动并执行相应的解释程序，它的作用是逐步分析源程序中的语句，按照源程序描述的过程，执行一个与此等价的机器语言指令序列，直到整个源程序都被扫描一遍，并被解释执行完毕为止。这有点像口译外语的情形，边说边翻译。解释方式适用于比较简单的程序设计语言，如BASIC。它的优点是支持人机对话方式的程序设计，可以边执行边修改；所需要的主存空间较小。但是这种方式的执行速度较慢，不能解释那些前后关联较多、较难理解的程序设计语言。大多数程序设计语言采用编译方式。将源程序输入计算机后，先启动并执行相应的编译程序（又称编译器），将源程序全部翻译成目标程序（目标代码）的机器语言指令序列。执行时，计算机将直接执行目标程序，不再需要源程序与翻译程序。因此，这种编译方式有点像笔译，得到完整的译文后就可以不要原文与译者了。在编译过程中，它所需的主存空间比解释方式多些，既要容纳源程序又要容纳一个比较大的编译程序；需花费的时间也要长些。但运行用户程序时，所需的主存空间比较小，执行速度也较快。<br>将汇编语言源程序转换为机器代码的目标程序的过程也是一种编译，人们将它专门称为“汇编”，相应的翻译程序称为汇编程序（又称汇编器）。它的逆过程叫做“反汇编”，即将用机器代码表示的目标程序（指令序列）反汇编成用汇编语言描述的程序。为利于二次开发，在剖析一些已有的重要软件时，常常需要进行反汇编。</p>\n<ul>\n<li>各种软件平台</li>\n</ul>\n<h3 id=\"应用软件\"><a href=\"#应用软件\" class=\"headerlink\" title=\"应用软件\"></a>应用软件</h3><p>应用软件不胜枚举，它一般包括：①科学计算类；②数据处理类；③自动控制类；④计算机辅助设计类；⑤人工智能类；等等。</p>\n<h2 id=\"计算机系统层次\"><a href=\"#计算机系统层次\" class=\"headerlink\" title=\"计算机系统层次\"></a>计算机系统层次</h2><h3 id=\"从计算机系统组成角度划分层次结构\"><a href=\"#从计算机系统组成角度划分层次结构\" class=\"headerlink\" title=\"从计算机系统组成角度划分层次结构\"></a>从计算机系统组成角度划分层次结构</h3><p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/2.jpg\"></p>\n<ol>\n<li><p>微体系结构层<br>微体系结构层是具体存在的硬件层次，在这一层我们看到的不是由大部件（即CPU、存储系统、输入&#x2F;输出系统及互连机构）构成的计算机，而是更细微的机器结构。微体系结构层执行机器指令，它可看作是指令系统层指令的解释器。在由微程序控制数据通路的计算机上，微程序就是上一层指令的解释器。它通过数据通路逐条对指令进行取指、译码和执行。例如，对加法ADD指令，将首先取出指令进行译码分析，然后找到操作数送入寄存器，由ALU求和，最后存结果。结果到指定地方，如某个存储器单元。而在硬件直接控制数据通路的计算机上，执行的步骤与此类似，但是由硬件直接解释执行指令，并不存在一个真正的程序来解释上一层的指令。</p>\n</li>\n<li><p>指令系统层<br>原则上，指令系统层是机器语言程序员眼中所看到的计算机，当然现在人们并不使用机器语言编程。指令系统层位于微体系结构层之上，是一个抽象的层次，其主要特征就是指令系统。指令系统（又称指令集）是指一台计算机所能执行的全部指令的集合。其指令是由微体系结构层的微程序解释执行或硬件电路直接执行的。<br>指令系统是计算机软件与硬件之间的一种接口。硬件系统的基本任务是实现指令系统所规定的各种指令功能，而各种程序只有最终转化为用机器语言（即代码表示的指令序列）才能被硬件执行。尽管现在已广泛应用各种高级语言编程，但需通过编译器或解释器将高级语言程序转换为硬件可以识别与执行的机器指令序列。<br>指令系统层定义了硬件和编译器之间的接口，它是一种硬件和编译器都能理解的语言。一方面，指令系统表明了一台计算机具有哪些硬件功能，是硬件逻辑设计的基础。因此，在指令系统层，应该定义一套在当前和将来的技术条件下能够高效率实现的指令集，从而使高效率的设计可用于今后的若干代计算机中。另一方面，指令系统层应该为编译器提供明确的编译目标，使编译结果具有规律性和完整性。</p>\n</li>\n<li><p>操作系统层<br>从程序员的观点来看，操作系统是一个在指令系统层提供的指令和特性之上又增加了新指令和特性的程序。这一层有新的指令集，有不同的存储器结构，有同时运行两个或多个程序的能力，以及其他一些特性。<br>尽管操作系统层和指令系统层都是抽象层次，但它们之间具有重要的区别。操作系统层指令集是系统程序员完全可用的指令集。它包括几乎所有的指令系统层的指令和操作系统层增加的新指令。这些新指令称为系统调用（SystemCall），如DOS操作系统的系统功能调用“INT21H”用于设备、文件和目录等管理，Linux操作系统的系统调用“fork()”用来创建一个进程。一个系统调用使用一条新指令调用一个预先定义好的操作系统服务，这样效率很高。一个典型的系统调用是从一个文件中读取数据。这一层增加的系统调用是由运行在指令系统层上的操作系统解释执行的。当一个用户程序执行一个系统调用时，比如从一个文件中读取数据，操作系统将一步步地执行这个调用。但是，那些和第2层指令相同的本层指令将直接交给微体系结构层执行，而不是由操作系统执行。换句话说，本层的新增指令由操作系统解释，而其他指令由微体系结构层直接执行，因此又将本层称为“混合层”。<br>这一层并不是为普通程序员的使用而设计的，主要是为支持高层所需的解释器或翻译器运行而设计的。</p>\n</li>\n<li><p>汇编语言层<br>微体系结构层可看作指令系统层指令的解释器，使指令系统的功能得以实现。但是，直接用机器指令代码编程是非常困难的，而让微体系结构层直接执行高级语言也不是好办法。因此，人们为所有的计算机都设计了一个汇编语言层，它位于指令系统层、操作系统层与面向问题语言层之间。从这一层看去，每一种计算机都有一套自己的汇编语言、解释它的汇编器，以及相应的程序设计与开发方法。汇编语言层以及上层是提供给解决应用问题的应用程序员使用的。第1、2、3层提供的机器语言都是二进制代码，适合机器执行，但不容易被人理解。从第4层开始，其提供的语言是人们能理解的单词和缩略语。汇编语言实际就是“符号化”的机器语言，每一条汇编指令语句都对应一条机器语言指令，它是它是面向机器结构的语言。用汇编语言编写的程序先由汇编器翻译成机器语言程序，然后由微体系结构层解释执行。这一层支持上层的方法与低层不同。第2层和第3层主要用的是解释；而第4层和第5层通常用的是编译。</p>\n</li>\n<li><p>面向问题语言层<br>BASIC、C、C++、Java、LISP等</p>\n</li>\n</ol>\n<h3 id=\"从语言功能角度划分层次结构\"><a href=\"#从语言功能角度划分层次结构\" class=\"headerlink\" title=\"从语言功能角度划分层次结构\"></a>从语言功能角度划分层次结构</h3><p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/3.jpg\"></p>\n<p>如果将计算机功能描述为“能执行用某些程序设计语言编写的程序”，那么用户看到的就是上图的语言功能层次模型。计算机硬件的物理功能是执行机器语言，称为机器语言物理机，从这一级看到的是一台实际的机器。而用户看到的是能执行某种语言程序的虚拟机，即通过配置某种语言处理程序后所形成的一台计算机。<br>与机器语言最接近的是汇编语言，它的基本成分是与指令系统一一对应的用助记符描述的汇编语句。与算法、数学模型甚至自然语言接近的，称为高级语言，它具有较强的通用性，在这一范畴内已推出了多种通用的高级程序设计语言。针对某些特定应用领域与用户，也可使用某种专用语言，它们一般面向应用，如所要求解的问题。<br>大多数计算机都是先将用程序设计语言编写的程序翻译为机器语言，然后才能执行。一般是直接翻译为机器语言。但当高级语言较复杂时，也可能分级编译，即先翻译为层次低些的某种中间语言，再将中间语言进一步翻译为机器语言，如上图虚线所示。<br>所谓虚拟机，通常是指通过配置软件（如某种语言的编译器或解释器）扩充机器功能后所形成的一台计算机。实际硬件在物理功能级上并不具备这种机器功能，因而称为虚拟机。采用虚拟机概念是计算机设计中的又一重要策略，它将提供给用户的功能抽象出来，使其脱离具体的物理机器，这有利于让用户摆脱真实物理机细节的束缚，获得超越物理机的功能。<br>广泛使用的Java虚拟机（JavaVirtualMachine，JVM）的概念。为了使Java程序能在不同的计算机上运行，Sun公司定义了一种称为Java虚拟机的虚拟体系结构。它有32位字组成的内存，能执行226条指令。大多数指令都很简单，只有一些比较复杂，需要多次内存循环。</p>\n<h3 id=\"软硬件逻辑上等价\"><a href=\"#软硬件逻辑上等价\" class=\"headerlink\" title=\"软硬件逻辑上等价\"></a>软硬件逻辑上等价</h3><p>如果说系统设计者必须关心软、硬件之间的界面，即哪些功能由硬件实现，哪些由软件实现；用户则更关心系统究竟能提供哪些功能。至于这些功能是由硬件还是软件实现，在逻辑功能上则是等价的，只是执行速度有差别而已。</p>\n<h3 id=\"计算机的性能指标\"><a href=\"#计算机的性能指标\" class=\"headerlink\" title=\"计算机的性能指标\"></a>计算机的性能指标</h3><ul>\n<li><p>基本字长</p>\n</li>\n<li><p>数据通路宽度</p>\n</li>\n<li><p>运算速度</p>\n</li>\n<li><p>主存储器容量</p>\n</li>\n<li><p>外存容量</p>\n</li>\n<li><p>配置的外围设备及其性能</p>\n</li>\n<li><p>系统软件配置</p>\n</li>\n</ul>\n<h3 id=\"提高计算机性能的若干技术\"><a href=\"#提高计算机性能的若干技术\" class=\"headerlink\" title=\"提高计算机性能的若干技术\"></a>提高计算机性能的若干技术</h3><ul>\n<li><p>提高单CPU性能的若干技术<br>（1）流水线处理技术<br>（2）RISC（精简指令系统计算机）技术<br>（3）超标量技术<br>（4）平衡不同子系统的数据吞吐率</p>\n</li>\n<li><p>并行计算机</p>\n</li>\n</ul>\n<h3 id=\"精简指令集计算机（RISC）\"><a href=\"#精简指令集计算机（RISC）\" class=\"headerlink\" title=\"精简指令集计算机（RISC）\"></a>精简指令集计算机（RISC）</h3><ul>\n<li>概念</li>\n</ul>\n<p>随着超大规模集成电路VLSI技术的迅速发展，计算机系统的硬件成本不断下降，而软件成本却在不断上升。因此，人们热衷于在指令系统中增加更多的指令和更复杂的指令，以适应不同应用领域的需要，并考虑尽量缩短指令系统与高级语言之间的语义差异，以便于实现高级语言的编译和降低软件成本。另外，为了维护系列机的软件兼容性，也使指令系统变得越来越庞大。在系列机中，为了使老用户在软件上的投资不受损失，新机型必须继承老机器指令系统中的全部指令，这种情况使同一系列计算机的指令系统越来越复杂。一般来说，人们在计算机设计方面的传统想法和做法是：字长愈长、性能愈高的计算机，其指令系统就应该愈复杂，按这种传统方法设计的计算机系统称为复杂指令系统计算机，简称CISC。指令系统很复杂、功能很强并不一定能提高机器的速度，CISC中采用很多复杂的寻址方式，为了计算有效地址需花费一定的时间；有的指令需要多次访问主存储器，所以执行速度会降低。</p>\n<p>复杂指令系统的实现需要复杂的控制器来支持，并且系列机为实现兼容，其控制部件多用微程序控制方式来实现，以便于指令系统的扩展。但微程序控制部件执行一条机器指令通常需要几个微周期，因此严重降低了指令的执行速度。为了提高指令的执行速度，CISC中常采用流水线技术。但由于存在很多问题，例如指令系统采用变字长指令、不同指令争用共同资源以及转移指令等，使流水线的效率不高。以上情况表明，传统的CISC设计思想并不利于提高计算机的速度。而且复杂的指令系统必然增加硬件实现的复杂性，从而使计算机的研制周期长、投资大。因此人们开始研究指令系统的合理性问题。对CISC指令系统运行的统计分析表明，各种指令的使用频率相差悬殊，最常用的是一些比较简单的指令，仅占指令总数的20%，但在程序中出现的频率却占80%。1975年，IBM公司提出了精简指令系统的想法。后来美国加利福尼亚大学伯克利分校的RISCI和RISCII、斯坦福大学的MIPS机的研制成功，为精简指令系统计算机（简称RISC）的诞生与发展起了很大作用。</p>\n<ul>\n<li>RISC的特点</li>\n</ul>\n<p>精简指令系统计算机的着眼点不是简单地放在简化指令系统上，而是通过简化指令使计算机的结构更加简单合理，更易于流水线的实现，从而提高处理速度。<br>  （1）面向寄存器的结构所有运算使用的数据都来自寄存器，运算结果也都写入寄存器。寄存器的典型长度是32位或64位。通常CPU内应设置大量的通用寄存器，以减少访问主存储器。<br>  （2）采用LOAD&#x2F;STORE结构<br>  （3）较少的指令数和寻址方式<br>  选取使用频率最高的一些简单指令，以及很有用但不复杂的指令，可简化控制部件。选用简单的寻址方式，有利于减少指令的执行周期数。<br>  （4）所有指令长度相同<br>  （5）硬布线控制逻辑<br>  （6）注重编译的优化<br>  RISC指令系统的简化，必然使编译生成的代码长度增长。但通过编译优化技术，将编译初步生成的代码重新组织，调度指令的执行次序，以充分发挥内部操作的并行性，从而进一步提高流水线的执行效率。虽然编译优化技术使编译时间拉长，但这种代价的结果是使程序的执行时间缩短。而且程序的编译工作只需一次，编译后生成的优化执行代码却可以高效率地执行多次。因此这个代价是值得的。</p>\n<h3 id=\"存储系统\"><a href=\"#存储系统\" class=\"headerlink\" title=\"存储系统\"></a>存储系统</h3><p>在物理构成上，存储系统通常分为3层：高速缓冲存储器Cache、主存和外存。Cache与主存常由半导体存储器构成；外存常由磁盘及光盘构成，也可以看作是I&#x2F;O设备。一个高性能的计算机系统要求存储器的存储容量大，存取速度快，成本低廉，能支持复杂系统结构。这些要求往往相互矛盾，彼此形成制约。因此在一个计算机系统中，常采用几种不同的存储器，构成多级存储体系，以适应不同层次的需要。通常，对CPU直接访问的一级，其速度尽可能快些，而容量相对有限；作为后援的一级其容量尽可能大些，而速度可以相对慢些。经过合理的搭配和组织，对用户来说，整个存储系统能够提供足够大的存储容量和较快的存取速度。<br>从用户的角度看，存储器还可以形成另一种层次结构，即物理存储器与虚拟存储器。物理存储器是指系统的物理组成中实际存在的主存，主存容量决定了实存空间的大小。在高档计算机中，依靠操作系统的软件支持及部分硬件的支持，可以使用户访问的编程空间远比实际主存空间大，用户感觉自己可编程访问一个很大的存储器，这个存储器称为虚拟存储器。</p>\n<h4 id=\"存储器的分类\"><a href=\"#存储器的分类\" class=\"headerlink\" title=\"存储器的分类\"></a>存储器的分类</h4><ul>\n<li><p>按存储器在计算机系统中的作用分类<br>（1）内部存储器内部存储器（简称内存或主存）是计算机主机的组成部分，用来存储当前运行所需要的程序和数据，CPU可以直接访问内存并与其交换信息。相对外部存储器而言，内存的容量小、存取速度快。由于CPU要频繁地访问内存，所以内存的性能在很大程度上影响了整个计算机系统的性能。<br>（2）外部存储器外部存储器也称辅助存储器或后援存储器，简称外存或辅存。外存用于存放当前不参加运行的程序和数据，以及一些需要永久保存的信息。外存设在设在主机外部，其容量大，但存取速度相对较慢，CPU不能直接访问它，而必须通过专门的设备才能对它进行读写（如磁盘驱动器等），这是它与内存之间的一个本质区别。<br>（3）高速缓冲存储器高速缓冲存储器（Cache）位于主存和CPU之间，用来存放正在执行的程序和数据，以便CPU能高速地访问它们。Cache的存取速度可以与CPU的速度相匹配，但其价格昂贵，存储容量较小。目前的微处理器通常将Cache或Cache的一部分制作在CPU芯片中。</p>\n</li>\n<li><p>按存取方式分类<br>（1）随机存取存储器RAM（RandomAccessMemory）随机存取存储器是可读可写的存储器，CPU可以对RAM单元的内容随机地读&#x2F;写访问，对任一单元的读出和写入的时间是一样的，即存取时间相同，并且与存储单元在存储器中所处的位置无关。RAM读&#x2F;写方便，使用灵活，但断电后信息会丢失。RAM主要用作主存，也可用作高速缓存。<br>（2）只读存储器ROM（ReadOnlyMemory）只读存储器可以看作RAM的一种特殊形式，其特点是：存储器的内容只能随机读出而不能写入。这类存储器用来存放那些不需要改变的信息。由于信息一旦写入存储器就固定不变了，即使断电信息也不会丢失，所以又称它为固定存储器。ROM除了存放某些系统程序外，还用来存放专门的子程序，或用作函数发生器、字符发生器及微程序控制器中的控制存储器。有些ROM在特定条件下用特殊的装置或程序可以重新写入。<br>（3）顺序存取存储器SAM（SequentialAccessMemory）顺序存取存储器的存取方式与前两种完全不同，它的内容只能按某种顺序存取，存取时间的长短与信息在存储器上的物理位置有关，所以SAM只能用平均存取时间作为衡量存取速度的指标。磁带机就是典型的顺序存取存储器。<br>（4）直接存取存储器DAM（DirectAccessMemory）直接存取存储器既不像RAM那样能随机地访问存储器<br>存储器的任何一个存储单元，也不像SAM那样完全按顺序存取，而是介于两者之间。存取信息时，第1步直接指向存储器的某个小区域（如磁盘上的磁道）；第2步在小区域内顺序检索或等待，直到找到目的地后再进行读&#x2F;写操作。这种存储器的存取时间也与信息所在的物理位置有关，但比SAM的存取时间要短。磁盘是最常见的直接存取存储器。</p>\n</li>\n<li><p>按存储介质分类<br>（1）磁芯存储器<br>（2）半导体存储器<br>（3）磁表面存储器<br>（4）光盘存储器</p>\n</li>\n<li><p>按信息的可保存性分类<br>断电后存储信息即消失的存储器，称为易失性存储器或挥发性存储器，RAM是易失性存储器。断电后信息仍然保存的存储器，称为非易失性存储器，也称为非挥发性存储器或永久性存储器，ROM、磁芯存储器、磁表面存储器和光盘存储器都是非易失性存储器。</p>\n</li>\n</ul>\n<h4 id=\"主存的主要技术指标\"><a href=\"#主存的主要技术指标\" class=\"headerlink\" title=\"主存的主要技术指标\"></a>主存的主要技术指标</h4><ul>\n<li>存储容量</li>\n<li>存取速度</li>\n<li>可靠性</li>\n<li>存取宽度</li>\n</ul>\n<h4 id=\"高速缓冲存储器Cache\"><a href=\"#高速缓冲存储器Cache\" class=\"headerlink\" title=\"高速缓冲存储器Cache\"></a>高速缓冲存储器Cache</h4><p>计算机系统整体性能的高低与许多因素有关，如CPU的主频、存储器的存取速度、系统架构、指令结构、信息在各部件之间的传送速度等。而CPU与主存之间的存取速度是一个很重要的因素。如果只是CPU工作速度很高，而主存的存取速度较低，就会造成CPU经常处于等待状态，既降低了处理速度，又浪费了CPU能力。为了减小CPU与主存之间的速度差异，现代微机中通常在慢速的DRAM和快速的CPU之间插入一个速度较快、容量较小的SRAM，起到缓冲作用，使CPU既能以较快速度存取SRAM中的数据，又不使系统成本上升过高，这就是Cache技术。</p>\n<p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/4.jpg\"></p>\n<p>由此可以想到，如果把一段时间内在一定地址范围中被频繁访问的信息集合成批地从主存读到一个能高速存取的小容量存储器中存放起来，供程序在这段时间内随时使用，从而尽量减少访问速度较慢的主存的次数，可以加快程序的运行速度，这就是Cache的设计思想，即在CPU和主存之间设置一个小容量的高速缓冲存储器（Cache）。  Cache中存放着最近要使用的程序与数据，作为主存中当前最急需执行信息的副本。其容量约为数KB到数百KB，由于容量较小，可以选用高速半导体存储器，使CPU访存速度得到提高。在高档微处理器中，在CPU芯片内集成了1～2个高速缓存，称为片内Cache，还允许在CPU芯片外扩充Cache。<br>有了Cache，系统在工作时总是不断地将与当前指令集相关联的一个不太大的后继指令集从主存读到Cache，然后再向CPU高速传送，从而达到速度匹配。当CPU需要访存时，同时将地址送往主存与Cache。若所需访问的内容已经在Cache中，则可直接从Cache中快速读取信息，这称为访问Cache命中；若访问的内容不在Cache中，即未命中，则从主存中读取信息，并考虑更新Cache，使其成为当前最急需部分。为此需要实现访存地址与Cache物理地址间的映像变换。<br>由于局部性原理不能保证所请求的数据百分之百地在Cache中，这里便存在一个命中率问题。所谓命中率，就是在CPU访问Cache时，所需信息恰好在Cache中的概率。命中率越高，正确获取数据的可能性就越大，目前Cache的访问命中率可达到90%以上。因此只要合理组织三级存储体系，从整体上讲，CPU就能以接近Cache的速度访问存储器，而总存储容量相当于联机外存的总容量。<br>一般来说，Cache的存储容量比主存的容量小得多，但不能太小，太小会使命中率太低。但也没有必要过大，过大不仅会增加成本，而且当Cache容量超过一定值后，命中率随容量的增加将不会有明显增长。所以Cache的空间与主存空间在一定范围内应保持适当比例的映射关系，以保证Cache有较高的命中率，且系统成本不会过多地增加。Cache的命中率与Cache的映像方式、替换算法、程序特性等因素有关。</p>\n<h4 id=\"存储系统的层次结构\"><a href=\"#存储系统的层次结构\" class=\"headerlink\" title=\"存储系统的层次结构\"></a>存储系统的层次结构</h4><p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/5.jpg\"></p>\n<p> 要真正解决存储器的容量、速度、价格之间的矛盾，不能只是将上面的各个层次的存储器进行简单组合，必须在系统结构上采取措施，采用不同速度、不同容量和不同价格的多种存储器件，按层次组成存储系统。各个层次的存储器之间通过硬件和软件有机地结合成一个统一的整体，无需程序员的干预而由计算机自动地实现调度，向程序员提供足够大的存储空间，同时最大限度地与CPU速度相匹配。按这样的思想组成的存储层次结构，称为存储体系结构。<br>典型的三级存储体系结构，分为“高速缓存—主存—辅存”三个层次。现在的计算机系统大多具备这三级存储结构。三级存储体系又分为两个层次，高速缓存和主存之间形成Cache-主存层次，主存和辅存之间形成主存-辅存层次。 </p>\n<p><img src=\"/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/6.jpg\"></p>\n<ul>\n<li>Cache-主存层次　<br>通过辅助硬件将Cache和主存构成一个整体，如上图所示。从整体上看，该层次具有接近于Cache的存取速度、主存容量和平均位价格，解决了存储器高速与低成本之间的矛盾。这个层次完全由硬件实现，不受软件的干预，因此对所有程序员都是透明的。</li>\n<li>主存-辅存层次　<br>随着操作系统和硬件技术的发展，利用附加硬件及存储管理软件，使主存和辅存构成一个整体，形成主存-辅存层次，如图上图所示。辅存只与主存交换信息，不能直接由CPU访问。从整体上看，该层次的存取速度接近于主存的存取速度，容量则接近于辅存的容量，而位价格也接近于廉价的辅存平均价格，从而解决了大容量和低成本之间的矛盾。三级存储体系结构的总的效果是：存取速度接近于Cache，存储容量接近于辅存容量，整体价格也比较合理。</li>\n</ul>\n<h4 id=\"磁盘冗余阵列\"><a href=\"#磁盘冗余阵列\" class=\"headerlink\" title=\"磁盘冗余阵列\"></a>磁盘冗余阵列</h4><p>廉价冗余磁盘阵列（RedundantArraysofInexpensiveDisk，RAID）是用多台磁盘存储器组成的大容量外存子系统，它是由多台磁盘机按一定规则（如分条、分块、交叉存取等）组合在一起构成的。通过阵列控制器的控制和管理，磁盘阵列系统能够将几个、几十个甚至几百个硬盘组合起来，使其容量高达几百GB甚至上千GB。其基础是数据分块技术，即在多个磁盘上交错存放数据，通过阵列控制器实现数据的并行、交叉存储或单独存储操作。由于阵列中的一部分磁盘存有冗余信息，一旦系统中某一磁盘失效，可以利用冗余信息重建用户数据。</p>\n<ul>\n<li>RAID0级（无冗余和无校验的数据分块）<br>数据分布在阵列中的所有磁盘上，与单个大容量磁盘相比，它的显著优点是：如果两个I&#x2F;O请求正在等待不同的数据块，则被请求的块有可能在不同的盘上。因此，两个请求能够并行发出，减少了I&#x2F;O的排队时间。RAID0级具有最高的I&#x2F;O性能和磁盘空间利用率，但无容错能力，增加了系统出故障的几率。若阵列中有一块磁盘损坏，将造成不可弥补的损失。其安全性甚至低于常规的硬盘系统，所以不适于对数据稳定性要求高的应用。</li>\n<li>RAID1级（镜像磁盘阵列）<br>由磁盘对组成，每个工作盘都有对应的镜像盘，上面保存着与工作盘完全相同的数据。如果镜像盘组中一个物理磁盘出现故障，系统可以使用未受影响的另一个磁盘继续操作，数据不会丢失，但磁盘空间的利用率只有50%。RAID1级的安全性高，而主要缺点是价格昂贵，它需要支持2倍于逻辑磁盘的磁盘空间。因此，RAID1级的配置只限于存储系统软件、数据和其他关键文件的驱动器中。在这种情况下，RAID1级对所有的数据提供实时备份，在磁盘损坏时，所有的关键数据仍立即可用。</li>\n<li>RAID2级（具有纠错海明码的磁盘阵列）</li>\n<li>RAID3、4、5、6、7级</li>\n<li>RAID10级（RAID0级+RAID1级）<br>这是一种复合的RAID模式，将RAID0的速度与RAID1的冗余特性相结合，既可提供数据分块，又能提供镜像功能，是所有RAID中性能最好的磁盘阵列，但每次写入时要写两个互为镜像的盘，价格高。这种结构特别适用于既有大量数据需要存取，同时又对数据安全性要求严格的领域，如银行、金融、商业超市、仓储库房、各种档案管理等。</li>\n</ul>\n<h4 id=\"虚拟存储系统的组织\"><a href=\"#虚拟存储系统的组织\" class=\"headerlink\" title=\"虚拟存储系统的组织\"></a>虚拟存储系统的组织</h4><p>虚拟存储系统建立在主存-辅存层次上，是由附加硬件装置及存储管理软件组成的存储体系，它使计算机具有接近主存的存取速度，并具有辅存的容量和位成本。<br>在采用磁盘作为后援存储器后，可以在存储管理部件和操作系统存储管理软件的支持下，将主存和辅存的地址空间统一编址，使用户获得一个很大的编程空间，其容量大大超过实际的主存储器。这个在用户界面上看到的存储器，被称为虚拟存储器（VirtualMemory，VM），这样的虚拟存储技术对用户来说，自然是极有价值的，因而已在计算机系统中广泛使用，高档微处理器芯片也为此提供了有关硬件支撑。从用户界面看，用户可使用位数较长的编程地址进行编程，这种地址面向程序的需要，不必考虑程序将来在主存储器中的实际位置，因而称为逻辑地址。它是面向虚拟存储器的，所以又称为虚地址。在用户看来，CPU可按虚地址访问一个很大的存储器，其容量甚至可达整个辅存容量，显然这是一种虚拟层次。<br>在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前急需运行的部分调入主存，供CPU操作，其余暂不运行部分留在磁盘中，随程序执行的需要，操作系统自动地按一定替换算法进行调度，将当前暂不运行部分调回磁盘，将新的模块由磁盘调入主存。这一层次上的工作，对用户是透明的。CPU执行程序时，需将程序提供的虚地址变换为主存的实际地址（实地址、物理地址）。一般是先由存储管理部件判断该地址的内容是否在主存中，若已调入主存，则通过地址变换机制将虚地址转换为实地址，然后访问主存单元；若尚未调入主存，则通过缺页中断程序，以页为单位调入或实现主存内容调换。从原理上看，虚拟存储器与Cache-主存层次有很多相似之处，如地址映像方式和替换策略。但是，Cache-主存层次的控制完全由硬件实现，它对各类程序员都是透明的；而虚拟存储器的控制是由硬件与软件结合实现，对应用程序员来说是透明的，但对于设计存储器管理软件的系统程序员来说是不透明的。</p>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>无</p>\n"},{"title":"操作系统原理","date":"2022-11-01T15:23:43.000Z","_content":"\n# 信息\n\n《操作系统原理(第4版)》 庞丽萍 华中科技大学出版社\n\n# 摘录\n\n## 绪论\n\n### 存储程序式计算机\n\n- 冯·诺依曼计算机体系结构\n  ![](./操作系统原理/1.jpg)\n  从20世纪40年代至今，计算机体系结构不断地发展变化，但冯·诺依曼计算机体系结构定义的一个存储程序式计算机的家族，几乎是当代所有计算机系统的构成基础（除专门设计用于处理特殊任务的计算机外）。存储程序式计算机由中央处理器（处理器（CPU））、存储器和输入／输出设备组成。所有的单元都通过总线连接，总线分为地址总线和数据总线，分别连接不同的部件。\n  由于冯·诺依曼型计算机的计算模型是顺序过程计算模型，所以它的特点是集中顺序过程，在当代的CPU中，可有32～64个通用寄存器，每个寄存器能够保存一个32位（bit）的数值。通用寄存器可以为功能单元提供操作数，并能接收、保存操作的结果。控制单元负责从主存储器提取指令、分析其类型，并产生信号通知计算机其他部分执行指令所指定的操作。控制单元包含一个程序计数器（programcounter，PC）和一个指令寄存器（instructionregister，IR）。程序计数器指示下一步应该执行的指令，而指令寄存器包含当前指令的拷贝。\n\n### 操作系统的发展历程\n\n操作系统是构成计算机系统的另一个重要的系统软件，它负责管理计算机系统的硬件、软件资源并控制整个计算机的工作流程。\n\n- 发展历程\n  从1950年至今，操作系统的发展主要经历了如下的几个阶段：①手工操作阶段——无操作系统；②批处理系统——早期批处理、执行系统；③操作系统形成——批处理操作系统、分时操作系统、实时操作系统；④现代操作系统——个人计算机操作系统、网络操作系统、分布式操作系统。\n\n- 中断和通道\n  20世纪60年代初期，硬件获得了两方面的进展：一是通道的引入；二是中断技术的出现。这两项重大成果导致操作系统进入执行系统阶段。通道是一种专用处理部件，它能控制一台或多台外设的工作，负责外部设备与主存之间的信息传输。它一旦被启动，就能独立于CPU运行，这样就可使CPU和通道并行操作，而且CPU和各种外部设备也能并行操作。所谓中断是指当主机接到某种信号信号（如I/O设备完成信号）时，马上停止原来的工作，转去处理这一事件，当事件处理完毕，主机又回到原来的工作点继续工作。\n\n- 多道程序\n  中断和通道技术出现以后，I/O设备和中央处理机可以并行操作，初步解决了高速处理机和低速外部设备的矛盾，提高了计算机的工作效率。但不久又发现，这种并行是有限度的，并不能完全消除中央处理机对外部传输的等待。比如，一个作业在运行过程中依此输入n批数据，每批输入1000个字符，输入机每输入1000个字符需用1000ms，而处理机处理这些数据则需300ms。可见，尽管处理机具有和外部设备并行工作的能力，但是在这种情况下无法让它多做工作，处理机仍有空闲等待现象。那么，为了提高设备的利用率，能否在系统内同时存放几道程序呢？这就引入了多道程序的概念。\n  多道程序运行的特征是：①多道——计算机主存中同时存放几道相互独立的程序；②宏观上并行——同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕；③微观上串行——从微观上看，主存中的多道程序轮流或分时地占有处理机，交替执行。\n\n- 分时技术\n  当计算机技术和软件技术发展到20世纪60年代中期，由于主机速度不断提高而采用了分时技术，使一台计算机可同时为多个终端用户服务。每个终端用户在自己的终端设备上联机使用计算机，好像自己独占机器一样。\n\n### 操作系统的基本概念\n\n- 计算机系统的组成\n  ![](./操作系统原理/2.jpg)\n  操作系统是一个大型的程序系统，它负责计算机系统软、硬件资源的分配和管理；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境。\n  操作系统是重要的系统软件，只有配置了操作系统这一系统软件后，才使计算机系统体现出系统的完整性和可利用性。当用户要计算机帮助完成其计算任务时，用户仅编制源程序（用户在源程序中，可以利用操作系统提供的系统调用请求操作系统相应的服务），而其余的大量工作，如作业控制、系统资源的合理分配和利用，各种调度策略的制订、人机联系方式等都是由操作系统实施的。所以，操作系统使整个计算机系统实现了高度自动化、高效率、高利用率、高可靠性。操作系统是整个计算机系统的核心。\n\n- 操作系统的资源管理功能\n  操作系统的主要功能是管理系统的软、硬件资源。这些资源按其性质来分，可以归纳为四类：处理机、存储器、外部设备和软件资源。这四类资源就构成了系统程序和用户程序赖以活动的物质基础和工作环境。针对这四类资源，操作系统就有相应的资源管理程序：处理机管理、存储管理、设备管理和软件资源管理程序。这些资源管理程序组成了操作系统这一程序系统。\n\n- 操作系统的基本类型\n  （1）批量操作系统；（2）分时操作系统；（3）实时操作系统；（4）个人计算机操作系统；（5）网络操作系统；（6）分布式操作系统。\n\n## 操作系统的组织结构\n\n### 操作系统虚拟机\n\n在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。扩充后的虚拟机不仅可以使用原来裸机提供的各种基本硬件指令，而且还可使用操作系统中所增加的许多其他“指令”。这些指令统称为扩充机器的指令系统，又称为操作命令语言。\n  ![](./操作系统原理/3.jpg)\n操作系统虚拟机提供了协助用户解决问题的装置，其功能是通过它提供的命令来体现的，用户也是通过这一组命令和操作系统虚拟机打交道的。系统所提供的全部操作命令的集合称为操作命令语言，它是用户和系统进行通信的手段和界面。这一用户界面分为两个方面：操作命令（又称命令接口）和系统功能调用（又称程序接口）。\n操作系统在计算机系统中所处的位置是硬件层（裸机）和其他所有软件之间，是所有软件中与硬件相连的第一层软件，它在裸机上运行，又是系统\n软件和应用程序运行的基础。它与硬件、应用程序和用户都有接口。具有一体化结构的操作系统提供的接口如下图所示，从该结构中可以看出操作系统提供的多种接口。\n  ![loading-ag-517](./操作系统原理/4.jpg)\n\n### 处理机的状态\n\n操作系统是计算机系统中最重要的系统软件，为了能正确地进行管理和控制，其本身是不能被破坏的。为此，系统应能建立一个保护环境，采用的办法是区分处理机的工作状态。因为，在系统中有两类程序在运行，一类是管理程序（如处理机调度程序、主存分配程序、I/O管理程序等）；另一类是用户程序。这两类程序是不同的，前者是管理和控制者，它负责管理和分配系统资源，为用户提供服务。而用户程序运行时，所需资源必须向操作系统提出请求，自己不能随意取用系统资源，如直接启动外部设备进行工作，更不能改变机器状态等。这两类不同程序执行时应有不同的权限，为此根据对资源和机器指令的使用权限，将处理执行时的工作状态区分为不同的状态（或称为模式）。所谓处理机的态，就是处理机当前处于何种状态，正在执行哪类程序。为了保护操作系统，至少需要区分两种状态：管态和用户态。管态（supervisormode）：又称为系统态，是操作系统的管理程序执行时机器所处的状态。在此状态下允许中央处理机使用全部系统资源和全部指令，其中包括一组特权指令（例如，涉及外部设备的输入／输出指令、改变机器状态或修改存储保护的某些指令），允许访问整个存储区。用户态（usermode）：又称为目态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用系统资源与改变机器状态，并且只允许用户程序访问自己的存储区域。有的系统将管理程序执行时的机器状态进一步分为核态和管态，这时，管态的权限有所变化，管态只允许使用一些在用户态下所不能使用的资源，但不能使用修改机器的状态指令。而核态（kernelmode）就具有上述管态所具有的所有权限。无核态的系统，管态执行核态的全部功能。管态比核态权限要低，用户态的权限更低。为了区分处理机的工作状态，需要硬件的支持。在计算机状态寄存器中需设置一个系统状态位（或称模式位）。若有了系统状态位，就可以区分当前正在执行的是系统程序还是用户程序。**若用户程序执行时，超出了它的权限，如要访问操作系统核心数据或企图执行一个特权指令，都将从用户态转为管态，由操作系统得到CPU控制权，处理这一非法操作。这样可以有效地保护操作系统不受破坏。当用户程序执行时，若需要请求操作系统服务，则要通过一种受控方式进入操作系统，将用户态转为核态，由操作系统得到控制权，在核态下执行其相应的服务例程，服务完毕后，返回到用户态，让用户继续执行。**\n\n### 中断机制\n\n所谓中断是指某个事件（例如电源掉电、定点加法溢出或I/O传输结束等）发生时，系统中止现行程序的运行、引出处理该事件程序进行处理，处理完毕后返回断点，继续执行。\n  ![](./操作系统原理/5.jpg)\n中断响应的实质是交换指令执行地址和处理器状态，以达到如下目的：①保留程序断点及有关信息；②自动转入相应的中断处理程序执行。中断响应所需的硬件支持包括：指令计数器、处理器状态寄存器、中断向量表和系统堆栈。\n整个中断处理的功能是由硬件和软件配合完成的。硬件负责中断进入过程，即发现和响应中断请求，把中断的原因和断点记下来供软件处理时查用，同时负责引出中断处理程序。而中断分析、中断处理、恢复被中断程序的现场等工作则由软件的中断处理程序来完成。\njava里数组越界的一场应该算一种中断。\n\n### UNIX系统结构\n\nUNIX系统核心层的功能包括文件管理、设备管理、存储管理和处理机管理，此外还有中断和俘获的处理。**现代计算机系统的硬件机构支持核心态和用户态，使得核心程序在核心态下运行，实用程序在用户态下运行。每一种状态都有自己的栈和栈指针，都有自己的地址映射部件。所以，用户态的程序不能直接访问核心态的程序和数据，只能通过访问管理程序指令（访管指令，如trap指令）自陷到核心内的操作系统服务程序。\nUNIX系统的核心结构是一体化结构。**\n![loading-ag-518](./操作系统原理/6.jpg)\n\n### 静态连接和动态链接\n\n连接这一处理步骤，以前通常采用静态连接方式。静态连接是将所需的外部调用函数连接到目标文件中形成一个完整的主存映像文件。采用这种静态连接的缺点是，当有多个应用程序都需要调用同一个库函数时，那么，这些应用程序的目标文件中都将包含这个外部函数对应的代码。这将造成主存的极大浪费，不能支持有效的共享。动态链接是将这一连接工作延迟到程序运行的时候进行。它需要的支持是动态链接库（DLL）。动态链接不需要将应用程序所需要的外部函数代码从库中提取出来并连接到目标文件中，而是在应用程序需要调用外部函数的地方作记录，并说明要使用的外部函数名和引用入口号，形成调用链表。当所需的动态链接库DLL在主存时，就可以确定所需函数的主存绝对地址，并将它填入调用链表相应位置中。当应用程序运行时，就可以正确地引用这个外部函数了。现代操作系统有的已采用了动态链接技术，如Windows系统，现在的动态链接库一般是系统库。\n\n### 操作系统提供的用户界面\n\n操作系统提供的用户界面如下图所示：一是操作界面，又称为操作命令；二是程序界面，又称为系统功能调用。\n![loading-ag-519](./操作系统原理/7.jpg)\n\n### 系统功能调用\n\n为了实现在程序级的服务支持，操作系统提供统一的系统功能调用，采用统一的调用方式——访问管理程序来实现对这些功能的调用。\n**对于用户所需要的功能，由系统设计者事先编制好能实现这些功能的例行子程序，作为操作系统程序模块的一部分。这些例行子程序不能像一般的用户子程序那样可随便调用，因为这些能实现各种功能的例行子程序是操作系统的程序部分，它运行时，机器处于管态（管理程序状态），而用户程序运行时，机器处于用户态。所以，用户程序对这些例行子程序的调用应以一种特殊的调用方式——访管方式来实现。**\n这样一个带有一定功能号的访管指令定义了一个系统调用。因此，系统调用是用户在程序一级请求操作系统服务的一种手段，它不是一条简单的硬指令，而是带有一定功能号的访管指令。它的功能并非由硬件直接提供，而是由操作系统中的一段程序完成的，即由软件方法实现的。用户可以用带有不同功能号的访管指令来请求各种不同的功能。可以这样说，系统调用是利用访管指令定义的指令。操作系统服务例程与一般子程序的区别在于，前者所实现的功能都是与计算机系统本身有关的，对前者的调用是通过一条访管指令来实现的。不同的程序设计语言调用操作系统服务的方式是不同的，它们有显式调用和隐式调用之分。**在汇编语言中是直接使用系统调用对操作系统提出各种要求的，因为在这种情况下，系统调用具有汇编指令的形式。而在高级语言中一般是隐式的调用（经编译后转成某种直接调用）。**\n\n## 并发\n\n### 进程概念\n\n#### 进程定义\n\n根据1978年在庐山召开的全国操作系统会议上关于进程的讨论，结合国外的各种观点，国内对进程这一概念作了如下描述：进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动。\n进程和程序是既有联系又有区别的两个概念，它们的区别如下。（1）程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态概念。而进程是程序在处理机上的一次执行过程，它是一动态概念。程序可以作为一种软件资料长期保存，而进程则是有一定生命期的，它能够动态地产生和消亡。即进程可由“创建”而产生，由调度而执行，因得不到资源而暂停，以致最后由“撤销”而消亡。（2）进程是一个能独立运行的单位，能与其他进程并行地活动。（3）进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。\n进程和程序又是有联系的。在支持多任务运行的操作系统中，活动的最小单位是进程。进程一定包含一个程序，因为程序是进程应完成功能的逻辑描述；而一个程序可以对应多个进程。如果同一程序同时运行于若干不同的数据集合上，它将属于若干个不同的进程。或者说，若干不同的进程可以包含相同的程序。这句话的意思是：用同一程序对不同的数据先后或同时加以处理，就对应于好几个进程。例如，系统具有一个C语言编译程序，当它对多个终端用户的C语言源程序进行编译时，就产生了多个编译进程。\n\n#### 进程类型\n\n有些进程起着资源管理和控制的作用，称为系统进程；而另一些是为用户算题任务而建立的进程称为用户进程。它们是有区别的。①系统进程被分配一个初始的资源集合，这些资源可为它所独占，也可以最高优先级的资格优先使用。用户进程通过系统服务请求的手段竞争系统资源。②用户进程不能做直接I/O操作，而系统进程可以做显示的、直接的I/O操作。③系统进程在管态下活动，而用户进程在用户态下活动。\n\n#### 进程状态\n\n进程有着“执行—暂停—执行”的活动规律。一般说来，一个进程并不是自始至终连续不停地运行的，它与并发执行中的其他进程的执行是相互制约的。它有时处于运行状态，有时又由于某种原因而暂停运行处于等待状态，当使它暂停的原因消失后，它又进入准备运行状态。所以，在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、等待状态（又称阻塞状态）。①就绪状态（ready）。当进程获得了除CPU之外所有的资源，它已经准备就绪，一旦得到CPU控制权，就可以立即运行，该进程所处的状态为就绪状态。②运行状态（running）。当进程由调度／分派模块分派后，得到中央处理机控制权，它的程序正在运行，该进程所处的状态为运行状态。③等待状态（wait）。若一进程正在等待某一事件发生（如等待输入／输出操作的完成）而暂时停止执行，这时，即使给它CPU控制权，它也无法执行，则称该进程处于等待状态，又可称为阻塞状态。\n为了描述一个进程和其他进程以及系统资源的关系，为了刻画一个进程在各个不同时期所处的状态，人们采用了一个与进程相联系的数据块，称为进程控制块（processcontrolblock，PCB）或称为进程描述器（processdescriptor）。系统根据pcb而感知进程的存在，故pcb是标识进程存在的实体。当系统创建一个进程时，必须为它设置一个pcb，然后根据pcb的信息对进程实施控制管理。进程任务完成时，系统撤销它的pcb，进程也随之消亡。\n\n#### 线程概念\n\n在操作系统中，为了支持并发活动，引入了进程的概念，在传统的操作系统中，每个进程只存在一条控制线索和一个程序计数器。但在有些现代操作系统中，提供了对单个进程中多条控制线索的支持。这些控制线索通常称为线程（threads），有时也称为轻量级进程（lightweightprocesses）。线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多条执行路径，即线程。这样，在一个进程内部就有多个可以独立活动的单位，可以加快进程处理的速度，进一步提高系统的并行处理能力。\n①线程是进程中的一条执行路径；②它有自己私用的堆栈和处理机执行环境（尤其是处理器寄存器）；③它共享分配给父进程的主存；④它是单个进程所创建的许多个同时存在的线程中的一个。\n进程和线程既有联系又有区别，对于进程的组成，可以高度概括为以下几个方面：①一个可执行程序，它定义了初始代码和数据；②一个私用地址空间（addressspace），它使进程可以使用的一组虚拟主存地址；③进程执行时所需的系统资源（如文件、信号灯、通信端口等），是由操作系统分配给进程的；④若系统支持线程运行，那么每个进程至少有一个执行线程。进程是任务调度的单位，也是系统资源的分配单位；而线程是进程中的一条执行路径，当系统支持多线程处理时，线程是任务调度的单位，但不是系统资源的分配单位。线程完全继承父进程占有的资源，当它活动时，具有自己的运行现场。\n相对进程而言，线程的创建与管理的开销要小得多。因为线程可以共享父进程的所有程序和全局数据，这意味着创建一个新线程只涉及最小量的主存分配（线程表），也意味着一个进程创建的多个线程可以共享地址区域和数据。在进程内创建多线程，可以提高系统的并行处理能力。例如，一个文件服务器，某时刻它正好封锁在等待磁盘操作上，如果这个服务器进程具有多个控制线程，那么当另一个线程在等待磁盘操作时，第二个线程就可以运行，比如它又可接收一个新的文件服务请求。这样可以提高系统的性能。\n\n## 处理机调度\n\n### 多级调度\n\n1．批处理系统中的处理机调度\n在多用户批处理操作系统中，对处理机的分配分为两级：作业调度和进程调度。在这样的系统中，每个用户提交的算题任务，往往作为系统的一个处理单位，称为作业。这样一道作业在处理过程中又可以分为多个并发的活动单位，称为进程。作业调度又称为宏观调度，其任务是对提交给系统的、存放在辅存设备上的大量作业，以一定的策略进行挑选，分配主存等必要的资源，建立作业对应的进程，使其投入运行。进入主存中的进程还可以根据需要创建子进程。作业调度使该作业对应的进程具备使用处理机的权利。而进入主存的诸进程，分别在什么时候真正获得处理机，这是由处理机的进程调度（一般又称为微观调度）来决定的。进程调度的对象是进程，其任务是在进入主存的所有进程中，确定哪个进程在什么时候获得处理机，使用多长时间等。\n2．多任务操作系统中的处理机调度\n3．多线程操作系统中的处理机调度\n在现代操作系统中，有些系统支持多线程运行。在这样的系统中，一个进程可以创建一个线程，也可以创建多个线程。系统为进程分配它所需要的资源（如主存），而处理机的分配单位则为线程，系统提供线程调度程序，其功能是当处理机空闲时，以某种策略选择一个就绪线程去运行，并为它分配处理机时间。\n\n### 作业调度算法\n\n1．先来先服务调度算法\n2．短作业优先调度算法\n3．响应比高者优先调度算法\n4．优先调度算法\n\n### 进程调度\n\n#### 调度／分派结构\n\n任何进程都必须通过调度／分派模块来使用处理机。进程调度的功能可细分为调度和分派两部分。其中，调度意味着依照完全确定的策略将一批进程进行排序，而分派则是从就绪队列中移出一个进程并给它提供处理机的使用权。相应的调度程序和分派程序的功能是：调度程序负责将一个进程插入到就绪队列并按一定原则保持队列结构；分派程序是将进程从就绪队列中移出并建立该进程执行的机器状态。\n但是，在一些系统中常常只提进程调度的概念，而不细分调度和分派这两个部分。因为这里所说的调度功能实际上分散到某些进程控制原语或通信原语中实现了，所以在这些系统中，调度与分派之间不加区别，并统称为调度程序模块。在这里提出调度／分派结构，是希望读者明确处理机的分配包含有两方面内容：一是按确定的调度原则选一个进程；二是给选中进程赋予处理机的控制权。若要强调后者，就使用“分派程序”这一名词；否则就采用“进程调度程序”这一名词。\n\n- CPU现场信息的切换\n  CPU现场信息的切换（即保留原来运行进程的状态信息，并用保留在选中进程PCB中的状态信息设置CPU现场）所需时间是额外开销，因为切换时系统并不能做其他的工作。进程切换所需时间因机器不同而不同，它取决于主存速度、必须复制的寄存器的数量、是否有特殊指令（如装入或保存所有单个指令）等因素。切换时间与硬件支持密切相关。例如，有的处理器（如SUNUltraSPARC）提供了多个寄存器组，切换只需要简单地改变当前寄存器组的指针。当处理器只有一个寄存器组，或活动进程超过了寄存器组的数量时，系统必须在寄存器组与主存之间进行数据复制。而且，操作系统越复杂，这一切换所要做的工作就越多。典型的进程切换时间为1μs到1000μs。进程调度时机可能有以下几种：①进程完成其任务时；②在一次管理程序调用之后，该调用使现行程序暂时不能继续运行时；③在一次出错陷入之后，该陷入使现行进程在出错处理时被挂起时；④在分时系统中，当进程使用完规定的时间片，时钟中断使该进程让出处理机时；⑤在采用可剥夺调度方式的系统中，当具有更高优先级的进程要求处理机时。\n- 进程调度的准则\n  不同的进程调度算法具有不同的特点，且可能对某些进程更有利。为了对算法进行选择以适用于特定的应用，必须分析各种算法的特点。为了比较各种进程调度算法，分析员提出了许多准则，这些准则对确定算法的优劣有很大的影响，这些准则涉及如下几个因素。（1）CPU使用率。需要使CPU尽可能忙。CPU使用率从0到100％。对于真实系统，它应从40％（轻负荷系统）到90％（重负荷系统）。（2）吞吐量。如果CPU忙于执行进程，那么就要评估其工作量。其中一种测量工作量的方法称为吞吐量。吞吐量是指一个时间单元内所完成的进程数量。若系统中短进程多，则吞吐量较高，可能为每秒十个进程。（3）周转时间。在批处理系统中，从作业进入系统到完成的时间间隔称为周转时间。周转时间是所有时间段之和，包括等待进入主存、在就绪队列中等待、在CPU上执行和I/O执行时间。利用特权可以分析运行该作业需要花费的时间。（4）响应时间。对于交互式系统而言，周转时间并不是最佳的准则，通常采用响应时间作为时间度量。响应时间是指从联机用户向计算机发出一个命令到计算机执行完该命令，并将相应的执行结果返回给用户所需的时间。（5）等待时间。进程调度算法并不影响进程运行和执行I/O的时间量，它只影响进程在就绪队列中等待所花费的时间。等待时间是进程在就绪队列中等待所花费时间之和。人们需要使CPU使用率和吞吐量最大化，而使周转时间、响应时间和等待时间最小化。在绝大多数情况下要优化平均度量值，不过在有的情况下，需要优化最小值或最大值，而不是平均值。例如，在分时系统中为了保证所有用户都得到好的服务，可能需要使响应时间最小。\n- 调度方式\n  在优先调度策略下还要确定调度方式。所谓调度方式是指，当一进程正在处理机上执行时，若有某个更为“重要而紧迫”的进程需要进行处理，亦即，若有优先级更高的进程进入就绪队列时，如何分配处理机。通常有两种进程调度方式：一种是仍然让正在执行的进程继续执行，直到该进程完成或发生某事件（如提出I/O请求）而进入“完成”或“阻塞”状态时，才把处理机分配给“重要而紧迫”的进程，使之执行，这种进程调度方式称为非剥夺方式；另一种方式则是“重要而紧迫”的进程一到，便暂停正在执行的进程，立即把处理机分配给它，这种方式称为可剥夺调度方式。后者所实施的策略就是可抢占的调度策略。\n- 进程优先数调度\n  进程优先数调度算法就是一种优先调度，该算法预先确定各进程的优先数，系统将处理机的使用权赋予就绪队列中具备最高优先级（优先数和一定的优先级相对应）的就绪进程。这种算法又可分为不可抢占CPU与可抢占CPU两种情况。在后一种情况下，无论何时，执行着的进程的优先级总要比就绪队列中的任何进程的优先级高。\n\n## 主存管理\n\n### 空间分片\n\n现代操作系统区分两类主存：物理主存和逻辑主存。主存共享的基础当然是物理主存。物理主存由0～m-1个物理地址组成。物理地址是计算机主存单元的真实地址，又称为绝对地址或实地址。处理机依据绝对地址可以随机存取存放在其内的信息。物理地址的集合所对应的空间组成了主存空间。而主存中的一个区域是物理地址集合的一个递增整数序列子集{n，n+1，…，n+m}所对应的主存空间。\n在多用户多进程系统中，主存以分片方式实现共享。主存中分片的方式有两种：一是划分为大小不等的区域，这些区域根据用户程序实际需要而被分割；二是划分为大小相等的块，以块为单位进行分配，操作系统和用户程序根据需要占用若干主存块。前者一般称为按区（或按段）分配，后者称为按页分配。这些分配方法是实现主存共享的主要方法。\n\n### 主存管理的功能\n\n如果直接以物理地址提交给用户使用，这对用户来说是十分困难的事。而且，多个用户程序共享主存，由用户自行分配主存更是不可能的事。为了支持多道程序运行，方便用户使用，系统必须为每个用户提供0～n-1的一组逻辑地址（虚地址），即提供一个虚拟地址空间。每个应用程序相信它的主存是由0单元开始的一组连续地址组成。用户的程序地址（指令地址或操作数地址）均为逻辑地址。对于每个逻辑地址，在主存中并没有一个固定的、真实的物理单元与之对应。因此，根据逻辑地址还不能直接到主存中去存取信息，它是一个虚地址或称为相对地址。用户所看到的虚存（逻辑地址）与被共享的主存（物理地址）之间有一定的映射关系。程序执行时，必须将逻辑地址正确地转换为物理地址，此即为地址映射。假定虚存空间由n表示，主存空间由m表示，那么地址映射可表示成：f：n→m。为了支持多道程序运行，主存管理必须实现主存分配、主存保护、主存扩充等功能。因此，存储管理的功能可归纳为以下几点：①映射逻辑地址到物理主存地址；②在多用户之间分配物理主存；③对各用户区的信息提供保护措施；④扩充逻辑主存区。\n\n#### 虚拟存储器\n\n随着科学技术的不断进步和计算机应用的日益广泛，需要计算机解决的问题越来越多、越来越复杂。有些科学计算或数据处理的问题需要相当大的主存容量，尤其在多道程序系统中主存容量显得更为紧张。当系统提供大容量的辅存时，操作系统把主存和辅存统一管理，实现信息的自动移动和覆盖。当一个用户程序的地址空间比主存可用空间大时，操作系统将这个程序的地址空间的一部分放入主存内，而其余部分放在辅存上。当所访问的信息不在主存时，则由操作系统负责调入所需要的部分。由于大多数程序执行时，在一段时间内仅使用它的程序编码的一部分，即并不需要在全部时间内将该程序的全部指令和数据都放在主存中，所以，程序的地址空间部分装入主存时，它还能正确地执行，此即为程序的局部性特征。\n虚拟存储器（virtualmemory）将用户的逻辑主存与物理主存分开，这是现代计算机对虚存的实质性的描述。更为一般的描述是：计算机系统在处理应用程序时，只装入部分程序代码和数据就启动其运行，由操作系统和硬件相配合完成主存和外围联机存储器之间的信息的动态调度，这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器。之所以称它为虚拟存储器，是因为这样的存储器实际上并不存在，只是由于系统提供了自动覆盖功能后，给用户造成的一种虚拟的感觉，仿佛有一个很大的主存供他使用一样。\n虚拟存储器的核心问题是将程序的访问地址和主存的可用地址相脱离。程序的访问地址称为虚地址，它可以访问的虚地址范围叫做程序的虚地址空间V，虚地址范围是由虚地址寄存器的位数决定的。在指定的计算机系统中，可使用的实地址范围叫做计算机的实地址空间R。当然，虚地址空间可以比实地址空间大，也可以比实际主存小。在多道程序运行环境下，操作系统把实际主存扩充成若干个虚存，系统可以为每个应用程序建立一个虚存。这样每个应用可以在自己的地址空间中编制程序，在各自的虚存上运行。引入虚存概念后，用户无需了解实存的物理性能，只需在自己的虚存上编制程序，这给用户带来了极大的方便。主存空间的分配由系统完成；逻辑地址转换成物理地址是通过地址变换机构自动完成的，这样，既消除了普通用户对主存分配细节、具体问题了解的困难，方便了用户，又能根据主存的情况和应用程序的实际需要进行动态分配，从而充分利用了主存。而且，多道程序设计所要求的存储保护、程序浮动都可以很方便地实现。必须指出，实现虚拟存储技术，需要有一定的物质基础。其一是需要有相当容量的辅存，以便足以存放多用户的作业的地址空间；其二是要有一定容量的主存；其三是地址变换机构。\n\n### 分区存储管理\n\n分区存储管理是满足多道程序设计的最简单的一种存储管理方法。它允许多个用户作业共享主存空间，这些作业在主存内是以划分分区而共存的。早期的分区存储管理技术只有固定式分区方法，后来才发展形成动态分区方法。\n分区存储管理技术能满足多道程序设计的需要，但它也存在着一个非常严重的碎片问题。解决这个问题的办法之一是采用拼接技术。所谓拼接技术是指移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲区，拼接要消耗大量的系统资源，且有时为拼接所花费的系统开销要大于拼接所得到的效益，因而这种方法的使用受到了限制。\n\n### 页式存储管理\n\n为了寻找解决碎片问题的新途径，人们很容易想到能否避开程序对连续连续性的要求，让程序的地址空间去适应存储器的现状。例如，有一个作业要求投入运行，其程序的地址空间为3KB，而主存当前只有两个各为1KB和2KB的空闲区。显然，每个空闲区的大小都比该程序的地址空间小，而总和却同它相等。这时可以把该程序存放到主存中这两个不相邻的区域中。这正是分页的思想。\n在分页存储管理方法中，主存被等分成一系列的块，程序的地址空间被等分成一系列的页面，然后将页面存放到主存块中。为了便于实现动态地址变换，一般主存的块和页面大小相等且为2的幂次。\n另外，在按区分配方案中，当作业程序的地址空间小于主存可用空间时，该作业是不能投入运行的，即不能方便地实现主存扩充。但是，在页式系统中则可方便地支持虚拟存储，扩充主存，因为它不需限定作业在投入运行之前必须把它的全部地址空间装入主存，而只要求把当前所需要的一部分页面装入主存即可。这样，对虚地址空间的限制，至少从理论上来说被取消了。换句话说，这种系统为用户提供了一个很大的地址空间。但系统必须完成主存和辅存之间的信息的自动调度。因为，一个作业的全部页面存放在辅存上，当它投入运行时，只是将运行进程的部分页面装入主存（这些页面称为活动页面），在进程活动期间，系统根据其需要再从辅存调入所需的页面。\n\n#### 页表\n\n程序的虚地址空间划分为若干页，并被装入主存的空闲块中。于是，一个连续的程序空间在主存中可能是不连续的。为了保证程序能正确地运行，必须在执行每条指令时将程序中的逻辑地址变换为实际的物理地址，即进行动态重定位。在页式系统中，实现这种地址变换的机构称为页面映像表，简称页表。在页式系统中，当程序按页划分装入存储器时，操作系统为该程序建立一个页表。页表是记录程序虚页与其在主存中块（实页）的对应关系的数据结构。页表中的每一个数据项用来描述页面在主存中的物理块号以及页面的使用特性（根据需要扩充页表的功能）。在简单的页式系统中，页表只是虚页和主存物理块的对照表。\n页表可由高速缓冲存储器组成，这样做的结果是，地址变换速度快，但成本较高。另一个办法是在主存固定区域内，用存储单元来存放页表。这种方法要占用一部分主存空间，而且地址变换速度较慢。现代的计算机系统采用硬件与主存页表相结合的方法实现地址变换。\n\n![](./操作系统原理/9.jpg)根据实际使用的经验，一般页面尺寸为1KB、2KB或4KB。\n当请求调页程序要调进一个页面、而此时该作业所分得的主存块已全部用完，则必须淘汰该作业已在主存中的一个页。这时，就产生了在诸页面中淘汰哪个页面的实际问题，这也就涉及淘汰算法即置换算法的问题。算法设计不好将造成巨大系统开销，称为颠簸。\n\n### 段式系统\n\n在前述的分区存储管理和页式系统中，程序的地址空间是一维线性的，因为指令或操作数地址只要给出一个信息量即可决定。分区存储管理方法易出现碎片。页式系统中一页或页号相连的几个虚页上存放的内容一般都不是一个逻辑意义完整的信息单位。请调一页，可能只用到页中的一部分内容。这种情况，对于要调用许多子程序的大型用户程序来说，仍然会感到感到主存空间的使用效率不高。为此，提出了段式存储管理技术。在这样的系统中作业的地址空间由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，它是一个连续的地址区。在主存中，每个分段占一分区。由于分段是一个有意义的信息单位，所以分段的共享和对分段的保护更有意义，同时也容易实现。\n\n### 段页式存储管理\n\n在段式存储管理中结合分页存储管理技术，即在程序地址空间内分段，在一个分段内划分页面，这就形成了段页式存储管理。具有段页式地址结构的用户地址空间。\n段页式存储管理的用户地址空间是二维的、按段划分的。在段中再划分成若干大小相等的页。这样，地址结构就由段号、段内页号和页内位移三部分组成。用户使用的仍是段号和段内相对地址，由地址变换机构自动将段内相对地址的高几位解释为段内页号，将剩余的低位解释为页内位移。用户地址空间的最小单位不是段而是页，而主存按页的大小划分，按页装入。这样，一个段可以装入到若干个不连续的主存块内，段的大小不再受主存可用区的限制了。\n\n![](./操作系统原理/10.jpg)段页式地址变换中要得到物理地址须经过三次主存访问（若段表、页表都在主存），第一次访问段表，得到页表起始地址；第二次访问页表，得到主存块号；第三次将主存块号与页内位移组合，得到物理地址。可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但在方便用户和提高存储器利用率上很好地实现了存储管理的目标。\n请求调页策略是在主存和辅存之间传送存储页，而不是整个进程。这样，整个进程并不需要全部驻留在主存中就可运行，即当进程访问页面时，核心为进程装入该页。请求调页的优点是，它使进程的虚地址空间到机器的物理存储空间的映射更为灵活，允许进程的大小比可用的物理存储空间大得多，还允许将更多的进程同时装入主存。\n\n## 输入／输出管理\n\nI/O设备是计算机系统中除中央处理机、主存储器之外的所有其他的设备。\n为了便于用户作业及相应进程在运行期间利用各类设备I/O，管理程序应能屏蔽设备的物理特性，为用户建立虚环境。现代操作系统一般采用“设备独立性”的概念。\n所谓设备独立性是指用户在编制程序时所使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。逻辑设备名是用户自己指定的设备名（或设备号），它是暂时的、可更改的。而物理设备名是系统提供的设备的标准名称，它是永久的、不可更改的。虽然程序在实际执行中必须使用实际的物理设备，就好像程序在主存中一定要使用物理地址一样，但在用户程序中则应避免使用实际的物理名，而采用逻辑设备名。这样做的道理就和用户程序中要使用逻辑地址而不使用物理地址的道理一样。设备管理的任务之一就是把逻辑设备名转换成物理设备名。\n\n### 缓冲技术\n\n- 什么是缓冲\n  缓冲是在两种不同速度的设备之间传输信息时平滑传输过程的常用手段。缓冲器是以硬件的方法来实现缓冲的，它容量较小，是用来暂时存放数据的一种存储装置。从经济上考虑，除了在关键的地方采用少量必要的硬件缓冲器之外，大都采用软件缓冲。软件缓冲区是指在I/O操作期间用来临时存放I/O数据的一块存储区域。缓冲是为了解决中央处理机的速度和I/O设备的速度不匹配的问题而提出来的，缓冲也可用于解决程序所请求的逻辑记录大小和设备的物理记录大小失配的问题，是有效地利用中央处理机的重要技术。下面看看缓冲是如何工作的。当用户要求在某个设备上进行读操作时，从系统中获得一个空的缓冲区，并将一个物理记录读到缓冲区中。当用户要求使用这些数据时，系统将依据逻辑记录特性从缓冲区中提取并发送到用户进程存储区中。当缓冲区空而进程又要从中取数据时该进程被迫等待。此时，操作系统需要重新送数据填满缓冲区，进程则从中取数据继续运行。当用户要求写操作时，先从系统获得一个空缓冲区，并且将一个逻辑记录从用户的进程存储区传送到缓冲区中。若为顺序写请求，则把数据写到缓冲区中，直到它完全装满为止。然后系统将缓冲区的内容作为物理记录文件写到设备上，使缓冲区再次为空。只有在系统还来不及腾空缓冲区之前，进程又企图输出信息时，它才需要等待。\n\n- 使用缓冲的理由\n  1）处理数据流的生产者与消费者之间的速度差异\n  2）协调传输数据大小的不一致\n  3）应用程序的拷贝语义\n\n### 输入／输出控制方式\n\n外部设备在中央处理机的控制之下完成信息的传输。在信息传输中，中央处理机做多少工作、外部设备做多少工作呢？这个问题将决定CPU和I/O设备的并行能力，同时它也取决于软、硬技术的基础。CPU一般通过I/O控制器与物理设备打交道。按照I/O控制器智能化程度的高低，可把I/O设备的控制方式分为四类：循环测试I/O方式、I/O中断方式、DMA方式和通道方式。\n\n- I/O中断方式\n  与循环测试方式相比，I/O中断方式使CPU的利用率大大提高了。但缺点是由于每台设备每次输入／输出一个数据，都要求中断CPU，当系统配置的设备较多时，系统进行中断处理的次数就很多，这会使CPU的有效计算时间大大减少。为减少I/O中断处理对CPU造成的负担，又出现了通道方式和DMA方式。\n\n- 通道方式\n  在大、中型和超级小型机中，一般采用I/O通道控制I/O设备的各种操作。I/O通道是用来控制外部设备与主存之间进行成批数据传输的部件。每个通道可以连接多台外部设备并控制它们的I/O操作。通道有自己的一套简单的指令系统和执行通道程序，通道接收CPU的委托，而又独立于CPU工作。因此，可以把通道看做是一台小型的处理I/O的处理机，或称I/O处理机。\n  与前面两种I/O方式相比，通道方式有更强的I/O处理能力。有关I/O的工作，CPU委托通道去做，当通道完成了I/O任务后，向CPU发中断信号，请求CPU处理。这样就使CPU基本上摆脱了I/O控制工作，并大大提高了CPU与外部设备的并行工作的程度。\n\n- DMA方式\n  在DMA方式中，I/O控制器有更强的功能。它除了具有上述的中断功能外，还有一个DMA控制机构。在DMA控制器的控制下，设备和主存之间可成批地进行数据交换，而不用CPU干预。这样既大大减轻了CPU的负担，也使I/O的数据传送速度大大提高。在DMA方式下，允许DMA控制器“接管”地址线的控制权，而直接控制DMA控制器与主存的数据交换。因此，I/O设备与主存之间的数据传送不需要CPU介入，从而减轻了CPU的负担。\n\n### UNIX系统设备管理的主要特点\n\n  1．将外部设备看做文件，由文件系统统一处理\n  2．系统的设备配置灵活、方便\n  3．使用块设备缓冲技术，提高了文件系统的存取速度块设备的文件存储部分是文件系统存在的介质，而文件系统与用户界面的联系最为密切，故文件系统存取文件的效率是十分重要的。文件系统通过高速缓冲机制存取文件数据，缓冲机制调节核心与文件存储设备之间的数据流。UNIX提供由数据缓冲区组成的高速缓冲，每个缓冲区的大小为512字节。当用户程序要把信息写入文件时，先写入缓冲区里立即返回，由系统作延迟写处理。当用户程序要从磁盘读文件信息时，先要查看在缓冲区缓冲区中有无含有此信息的块，如果有就不必启动磁盘I/O，可立即从缓冲区内取出。这种做法大大加快了文件的访问速度。\n\n- UNIX缓冲区的管理\n  对文件系统的一切存取操作，核心都能通过每次直接从磁盘上读或往磁盘上写来实现。但磁盘的传输速率与CPU的速度相比还是慢的。为了加快系统的响应时间和增加系统的吞吐量，UNIX构造了一个由高速缓冲组成的内部数据缓冲池，以降低磁盘的存取频率。UNIX缓冲管理策略试图将尽可能多的有用数据保存在高速缓冲中。核心体系结构中的高速缓冲模块的位置处于文件子系统与块设备驱动程序之间。当从磁盘中读数据时，核心试图先从高速缓冲区中读。如果数据已在高速缓冲中，核心可以不必启动磁盘I/O。如果数据不在该高速缓冲区中，则核心从磁盘上读数据，并将其暂时保存在缓冲区中。类似地，要往磁盘上写数据时，也先往高速缓冲区中写入，以便核心随后又试图读它时，它能在高速缓冲中。但是，被写在高速缓冲中的数据要延迟写到非往磁盘上写不可的时候才进行。所以，高速缓冲模块的算法实现了数据的预先缓存和延迟发送的功能。\n\n## 文件系统\n\n文件的物理结构：连续文件、串联文件、随机文件、索引文件\n\n### 文件目录\n\n文件系统是用户和外部设备之间的接口和界面。用户可通过文件系统去管理和使用各种设备介质上的信息。文件系统的大部分工作是为了解决“用户所需的信息结构及其操作”与“设备介质的实际结构和I/O指令”之间的差异。用户所希望的信息结构是按照简单的逻辑关系组织在一起的，他们所希望的操作是一些只用名字就能存取所需信息的读写操作。然而，计算机只能使用各种I/O指令去存取相应介质上的信息，其信息结构又是按照设备介质的各自特点组织的。因此，文件系统所要解决的核心问题，就是按照充分发挥主机和外部设备效率的原则，把信息的逻辑结构映像成设备介质上的物理结构，把用户的文件操作转换成相应的I/O指令。转换过程所使用的主要数据结构是文件目录和辅存空间使用情况表。这样，文件目录就将每个文件的符号名和它们在辅存空间的物理地址与有关文件情况的说明信息联系起来了。因此，用户只需向系统提供一个文件符号名，系统就能准确地找出所要的文件来，这就是文件系统的基本功能。实现符号名与具体物理地址之间的转换，其主要环节是查目录。所以，目录的编排应以如何能准确地找到所需的文件为原则，而选择查目录的方法应以查找速度快为准则。\n\n# 感想\n\n无\n","source":"_posts/操作系统原理.md","raw":"---\ntitle: 操作系统原理\ndate: 2022-11-01 23:23:43\ncategories: \n- 读书\ntags: \n- 操作系统\n---\n\n# 信息\n\n《操作系统原理(第4版)》 庞丽萍 华中科技大学出版社\n\n# 摘录\n\n## 绪论\n\n### 存储程序式计算机\n\n- 冯·诺依曼计算机体系结构\n  ![](./操作系统原理/1.jpg)\n  从20世纪40年代至今，计算机体系结构不断地发展变化，但冯·诺依曼计算机体系结构定义的一个存储程序式计算机的家族，几乎是当代所有计算机系统的构成基础（除专门设计用于处理特殊任务的计算机外）。存储程序式计算机由中央处理器（处理器（CPU））、存储器和输入／输出设备组成。所有的单元都通过总线连接，总线分为地址总线和数据总线，分别连接不同的部件。\n  由于冯·诺依曼型计算机的计算模型是顺序过程计算模型，所以它的特点是集中顺序过程，在当代的CPU中，可有32～64个通用寄存器，每个寄存器能够保存一个32位（bit）的数值。通用寄存器可以为功能单元提供操作数，并能接收、保存操作的结果。控制单元负责从主存储器提取指令、分析其类型，并产生信号通知计算机其他部分执行指令所指定的操作。控制单元包含一个程序计数器（programcounter，PC）和一个指令寄存器（instructionregister，IR）。程序计数器指示下一步应该执行的指令，而指令寄存器包含当前指令的拷贝。\n\n### 操作系统的发展历程\n\n操作系统是构成计算机系统的另一个重要的系统软件，它负责管理计算机系统的硬件、软件资源并控制整个计算机的工作流程。\n\n- 发展历程\n  从1950年至今，操作系统的发展主要经历了如下的几个阶段：①手工操作阶段——无操作系统；②批处理系统——早期批处理、执行系统；③操作系统形成——批处理操作系统、分时操作系统、实时操作系统；④现代操作系统——个人计算机操作系统、网络操作系统、分布式操作系统。\n\n- 中断和通道\n  20世纪60年代初期，硬件获得了两方面的进展：一是通道的引入；二是中断技术的出现。这两项重大成果导致操作系统进入执行系统阶段。通道是一种专用处理部件，它能控制一台或多台外设的工作，负责外部设备与主存之间的信息传输。它一旦被启动，就能独立于CPU运行，这样就可使CPU和通道并行操作，而且CPU和各种外部设备也能并行操作。所谓中断是指当主机接到某种信号信号（如I/O设备完成信号）时，马上停止原来的工作，转去处理这一事件，当事件处理完毕，主机又回到原来的工作点继续工作。\n\n- 多道程序\n  中断和通道技术出现以后，I/O设备和中央处理机可以并行操作，初步解决了高速处理机和低速外部设备的矛盾，提高了计算机的工作效率。但不久又发现，这种并行是有限度的，并不能完全消除中央处理机对外部传输的等待。比如，一个作业在运行过程中依此输入n批数据，每批输入1000个字符，输入机每输入1000个字符需用1000ms，而处理机处理这些数据则需300ms。可见，尽管处理机具有和外部设备并行工作的能力，但是在这种情况下无法让它多做工作，处理机仍有空闲等待现象。那么，为了提高设备的利用率，能否在系统内同时存放几道程序呢？这就引入了多道程序的概念。\n  多道程序运行的特征是：①多道——计算机主存中同时存放几道相互独立的程序；②宏观上并行——同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕；③微观上串行——从微观上看，主存中的多道程序轮流或分时地占有处理机，交替执行。\n\n- 分时技术\n  当计算机技术和软件技术发展到20世纪60年代中期，由于主机速度不断提高而采用了分时技术，使一台计算机可同时为多个终端用户服务。每个终端用户在自己的终端设备上联机使用计算机，好像自己独占机器一样。\n\n### 操作系统的基本概念\n\n- 计算机系统的组成\n  ![](./操作系统原理/2.jpg)\n  操作系统是一个大型的程序系统，它负责计算机系统软、硬件资源的分配和管理；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境。\n  操作系统是重要的系统软件，只有配置了操作系统这一系统软件后，才使计算机系统体现出系统的完整性和可利用性。当用户要计算机帮助完成其计算任务时，用户仅编制源程序（用户在源程序中，可以利用操作系统提供的系统调用请求操作系统相应的服务），而其余的大量工作，如作业控制、系统资源的合理分配和利用，各种调度策略的制订、人机联系方式等都是由操作系统实施的。所以，操作系统使整个计算机系统实现了高度自动化、高效率、高利用率、高可靠性。操作系统是整个计算机系统的核心。\n\n- 操作系统的资源管理功能\n  操作系统的主要功能是管理系统的软、硬件资源。这些资源按其性质来分，可以归纳为四类：处理机、存储器、外部设备和软件资源。这四类资源就构成了系统程序和用户程序赖以活动的物质基础和工作环境。针对这四类资源，操作系统就有相应的资源管理程序：处理机管理、存储管理、设备管理和软件资源管理程序。这些资源管理程序组成了操作系统这一程序系统。\n\n- 操作系统的基本类型\n  （1）批量操作系统；（2）分时操作系统；（3）实时操作系统；（4）个人计算机操作系统；（5）网络操作系统；（6）分布式操作系统。\n\n## 操作系统的组织结构\n\n### 操作系统虚拟机\n\n在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。扩充后的虚拟机不仅可以使用原来裸机提供的各种基本硬件指令，而且还可使用操作系统中所增加的许多其他“指令”。这些指令统称为扩充机器的指令系统，又称为操作命令语言。\n  ![](./操作系统原理/3.jpg)\n操作系统虚拟机提供了协助用户解决问题的装置，其功能是通过它提供的命令来体现的，用户也是通过这一组命令和操作系统虚拟机打交道的。系统所提供的全部操作命令的集合称为操作命令语言，它是用户和系统进行通信的手段和界面。这一用户界面分为两个方面：操作命令（又称命令接口）和系统功能调用（又称程序接口）。\n操作系统在计算机系统中所处的位置是硬件层（裸机）和其他所有软件之间，是所有软件中与硬件相连的第一层软件，它在裸机上运行，又是系统\n软件和应用程序运行的基础。它与硬件、应用程序和用户都有接口。具有一体化结构的操作系统提供的接口如下图所示，从该结构中可以看出操作系统提供的多种接口。\n  ![loading-ag-517](./操作系统原理/4.jpg)\n\n### 处理机的状态\n\n操作系统是计算机系统中最重要的系统软件，为了能正确地进行管理和控制，其本身是不能被破坏的。为此，系统应能建立一个保护环境，采用的办法是区分处理机的工作状态。因为，在系统中有两类程序在运行，一类是管理程序（如处理机调度程序、主存分配程序、I/O管理程序等）；另一类是用户程序。这两类程序是不同的，前者是管理和控制者，它负责管理和分配系统资源，为用户提供服务。而用户程序运行时，所需资源必须向操作系统提出请求，自己不能随意取用系统资源，如直接启动外部设备进行工作，更不能改变机器状态等。这两类不同程序执行时应有不同的权限，为此根据对资源和机器指令的使用权限，将处理执行时的工作状态区分为不同的状态（或称为模式）。所谓处理机的态，就是处理机当前处于何种状态，正在执行哪类程序。为了保护操作系统，至少需要区分两种状态：管态和用户态。管态（supervisormode）：又称为系统态，是操作系统的管理程序执行时机器所处的状态。在此状态下允许中央处理机使用全部系统资源和全部指令，其中包括一组特权指令（例如，涉及外部设备的输入／输出指令、改变机器状态或修改存储保护的某些指令），允许访问整个存储区。用户态（usermode）：又称为目态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用系统资源与改变机器状态，并且只允许用户程序访问自己的存储区域。有的系统将管理程序执行时的机器状态进一步分为核态和管态，这时，管态的权限有所变化，管态只允许使用一些在用户态下所不能使用的资源，但不能使用修改机器的状态指令。而核态（kernelmode）就具有上述管态所具有的所有权限。无核态的系统，管态执行核态的全部功能。管态比核态权限要低，用户态的权限更低。为了区分处理机的工作状态，需要硬件的支持。在计算机状态寄存器中需设置一个系统状态位（或称模式位）。若有了系统状态位，就可以区分当前正在执行的是系统程序还是用户程序。**若用户程序执行时，超出了它的权限，如要访问操作系统核心数据或企图执行一个特权指令，都将从用户态转为管态，由操作系统得到CPU控制权，处理这一非法操作。这样可以有效地保护操作系统不受破坏。当用户程序执行时，若需要请求操作系统服务，则要通过一种受控方式进入操作系统，将用户态转为核态，由操作系统得到控制权，在核态下执行其相应的服务例程，服务完毕后，返回到用户态，让用户继续执行。**\n\n### 中断机制\n\n所谓中断是指某个事件（例如电源掉电、定点加法溢出或I/O传输结束等）发生时，系统中止现行程序的运行、引出处理该事件程序进行处理，处理完毕后返回断点，继续执行。\n  ![](./操作系统原理/5.jpg)\n中断响应的实质是交换指令执行地址和处理器状态，以达到如下目的：①保留程序断点及有关信息；②自动转入相应的中断处理程序执行。中断响应所需的硬件支持包括：指令计数器、处理器状态寄存器、中断向量表和系统堆栈。\n整个中断处理的功能是由硬件和软件配合完成的。硬件负责中断进入过程，即发现和响应中断请求，把中断的原因和断点记下来供软件处理时查用，同时负责引出中断处理程序。而中断分析、中断处理、恢复被中断程序的现场等工作则由软件的中断处理程序来完成。\njava里数组越界的一场应该算一种中断。\n\n### UNIX系统结构\n\nUNIX系统核心层的功能包括文件管理、设备管理、存储管理和处理机管理，此外还有中断和俘获的处理。**现代计算机系统的硬件机构支持核心态和用户态，使得核心程序在核心态下运行，实用程序在用户态下运行。每一种状态都有自己的栈和栈指针，都有自己的地址映射部件。所以，用户态的程序不能直接访问核心态的程序和数据，只能通过访问管理程序指令（访管指令，如trap指令）自陷到核心内的操作系统服务程序。\nUNIX系统的核心结构是一体化结构。**\n![loading-ag-518](./操作系统原理/6.jpg)\n\n### 静态连接和动态链接\n\n连接这一处理步骤，以前通常采用静态连接方式。静态连接是将所需的外部调用函数连接到目标文件中形成一个完整的主存映像文件。采用这种静态连接的缺点是，当有多个应用程序都需要调用同一个库函数时，那么，这些应用程序的目标文件中都将包含这个外部函数对应的代码。这将造成主存的极大浪费，不能支持有效的共享。动态链接是将这一连接工作延迟到程序运行的时候进行。它需要的支持是动态链接库（DLL）。动态链接不需要将应用程序所需要的外部函数代码从库中提取出来并连接到目标文件中，而是在应用程序需要调用外部函数的地方作记录，并说明要使用的外部函数名和引用入口号，形成调用链表。当所需的动态链接库DLL在主存时，就可以确定所需函数的主存绝对地址，并将它填入调用链表相应位置中。当应用程序运行时，就可以正确地引用这个外部函数了。现代操作系统有的已采用了动态链接技术，如Windows系统，现在的动态链接库一般是系统库。\n\n### 操作系统提供的用户界面\n\n操作系统提供的用户界面如下图所示：一是操作界面，又称为操作命令；二是程序界面，又称为系统功能调用。\n![loading-ag-519](./操作系统原理/7.jpg)\n\n### 系统功能调用\n\n为了实现在程序级的服务支持，操作系统提供统一的系统功能调用，采用统一的调用方式——访问管理程序来实现对这些功能的调用。\n**对于用户所需要的功能，由系统设计者事先编制好能实现这些功能的例行子程序，作为操作系统程序模块的一部分。这些例行子程序不能像一般的用户子程序那样可随便调用，因为这些能实现各种功能的例行子程序是操作系统的程序部分，它运行时，机器处于管态（管理程序状态），而用户程序运行时，机器处于用户态。所以，用户程序对这些例行子程序的调用应以一种特殊的调用方式——访管方式来实现。**\n这样一个带有一定功能号的访管指令定义了一个系统调用。因此，系统调用是用户在程序一级请求操作系统服务的一种手段，它不是一条简单的硬指令，而是带有一定功能号的访管指令。它的功能并非由硬件直接提供，而是由操作系统中的一段程序完成的，即由软件方法实现的。用户可以用带有不同功能号的访管指令来请求各种不同的功能。可以这样说，系统调用是利用访管指令定义的指令。操作系统服务例程与一般子程序的区别在于，前者所实现的功能都是与计算机系统本身有关的，对前者的调用是通过一条访管指令来实现的。不同的程序设计语言调用操作系统服务的方式是不同的，它们有显式调用和隐式调用之分。**在汇编语言中是直接使用系统调用对操作系统提出各种要求的，因为在这种情况下，系统调用具有汇编指令的形式。而在高级语言中一般是隐式的调用（经编译后转成某种直接调用）。**\n\n## 并发\n\n### 进程概念\n\n#### 进程定义\n\n根据1978年在庐山召开的全国操作系统会议上关于进程的讨论，结合国外的各种观点，国内对进程这一概念作了如下描述：进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动。\n进程和程序是既有联系又有区别的两个概念，它们的区别如下。（1）程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态概念。而进程是程序在处理机上的一次执行过程，它是一动态概念。程序可以作为一种软件资料长期保存，而进程则是有一定生命期的，它能够动态地产生和消亡。即进程可由“创建”而产生，由调度而执行，因得不到资源而暂停，以致最后由“撤销”而消亡。（2）进程是一个能独立运行的单位，能与其他进程并行地活动。（3）进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。\n进程和程序又是有联系的。在支持多任务运行的操作系统中，活动的最小单位是进程。进程一定包含一个程序，因为程序是进程应完成功能的逻辑描述；而一个程序可以对应多个进程。如果同一程序同时运行于若干不同的数据集合上，它将属于若干个不同的进程。或者说，若干不同的进程可以包含相同的程序。这句话的意思是：用同一程序对不同的数据先后或同时加以处理，就对应于好几个进程。例如，系统具有一个C语言编译程序，当它对多个终端用户的C语言源程序进行编译时，就产生了多个编译进程。\n\n#### 进程类型\n\n有些进程起着资源管理和控制的作用，称为系统进程；而另一些是为用户算题任务而建立的进程称为用户进程。它们是有区别的。①系统进程被分配一个初始的资源集合，这些资源可为它所独占，也可以最高优先级的资格优先使用。用户进程通过系统服务请求的手段竞争系统资源。②用户进程不能做直接I/O操作，而系统进程可以做显示的、直接的I/O操作。③系统进程在管态下活动，而用户进程在用户态下活动。\n\n#### 进程状态\n\n进程有着“执行—暂停—执行”的活动规律。一般说来，一个进程并不是自始至终连续不停地运行的，它与并发执行中的其他进程的执行是相互制约的。它有时处于运行状态，有时又由于某种原因而暂停运行处于等待状态，当使它暂停的原因消失后，它又进入准备运行状态。所以，在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、等待状态（又称阻塞状态）。①就绪状态（ready）。当进程获得了除CPU之外所有的资源，它已经准备就绪，一旦得到CPU控制权，就可以立即运行，该进程所处的状态为就绪状态。②运行状态（running）。当进程由调度／分派模块分派后，得到中央处理机控制权，它的程序正在运行，该进程所处的状态为运行状态。③等待状态（wait）。若一进程正在等待某一事件发生（如等待输入／输出操作的完成）而暂时停止执行，这时，即使给它CPU控制权，它也无法执行，则称该进程处于等待状态，又可称为阻塞状态。\n为了描述一个进程和其他进程以及系统资源的关系，为了刻画一个进程在各个不同时期所处的状态，人们采用了一个与进程相联系的数据块，称为进程控制块（processcontrolblock，PCB）或称为进程描述器（processdescriptor）。系统根据pcb而感知进程的存在，故pcb是标识进程存在的实体。当系统创建一个进程时，必须为它设置一个pcb，然后根据pcb的信息对进程实施控制管理。进程任务完成时，系统撤销它的pcb，进程也随之消亡。\n\n#### 线程概念\n\n在操作系统中，为了支持并发活动，引入了进程的概念，在传统的操作系统中，每个进程只存在一条控制线索和一个程序计数器。但在有些现代操作系统中，提供了对单个进程中多条控制线索的支持。这些控制线索通常称为线程（threads），有时也称为轻量级进程（lightweightprocesses）。线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多条执行路径，即线程。这样，在一个进程内部就有多个可以独立活动的单位，可以加快进程处理的速度，进一步提高系统的并行处理能力。\n①线程是进程中的一条执行路径；②它有自己私用的堆栈和处理机执行环境（尤其是处理器寄存器）；③它共享分配给父进程的主存；④它是单个进程所创建的许多个同时存在的线程中的一个。\n进程和线程既有联系又有区别，对于进程的组成，可以高度概括为以下几个方面：①一个可执行程序，它定义了初始代码和数据；②一个私用地址空间（addressspace），它使进程可以使用的一组虚拟主存地址；③进程执行时所需的系统资源（如文件、信号灯、通信端口等），是由操作系统分配给进程的；④若系统支持线程运行，那么每个进程至少有一个执行线程。进程是任务调度的单位，也是系统资源的分配单位；而线程是进程中的一条执行路径，当系统支持多线程处理时，线程是任务调度的单位，但不是系统资源的分配单位。线程完全继承父进程占有的资源，当它活动时，具有自己的运行现场。\n相对进程而言，线程的创建与管理的开销要小得多。因为线程可以共享父进程的所有程序和全局数据，这意味着创建一个新线程只涉及最小量的主存分配（线程表），也意味着一个进程创建的多个线程可以共享地址区域和数据。在进程内创建多线程，可以提高系统的并行处理能力。例如，一个文件服务器，某时刻它正好封锁在等待磁盘操作上，如果这个服务器进程具有多个控制线程，那么当另一个线程在等待磁盘操作时，第二个线程就可以运行，比如它又可接收一个新的文件服务请求。这样可以提高系统的性能。\n\n## 处理机调度\n\n### 多级调度\n\n1．批处理系统中的处理机调度\n在多用户批处理操作系统中，对处理机的分配分为两级：作业调度和进程调度。在这样的系统中，每个用户提交的算题任务，往往作为系统的一个处理单位，称为作业。这样一道作业在处理过程中又可以分为多个并发的活动单位，称为进程。作业调度又称为宏观调度，其任务是对提交给系统的、存放在辅存设备上的大量作业，以一定的策略进行挑选，分配主存等必要的资源，建立作业对应的进程，使其投入运行。进入主存中的进程还可以根据需要创建子进程。作业调度使该作业对应的进程具备使用处理机的权利。而进入主存的诸进程，分别在什么时候真正获得处理机，这是由处理机的进程调度（一般又称为微观调度）来决定的。进程调度的对象是进程，其任务是在进入主存的所有进程中，确定哪个进程在什么时候获得处理机，使用多长时间等。\n2．多任务操作系统中的处理机调度\n3．多线程操作系统中的处理机调度\n在现代操作系统中，有些系统支持多线程运行。在这样的系统中，一个进程可以创建一个线程，也可以创建多个线程。系统为进程分配它所需要的资源（如主存），而处理机的分配单位则为线程，系统提供线程调度程序，其功能是当处理机空闲时，以某种策略选择一个就绪线程去运行，并为它分配处理机时间。\n\n### 作业调度算法\n\n1．先来先服务调度算法\n2．短作业优先调度算法\n3．响应比高者优先调度算法\n4．优先调度算法\n\n### 进程调度\n\n#### 调度／分派结构\n\n任何进程都必须通过调度／分派模块来使用处理机。进程调度的功能可细分为调度和分派两部分。其中，调度意味着依照完全确定的策略将一批进程进行排序，而分派则是从就绪队列中移出一个进程并给它提供处理机的使用权。相应的调度程序和分派程序的功能是：调度程序负责将一个进程插入到就绪队列并按一定原则保持队列结构；分派程序是将进程从就绪队列中移出并建立该进程执行的机器状态。\n但是，在一些系统中常常只提进程调度的概念，而不细分调度和分派这两个部分。因为这里所说的调度功能实际上分散到某些进程控制原语或通信原语中实现了，所以在这些系统中，调度与分派之间不加区别，并统称为调度程序模块。在这里提出调度／分派结构，是希望读者明确处理机的分配包含有两方面内容：一是按确定的调度原则选一个进程；二是给选中进程赋予处理机的控制权。若要强调后者，就使用“分派程序”这一名词；否则就采用“进程调度程序”这一名词。\n\n- CPU现场信息的切换\n  CPU现场信息的切换（即保留原来运行进程的状态信息，并用保留在选中进程PCB中的状态信息设置CPU现场）所需时间是额外开销，因为切换时系统并不能做其他的工作。进程切换所需时间因机器不同而不同，它取决于主存速度、必须复制的寄存器的数量、是否有特殊指令（如装入或保存所有单个指令）等因素。切换时间与硬件支持密切相关。例如，有的处理器（如SUNUltraSPARC）提供了多个寄存器组，切换只需要简单地改变当前寄存器组的指针。当处理器只有一个寄存器组，或活动进程超过了寄存器组的数量时，系统必须在寄存器组与主存之间进行数据复制。而且，操作系统越复杂，这一切换所要做的工作就越多。典型的进程切换时间为1μs到1000μs。进程调度时机可能有以下几种：①进程完成其任务时；②在一次管理程序调用之后，该调用使现行程序暂时不能继续运行时；③在一次出错陷入之后，该陷入使现行进程在出错处理时被挂起时；④在分时系统中，当进程使用完规定的时间片，时钟中断使该进程让出处理机时；⑤在采用可剥夺调度方式的系统中，当具有更高优先级的进程要求处理机时。\n- 进程调度的准则\n  不同的进程调度算法具有不同的特点，且可能对某些进程更有利。为了对算法进行选择以适用于特定的应用，必须分析各种算法的特点。为了比较各种进程调度算法，分析员提出了许多准则，这些准则对确定算法的优劣有很大的影响，这些准则涉及如下几个因素。（1）CPU使用率。需要使CPU尽可能忙。CPU使用率从0到100％。对于真实系统，它应从40％（轻负荷系统）到90％（重负荷系统）。（2）吞吐量。如果CPU忙于执行进程，那么就要评估其工作量。其中一种测量工作量的方法称为吞吐量。吞吐量是指一个时间单元内所完成的进程数量。若系统中短进程多，则吞吐量较高，可能为每秒十个进程。（3）周转时间。在批处理系统中，从作业进入系统到完成的时间间隔称为周转时间。周转时间是所有时间段之和，包括等待进入主存、在就绪队列中等待、在CPU上执行和I/O执行时间。利用特权可以分析运行该作业需要花费的时间。（4）响应时间。对于交互式系统而言，周转时间并不是最佳的准则，通常采用响应时间作为时间度量。响应时间是指从联机用户向计算机发出一个命令到计算机执行完该命令，并将相应的执行结果返回给用户所需的时间。（5）等待时间。进程调度算法并不影响进程运行和执行I/O的时间量，它只影响进程在就绪队列中等待所花费的时间。等待时间是进程在就绪队列中等待所花费时间之和。人们需要使CPU使用率和吞吐量最大化，而使周转时间、响应时间和等待时间最小化。在绝大多数情况下要优化平均度量值，不过在有的情况下，需要优化最小值或最大值，而不是平均值。例如，在分时系统中为了保证所有用户都得到好的服务，可能需要使响应时间最小。\n- 调度方式\n  在优先调度策略下还要确定调度方式。所谓调度方式是指，当一进程正在处理机上执行时，若有某个更为“重要而紧迫”的进程需要进行处理，亦即，若有优先级更高的进程进入就绪队列时，如何分配处理机。通常有两种进程调度方式：一种是仍然让正在执行的进程继续执行，直到该进程完成或发生某事件（如提出I/O请求）而进入“完成”或“阻塞”状态时，才把处理机分配给“重要而紧迫”的进程，使之执行，这种进程调度方式称为非剥夺方式；另一种方式则是“重要而紧迫”的进程一到，便暂停正在执行的进程，立即把处理机分配给它，这种方式称为可剥夺调度方式。后者所实施的策略就是可抢占的调度策略。\n- 进程优先数调度\n  进程优先数调度算法就是一种优先调度，该算法预先确定各进程的优先数，系统将处理机的使用权赋予就绪队列中具备最高优先级（优先数和一定的优先级相对应）的就绪进程。这种算法又可分为不可抢占CPU与可抢占CPU两种情况。在后一种情况下，无论何时，执行着的进程的优先级总要比就绪队列中的任何进程的优先级高。\n\n## 主存管理\n\n### 空间分片\n\n现代操作系统区分两类主存：物理主存和逻辑主存。主存共享的基础当然是物理主存。物理主存由0～m-1个物理地址组成。物理地址是计算机主存单元的真实地址，又称为绝对地址或实地址。处理机依据绝对地址可以随机存取存放在其内的信息。物理地址的集合所对应的空间组成了主存空间。而主存中的一个区域是物理地址集合的一个递增整数序列子集{n，n+1，…，n+m}所对应的主存空间。\n在多用户多进程系统中，主存以分片方式实现共享。主存中分片的方式有两种：一是划分为大小不等的区域，这些区域根据用户程序实际需要而被分割；二是划分为大小相等的块，以块为单位进行分配，操作系统和用户程序根据需要占用若干主存块。前者一般称为按区（或按段）分配，后者称为按页分配。这些分配方法是实现主存共享的主要方法。\n\n### 主存管理的功能\n\n如果直接以物理地址提交给用户使用，这对用户来说是十分困难的事。而且，多个用户程序共享主存，由用户自行分配主存更是不可能的事。为了支持多道程序运行，方便用户使用，系统必须为每个用户提供0～n-1的一组逻辑地址（虚地址），即提供一个虚拟地址空间。每个应用程序相信它的主存是由0单元开始的一组连续地址组成。用户的程序地址（指令地址或操作数地址）均为逻辑地址。对于每个逻辑地址，在主存中并没有一个固定的、真实的物理单元与之对应。因此，根据逻辑地址还不能直接到主存中去存取信息，它是一个虚地址或称为相对地址。用户所看到的虚存（逻辑地址）与被共享的主存（物理地址）之间有一定的映射关系。程序执行时，必须将逻辑地址正确地转换为物理地址，此即为地址映射。假定虚存空间由n表示，主存空间由m表示，那么地址映射可表示成：f：n→m。为了支持多道程序运行，主存管理必须实现主存分配、主存保护、主存扩充等功能。因此，存储管理的功能可归纳为以下几点：①映射逻辑地址到物理主存地址；②在多用户之间分配物理主存；③对各用户区的信息提供保护措施；④扩充逻辑主存区。\n\n#### 虚拟存储器\n\n随着科学技术的不断进步和计算机应用的日益广泛，需要计算机解决的问题越来越多、越来越复杂。有些科学计算或数据处理的问题需要相当大的主存容量，尤其在多道程序系统中主存容量显得更为紧张。当系统提供大容量的辅存时，操作系统把主存和辅存统一管理，实现信息的自动移动和覆盖。当一个用户程序的地址空间比主存可用空间大时，操作系统将这个程序的地址空间的一部分放入主存内，而其余部分放在辅存上。当所访问的信息不在主存时，则由操作系统负责调入所需要的部分。由于大多数程序执行时，在一段时间内仅使用它的程序编码的一部分，即并不需要在全部时间内将该程序的全部指令和数据都放在主存中，所以，程序的地址空间部分装入主存时，它还能正确地执行，此即为程序的局部性特征。\n虚拟存储器（virtualmemory）将用户的逻辑主存与物理主存分开，这是现代计算机对虚存的实质性的描述。更为一般的描述是：计算机系统在处理应用程序时，只装入部分程序代码和数据就启动其运行，由操作系统和硬件相配合完成主存和外围联机存储器之间的信息的动态调度，这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器。之所以称它为虚拟存储器，是因为这样的存储器实际上并不存在，只是由于系统提供了自动覆盖功能后，给用户造成的一种虚拟的感觉，仿佛有一个很大的主存供他使用一样。\n虚拟存储器的核心问题是将程序的访问地址和主存的可用地址相脱离。程序的访问地址称为虚地址，它可以访问的虚地址范围叫做程序的虚地址空间V，虚地址范围是由虚地址寄存器的位数决定的。在指定的计算机系统中，可使用的实地址范围叫做计算机的实地址空间R。当然，虚地址空间可以比实地址空间大，也可以比实际主存小。在多道程序运行环境下，操作系统把实际主存扩充成若干个虚存，系统可以为每个应用程序建立一个虚存。这样每个应用可以在自己的地址空间中编制程序，在各自的虚存上运行。引入虚存概念后，用户无需了解实存的物理性能，只需在自己的虚存上编制程序，这给用户带来了极大的方便。主存空间的分配由系统完成；逻辑地址转换成物理地址是通过地址变换机构自动完成的，这样，既消除了普通用户对主存分配细节、具体问题了解的困难，方便了用户，又能根据主存的情况和应用程序的实际需要进行动态分配，从而充分利用了主存。而且，多道程序设计所要求的存储保护、程序浮动都可以很方便地实现。必须指出，实现虚拟存储技术，需要有一定的物质基础。其一是需要有相当容量的辅存，以便足以存放多用户的作业的地址空间；其二是要有一定容量的主存；其三是地址变换机构。\n\n### 分区存储管理\n\n分区存储管理是满足多道程序设计的最简单的一种存储管理方法。它允许多个用户作业共享主存空间，这些作业在主存内是以划分分区而共存的。早期的分区存储管理技术只有固定式分区方法，后来才发展形成动态分区方法。\n分区存储管理技术能满足多道程序设计的需要，但它也存在着一个非常严重的碎片问题。解决这个问题的办法之一是采用拼接技术。所谓拼接技术是指移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲区，拼接要消耗大量的系统资源，且有时为拼接所花费的系统开销要大于拼接所得到的效益，因而这种方法的使用受到了限制。\n\n### 页式存储管理\n\n为了寻找解决碎片问题的新途径，人们很容易想到能否避开程序对连续连续性的要求，让程序的地址空间去适应存储器的现状。例如，有一个作业要求投入运行，其程序的地址空间为3KB，而主存当前只有两个各为1KB和2KB的空闲区。显然，每个空闲区的大小都比该程序的地址空间小，而总和却同它相等。这时可以把该程序存放到主存中这两个不相邻的区域中。这正是分页的思想。\n在分页存储管理方法中，主存被等分成一系列的块，程序的地址空间被等分成一系列的页面，然后将页面存放到主存块中。为了便于实现动态地址变换，一般主存的块和页面大小相等且为2的幂次。\n另外，在按区分配方案中，当作业程序的地址空间小于主存可用空间时，该作业是不能投入运行的，即不能方便地实现主存扩充。但是，在页式系统中则可方便地支持虚拟存储，扩充主存，因为它不需限定作业在投入运行之前必须把它的全部地址空间装入主存，而只要求把当前所需要的一部分页面装入主存即可。这样，对虚地址空间的限制，至少从理论上来说被取消了。换句话说，这种系统为用户提供了一个很大的地址空间。但系统必须完成主存和辅存之间的信息的自动调度。因为，一个作业的全部页面存放在辅存上，当它投入运行时，只是将运行进程的部分页面装入主存（这些页面称为活动页面），在进程活动期间，系统根据其需要再从辅存调入所需的页面。\n\n#### 页表\n\n程序的虚地址空间划分为若干页，并被装入主存的空闲块中。于是，一个连续的程序空间在主存中可能是不连续的。为了保证程序能正确地运行，必须在执行每条指令时将程序中的逻辑地址变换为实际的物理地址，即进行动态重定位。在页式系统中，实现这种地址变换的机构称为页面映像表，简称页表。在页式系统中，当程序按页划分装入存储器时，操作系统为该程序建立一个页表。页表是记录程序虚页与其在主存中块（实页）的对应关系的数据结构。页表中的每一个数据项用来描述页面在主存中的物理块号以及页面的使用特性（根据需要扩充页表的功能）。在简单的页式系统中，页表只是虚页和主存物理块的对照表。\n页表可由高速缓冲存储器组成，这样做的结果是，地址变换速度快，但成本较高。另一个办法是在主存固定区域内，用存储单元来存放页表。这种方法要占用一部分主存空间，而且地址变换速度较慢。现代的计算机系统采用硬件与主存页表相结合的方法实现地址变换。\n\n![](./操作系统原理/9.jpg)根据实际使用的经验，一般页面尺寸为1KB、2KB或4KB。\n当请求调页程序要调进一个页面、而此时该作业所分得的主存块已全部用完，则必须淘汰该作业已在主存中的一个页。这时，就产生了在诸页面中淘汰哪个页面的实际问题，这也就涉及淘汰算法即置换算法的问题。算法设计不好将造成巨大系统开销，称为颠簸。\n\n### 段式系统\n\n在前述的分区存储管理和页式系统中，程序的地址空间是一维线性的，因为指令或操作数地址只要给出一个信息量即可决定。分区存储管理方法易出现碎片。页式系统中一页或页号相连的几个虚页上存放的内容一般都不是一个逻辑意义完整的信息单位。请调一页，可能只用到页中的一部分内容。这种情况，对于要调用许多子程序的大型用户程序来说，仍然会感到感到主存空间的使用效率不高。为此，提出了段式存储管理技术。在这样的系统中作业的地址空间由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，它是一个连续的地址区。在主存中，每个分段占一分区。由于分段是一个有意义的信息单位，所以分段的共享和对分段的保护更有意义，同时也容易实现。\n\n### 段页式存储管理\n\n在段式存储管理中结合分页存储管理技术，即在程序地址空间内分段，在一个分段内划分页面，这就形成了段页式存储管理。具有段页式地址结构的用户地址空间。\n段页式存储管理的用户地址空间是二维的、按段划分的。在段中再划分成若干大小相等的页。这样，地址结构就由段号、段内页号和页内位移三部分组成。用户使用的仍是段号和段内相对地址，由地址变换机构自动将段内相对地址的高几位解释为段内页号，将剩余的低位解释为页内位移。用户地址空间的最小单位不是段而是页，而主存按页的大小划分，按页装入。这样，一个段可以装入到若干个不连续的主存块内，段的大小不再受主存可用区的限制了。\n\n![](./操作系统原理/10.jpg)段页式地址变换中要得到物理地址须经过三次主存访问（若段表、页表都在主存），第一次访问段表，得到页表起始地址；第二次访问页表，得到主存块号；第三次将主存块号与页内位移组合，得到物理地址。可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但在方便用户和提高存储器利用率上很好地实现了存储管理的目标。\n请求调页策略是在主存和辅存之间传送存储页，而不是整个进程。这样，整个进程并不需要全部驻留在主存中就可运行，即当进程访问页面时，核心为进程装入该页。请求调页的优点是，它使进程的虚地址空间到机器的物理存储空间的映射更为灵活，允许进程的大小比可用的物理存储空间大得多，还允许将更多的进程同时装入主存。\n\n## 输入／输出管理\n\nI/O设备是计算机系统中除中央处理机、主存储器之外的所有其他的设备。\n为了便于用户作业及相应进程在运行期间利用各类设备I/O，管理程序应能屏蔽设备的物理特性，为用户建立虚环境。现代操作系统一般采用“设备独立性”的概念。\n所谓设备独立性是指用户在编制程序时所使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。逻辑设备名是用户自己指定的设备名（或设备号），它是暂时的、可更改的。而物理设备名是系统提供的设备的标准名称，它是永久的、不可更改的。虽然程序在实际执行中必须使用实际的物理设备，就好像程序在主存中一定要使用物理地址一样，但在用户程序中则应避免使用实际的物理名，而采用逻辑设备名。这样做的道理就和用户程序中要使用逻辑地址而不使用物理地址的道理一样。设备管理的任务之一就是把逻辑设备名转换成物理设备名。\n\n### 缓冲技术\n\n- 什么是缓冲\n  缓冲是在两种不同速度的设备之间传输信息时平滑传输过程的常用手段。缓冲器是以硬件的方法来实现缓冲的，它容量较小，是用来暂时存放数据的一种存储装置。从经济上考虑，除了在关键的地方采用少量必要的硬件缓冲器之外，大都采用软件缓冲。软件缓冲区是指在I/O操作期间用来临时存放I/O数据的一块存储区域。缓冲是为了解决中央处理机的速度和I/O设备的速度不匹配的问题而提出来的，缓冲也可用于解决程序所请求的逻辑记录大小和设备的物理记录大小失配的问题，是有效地利用中央处理机的重要技术。下面看看缓冲是如何工作的。当用户要求在某个设备上进行读操作时，从系统中获得一个空的缓冲区，并将一个物理记录读到缓冲区中。当用户要求使用这些数据时，系统将依据逻辑记录特性从缓冲区中提取并发送到用户进程存储区中。当缓冲区空而进程又要从中取数据时该进程被迫等待。此时，操作系统需要重新送数据填满缓冲区，进程则从中取数据继续运行。当用户要求写操作时，先从系统获得一个空缓冲区，并且将一个逻辑记录从用户的进程存储区传送到缓冲区中。若为顺序写请求，则把数据写到缓冲区中，直到它完全装满为止。然后系统将缓冲区的内容作为物理记录文件写到设备上，使缓冲区再次为空。只有在系统还来不及腾空缓冲区之前，进程又企图输出信息时，它才需要等待。\n\n- 使用缓冲的理由\n  1）处理数据流的生产者与消费者之间的速度差异\n  2）协调传输数据大小的不一致\n  3）应用程序的拷贝语义\n\n### 输入／输出控制方式\n\n外部设备在中央处理机的控制之下完成信息的传输。在信息传输中，中央处理机做多少工作、外部设备做多少工作呢？这个问题将决定CPU和I/O设备的并行能力，同时它也取决于软、硬技术的基础。CPU一般通过I/O控制器与物理设备打交道。按照I/O控制器智能化程度的高低，可把I/O设备的控制方式分为四类：循环测试I/O方式、I/O中断方式、DMA方式和通道方式。\n\n- I/O中断方式\n  与循环测试方式相比，I/O中断方式使CPU的利用率大大提高了。但缺点是由于每台设备每次输入／输出一个数据，都要求中断CPU，当系统配置的设备较多时，系统进行中断处理的次数就很多，这会使CPU的有效计算时间大大减少。为减少I/O中断处理对CPU造成的负担，又出现了通道方式和DMA方式。\n\n- 通道方式\n  在大、中型和超级小型机中，一般采用I/O通道控制I/O设备的各种操作。I/O通道是用来控制外部设备与主存之间进行成批数据传输的部件。每个通道可以连接多台外部设备并控制它们的I/O操作。通道有自己的一套简单的指令系统和执行通道程序，通道接收CPU的委托，而又独立于CPU工作。因此，可以把通道看做是一台小型的处理I/O的处理机，或称I/O处理机。\n  与前面两种I/O方式相比，通道方式有更强的I/O处理能力。有关I/O的工作，CPU委托通道去做，当通道完成了I/O任务后，向CPU发中断信号，请求CPU处理。这样就使CPU基本上摆脱了I/O控制工作，并大大提高了CPU与外部设备的并行工作的程度。\n\n- DMA方式\n  在DMA方式中，I/O控制器有更强的功能。它除了具有上述的中断功能外，还有一个DMA控制机构。在DMA控制器的控制下，设备和主存之间可成批地进行数据交换，而不用CPU干预。这样既大大减轻了CPU的负担，也使I/O的数据传送速度大大提高。在DMA方式下，允许DMA控制器“接管”地址线的控制权，而直接控制DMA控制器与主存的数据交换。因此，I/O设备与主存之间的数据传送不需要CPU介入，从而减轻了CPU的负担。\n\n### UNIX系统设备管理的主要特点\n\n  1．将外部设备看做文件，由文件系统统一处理\n  2．系统的设备配置灵活、方便\n  3．使用块设备缓冲技术，提高了文件系统的存取速度块设备的文件存储部分是文件系统存在的介质，而文件系统与用户界面的联系最为密切，故文件系统存取文件的效率是十分重要的。文件系统通过高速缓冲机制存取文件数据，缓冲机制调节核心与文件存储设备之间的数据流。UNIX提供由数据缓冲区组成的高速缓冲，每个缓冲区的大小为512字节。当用户程序要把信息写入文件时，先写入缓冲区里立即返回，由系统作延迟写处理。当用户程序要从磁盘读文件信息时，先要查看在缓冲区缓冲区中有无含有此信息的块，如果有就不必启动磁盘I/O，可立即从缓冲区内取出。这种做法大大加快了文件的访问速度。\n\n- UNIX缓冲区的管理\n  对文件系统的一切存取操作，核心都能通过每次直接从磁盘上读或往磁盘上写来实现。但磁盘的传输速率与CPU的速度相比还是慢的。为了加快系统的响应时间和增加系统的吞吐量，UNIX构造了一个由高速缓冲组成的内部数据缓冲池，以降低磁盘的存取频率。UNIX缓冲管理策略试图将尽可能多的有用数据保存在高速缓冲中。核心体系结构中的高速缓冲模块的位置处于文件子系统与块设备驱动程序之间。当从磁盘中读数据时，核心试图先从高速缓冲区中读。如果数据已在高速缓冲中，核心可以不必启动磁盘I/O。如果数据不在该高速缓冲区中，则核心从磁盘上读数据，并将其暂时保存在缓冲区中。类似地，要往磁盘上写数据时，也先往高速缓冲区中写入，以便核心随后又试图读它时，它能在高速缓冲中。但是，被写在高速缓冲中的数据要延迟写到非往磁盘上写不可的时候才进行。所以，高速缓冲模块的算法实现了数据的预先缓存和延迟发送的功能。\n\n## 文件系统\n\n文件的物理结构：连续文件、串联文件、随机文件、索引文件\n\n### 文件目录\n\n文件系统是用户和外部设备之间的接口和界面。用户可通过文件系统去管理和使用各种设备介质上的信息。文件系统的大部分工作是为了解决“用户所需的信息结构及其操作”与“设备介质的实际结构和I/O指令”之间的差异。用户所希望的信息结构是按照简单的逻辑关系组织在一起的，他们所希望的操作是一些只用名字就能存取所需信息的读写操作。然而，计算机只能使用各种I/O指令去存取相应介质上的信息，其信息结构又是按照设备介质的各自特点组织的。因此，文件系统所要解决的核心问题，就是按照充分发挥主机和外部设备效率的原则，把信息的逻辑结构映像成设备介质上的物理结构，把用户的文件操作转换成相应的I/O指令。转换过程所使用的主要数据结构是文件目录和辅存空间使用情况表。这样，文件目录就将每个文件的符号名和它们在辅存空间的物理地址与有关文件情况的说明信息联系起来了。因此，用户只需向系统提供一个文件符号名，系统就能准确地找出所要的文件来，这就是文件系统的基本功能。实现符号名与具体物理地址之间的转换，其主要环节是查目录。所以，目录的编排应以如何能准确地找到所需的文件为原则，而选择查目录的方法应以查找速度快为准则。\n\n# 感想\n\n无\n","slug":"操作系统原理","published":1,"updated":"2022-11-01T15:53:16.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38wl001jq8t7ei8agunb","content":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《操作系统原理(第4版)》 庞丽萍 华中科技大学出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><h2 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h2><h3 id=\"存储程序式计算机\"><a href=\"#存储程序式计算机\" class=\"headerlink\" title=\"存储程序式计算机\"></a>存储程序式计算机</h3><ul>\n<li>冯·诺依曼计算机体系结构<br><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/1.jpg\"><br>从20世纪40年代至今，计算机体系结构不断地发展变化，但冯·诺依曼计算机体系结构定义的一个存储程序式计算机的家族，几乎是当代所有计算机系统的构成基础（除专门设计用于处理特殊任务的计算机外）。存储程序式计算机由中央处理器（处理器（CPU））、存储器和输入／输出设备组成。所有的单元都通过总线连接，总线分为地址总线和数据总线，分别连接不同的部件。<br>由于冯·诺依曼型计算机的计算模型是顺序过程计算模型，所以它的特点是集中顺序过程，在当代的CPU中，可有32～64个通用寄存器，每个寄存器能够保存一个32位（bit）的数值。通用寄存器可以为功能单元提供操作数，并能接收、保存操作的结果。控制单元负责从主存储器提取指令、分析其类型，并产生信号通知计算机其他部分执行指令所指定的操作。控制单元包含一个程序计数器（programcounter，PC）和一个指令寄存器（instructionregister，IR）。程序计数器指示下一步应该执行的指令，而指令寄存器包含当前指令的拷贝。</li>\n</ul>\n<h3 id=\"操作系统的发展历程\"><a href=\"#操作系统的发展历程\" class=\"headerlink\" title=\"操作系统的发展历程\"></a>操作系统的发展历程</h3><p>操作系统是构成计算机系统的另一个重要的系统软件，它负责管理计算机系统的硬件、软件资源并控制整个计算机的工作流程。</p>\n<ul>\n<li><p>发展历程<br>从1950年至今，操作系统的发展主要经历了如下的几个阶段：①手工操作阶段——无操作系统；②批处理系统——早期批处理、执行系统；③操作系统形成——批处理操作系统、分时操作系统、实时操作系统；④现代操作系统——个人计算机操作系统、网络操作系统、分布式操作系统。</p>\n</li>\n<li><p>中断和通道<br>20世纪60年代初期，硬件获得了两方面的进展：一是通道的引入；二是中断技术的出现。这两项重大成果导致操作系统进入执行系统阶段。通道是一种专用处理部件，它能控制一台或多台外设的工作，负责外部设备与主存之间的信息传输。它一旦被启动，就能独立于CPU运行，这样就可使CPU和通道并行操作，而且CPU和各种外部设备也能并行操作。所谓中断是指当主机接到某种信号信号（如I&#x2F;O设备完成信号）时，马上停止原来的工作，转去处理这一事件，当事件处理完毕，主机又回到原来的工作点继续工作。</p>\n</li>\n<li><p>多道程序<br>中断和通道技术出现以后，I&#x2F;O设备和中央处理机可以并行操作，初步解决了高速处理机和低速外部设备的矛盾，提高了计算机的工作效率。但不久又发现，这种并行是有限度的，并不能完全消除中央处理机对外部传输的等待。比如，一个作业在运行过程中依此输入n批数据，每批输入1000个字符，输入机每输入1000个字符需用1000ms，而处理机处理这些数据则需300ms。可见，尽管处理机具有和外部设备并行工作的能力，但是在这种情况下无法让它多做工作，处理机仍有空闲等待现象。那么，为了提高设备的利用率，能否在系统内同时存放几道程序呢？这就引入了多道程序的概念。<br>多道程序运行的特征是：①多道——计算机主存中同时存放几道相互独立的程序；②宏观上并行——同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕；③微观上串行——从微观上看，主存中的多道程序轮流或分时地占有处理机，交替执行。</p>\n</li>\n<li><p>分时技术<br>当计算机技术和软件技术发展到20世纪60年代中期，由于主机速度不断提高而采用了分时技术，使一台计算机可同时为多个终端用户服务。每个终端用户在自己的终端设备上联机使用计算机，好像自己独占机器一样。</p>\n</li>\n</ul>\n<h3 id=\"操作系统的基本概念\"><a href=\"#操作系统的基本概念\" class=\"headerlink\" title=\"操作系统的基本概念\"></a>操作系统的基本概念</h3><ul>\n<li><p>计算机系统的组成<br><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/2.jpg\"><br>操作系统是一个大型的程序系统，它负责计算机系统软、硬件资源的分配和管理；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境。<br>操作系统是重要的系统软件，只有配置了操作系统这一系统软件后，才使计算机系统体现出系统的完整性和可利用性。当用户要计算机帮助完成其计算任务时，用户仅编制源程序（用户在源程序中，可以利用操作系统提供的系统调用请求操作系统相应的服务），而其余的大量工作，如作业控制、系统资源的合理分配和利用，各种调度策略的制订、人机联系方式等都是由操作系统实施的。所以，操作系统使整个计算机系统实现了高度自动化、高效率、高利用率、高可靠性。操作系统是整个计算机系统的核心。</p>\n</li>\n<li><p>操作系统的资源管理功能<br>操作系统的主要功能是管理系统的软、硬件资源。这些资源按其性质来分，可以归纳为四类：处理机、存储器、外部设备和软件资源。这四类资源就构成了系统程序和用户程序赖以活动的物质基础和工作环境。针对这四类资源，操作系统就有相应的资源管理程序：处理机管理、存储管理、设备管理和软件资源管理程序。这些资源管理程序组成了操作系统这一程序系统。</p>\n</li>\n<li><p>操作系统的基本类型<br>（1）批量操作系统；（2）分时操作系统；（3）实时操作系统；（4）个人计算机操作系统；（5）网络操作系统；（6）分布式操作系统。</p>\n</li>\n</ul>\n<h2 id=\"操作系统的组织结构\"><a href=\"#操作系统的组织结构\" class=\"headerlink\" title=\"操作系统的组织结构\"></a>操作系统的组织结构</h2><h3 id=\"操作系统虚拟机\"><a href=\"#操作系统虚拟机\" class=\"headerlink\" title=\"操作系统虚拟机\"></a>操作系统虚拟机</h3><p>在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。扩充后的虚拟机不仅可以使用原来裸机提供的各种基本硬件指令，而且还可使用操作系统中所增加的许多其他“指令”。这些指令统称为扩充机器的指令系统，又称为操作命令语言。<br>  <img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/3.jpg\"><br>操作系统虚拟机提供了协助用户解决问题的装置，其功能是通过它提供的命令来体现的，用户也是通过这一组命令和操作系统虚拟机打交道的。系统所提供的全部操作命令的集合称为操作命令语言，它是用户和系统进行通信的手段和界面。这一用户界面分为两个方面：操作命令（又称命令接口）和系统功能调用（又称程序接口）。<br>操作系统在计算机系统中所处的位置是硬件层（裸机）和其他所有软件之间，是所有软件中与硬件相连的第一层软件，它在裸机上运行，又是系统<br>软件和应用程序运行的基础。它与硬件、应用程序和用户都有接口。具有一体化结构的操作系统提供的接口如下图所示，从该结构中可以看出操作系统提供的多种接口。<br>  <img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/4.jpg\" alt=\"loading-ag-517\"></p>\n<h3 id=\"处理机的状态\"><a href=\"#处理机的状态\" class=\"headerlink\" title=\"处理机的状态\"></a>处理机的状态</h3><p>操作系统是计算机系统中最重要的系统软件，为了能正确地进行管理和控制，其本身是不能被破坏的。为此，系统应能建立一个保护环境，采用的办法是区分处理机的工作状态。因为，在系统中有两类程序在运行，一类是管理程序（如处理机调度程序、主存分配程序、I&#x2F;O管理程序等）；另一类是用户程序。这两类程序是不同的，前者是管理和控制者，它负责管理和分配系统资源，为用户提供服务。而用户程序运行时，所需资源必须向操作系统提出请求，自己不能随意取用系统资源，如直接启动外部设备进行工作，更不能改变机器状态等。这两类不同程序执行时应有不同的权限，为此根据对资源和机器指令的使用权限，将处理执行时的工作状态区分为不同的状态（或称为模式）。所谓处理机的态，就是处理机当前处于何种状态，正在执行哪类程序。为了保护操作系统，至少需要区分两种状态：管态和用户态。管态（supervisormode）：又称为系统态，是操作系统的管理程序执行时机器所处的状态。在此状态下允许中央处理机使用全部系统资源和全部指令，其中包括一组特权指令（例如，涉及外部设备的输入／输出指令、改变机器状态或修改存储保护的某些指令），允许访问整个存储区。用户态（usermode）：又称为目态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用系统资源与改变机器状态，并且只允许用户程序访问自己的存储区域。有的系统将管理程序执行时的机器状态进一步分为核态和管态，这时，管态的权限有所变化，管态只允许使用一些在用户态下所不能使用的资源，但不能使用修改机器的状态指令。而核态（kernelmode）就具有上述管态所具有的所有权限。无核态的系统，管态执行核态的全部功能。管态比核态权限要低，用户态的权限更低。为了区分处理机的工作状态，需要硬件的支持。在计算机状态寄存器中需设置一个系统状态位（或称模式位）。若有了系统状态位，就可以区分当前正在执行的是系统程序还是用户程序。<strong>若用户程序执行时，超出了它的权限，如要访问操作系统核心数据或企图执行一个特权指令，都将从用户态转为管态，由操作系统得到CPU控制权，处理这一非法操作。这样可以有效地保护操作系统不受破坏。当用户程序执行时，若需要请求操作系统服务，则要通过一种受控方式进入操作系统，将用户态转为核态，由操作系统得到控制权，在核态下执行其相应的服务例程，服务完毕后，返回到用户态，让用户继续执行。</strong></p>\n<h3 id=\"中断机制\"><a href=\"#中断机制\" class=\"headerlink\" title=\"中断机制\"></a>中断机制</h3><p>所谓中断是指某个事件（例如电源掉电、定点加法溢出或I&#x2F;O传输结束等）发生时，系统中止现行程序的运行、引出处理该事件程序进行处理，处理完毕后返回断点，继续执行。<br>  <img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/5.jpg\"><br>中断响应的实质是交换指令执行地址和处理器状态，以达到如下目的：①保留程序断点及有关信息；②自动转入相应的中断处理程序执行。中断响应所需的硬件支持包括：指令计数器、处理器状态寄存器、中断向量表和系统堆栈。<br>整个中断处理的功能是由硬件和软件配合完成的。硬件负责中断进入过程，即发现和响应中断请求，把中断的原因和断点记下来供软件处理时查用，同时负责引出中断处理程序。而中断分析、中断处理、恢复被中断程序的现场等工作则由软件的中断处理程序来完成。<br>java里数组越界的一场应该算一种中断。</p>\n<h3 id=\"UNIX系统结构\"><a href=\"#UNIX系统结构\" class=\"headerlink\" title=\"UNIX系统结构\"></a>UNIX系统结构</h3><p>UNIX系统核心层的功能包括文件管理、设备管理、存储管理和处理机管理，此外还有中断和俘获的处理。<strong>现代计算机系统的硬件机构支持核心态和用户态，使得核心程序在核心态下运行，实用程序在用户态下运行。每一种状态都有自己的栈和栈指针，都有自己的地址映射部件。所以，用户态的程序不能直接访问核心态的程序和数据，只能通过访问管理程序指令（访管指令，如trap指令）自陷到核心内的操作系统服务程序。<br>UNIX系统的核心结构是一体化结构。</strong><br><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/6.jpg\" alt=\"loading-ag-518\"></p>\n<h3 id=\"静态连接和动态链接\"><a href=\"#静态连接和动态链接\" class=\"headerlink\" title=\"静态连接和动态链接\"></a>静态连接和动态链接</h3><p>连接这一处理步骤，以前通常采用静态连接方式。静态连接是将所需的外部调用函数连接到目标文件中形成一个完整的主存映像文件。采用这种静态连接的缺点是，当有多个应用程序都需要调用同一个库函数时，那么，这些应用程序的目标文件中都将包含这个外部函数对应的代码。这将造成主存的极大浪费，不能支持有效的共享。动态链接是将这一连接工作延迟到程序运行的时候进行。它需要的支持是动态链接库（DLL）。动态链接不需要将应用程序所需要的外部函数代码从库中提取出来并连接到目标文件中，而是在应用程序需要调用外部函数的地方作记录，并说明要使用的外部函数名和引用入口号，形成调用链表。当所需的动态链接库DLL在主存时，就可以确定所需函数的主存绝对地址，并将它填入调用链表相应位置中。当应用程序运行时，就可以正确地引用这个外部函数了。现代操作系统有的已采用了动态链接技术，如Windows系统，现在的动态链接库一般是系统库。</p>\n<h3 id=\"操作系统提供的用户界面\"><a href=\"#操作系统提供的用户界面\" class=\"headerlink\" title=\"操作系统提供的用户界面\"></a>操作系统提供的用户界面</h3><p>操作系统提供的用户界面如下图所示：一是操作界面，又称为操作命令；二是程序界面，又称为系统功能调用。<br><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/7.jpg\" alt=\"loading-ag-519\"></p>\n<h3 id=\"系统功能调用\"><a href=\"#系统功能调用\" class=\"headerlink\" title=\"系统功能调用\"></a>系统功能调用</h3><p>为了实现在程序级的服务支持，操作系统提供统一的系统功能调用，采用统一的调用方式——访问管理程序来实现对这些功能的调用。<br><strong>对于用户所需要的功能，由系统设计者事先编制好能实现这些功能的例行子程序，作为操作系统程序模块的一部分。这些例行子程序不能像一般的用户子程序那样可随便调用，因为这些能实现各种功能的例行子程序是操作系统的程序部分，它运行时，机器处于管态（管理程序状态），而用户程序运行时，机器处于用户态。所以，用户程序对这些例行子程序的调用应以一种特殊的调用方式——访管方式来实现。</strong><br>这样一个带有一定功能号的访管指令定义了一个系统调用。因此，系统调用是用户在程序一级请求操作系统服务的一种手段，它不是一条简单的硬指令，而是带有一定功能号的访管指令。它的功能并非由硬件直接提供，而是由操作系统中的一段程序完成的，即由软件方法实现的。用户可以用带有不同功能号的访管指令来请求各种不同的功能。可以这样说，系统调用是利用访管指令定义的指令。操作系统服务例程与一般子程序的区别在于，前者所实现的功能都是与计算机系统本身有关的，对前者的调用是通过一条访管指令来实现的。不同的程序设计语言调用操作系统服务的方式是不同的，它们有显式调用和隐式调用之分。<strong>在汇编语言中是直接使用系统调用对操作系统提出各种要求的，因为在这种情况下，系统调用具有汇编指令的形式。而在高级语言中一般是隐式的调用（经编译后转成某种直接调用）。</strong></p>\n<h2 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h2><h3 id=\"进程概念\"><a href=\"#进程概念\" class=\"headerlink\" title=\"进程概念\"></a>进程概念</h3><h4 id=\"进程定义\"><a href=\"#进程定义\" class=\"headerlink\" title=\"进程定义\"></a>进程定义</h4><p>根据1978年在庐山召开的全国操作系统会议上关于进程的讨论，结合国外的各种观点，国内对进程这一概念作了如下描述：进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动。<br>进程和程序是既有联系又有区别的两个概念，它们的区别如下。（1）程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态概念。而进程是程序在处理机上的一次执行过程，它是一动态概念。程序可以作为一种软件资料长期保存，而进程则是有一定生命期的，它能够动态地产生和消亡。即进程可由“创建”而产生，由调度而执行，因得不到资源而暂停，以致最后由“撤销”而消亡。（2）进程是一个能独立运行的单位，能与其他进程并行地活动。（3）进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。<br>进程和程序又是有联系的。在支持多任务运行的操作系统中，活动的最小单位是进程。进程一定包含一个程序，因为程序是进程应完成功能的逻辑描述；而一个程序可以对应多个进程。如果同一程序同时运行于若干不同的数据集合上，它将属于若干个不同的进程。或者说，若干不同的进程可以包含相同的程序。这句话的意思是：用同一程序对不同的数据先后或同时加以处理，就对应于好几个进程。例如，系统具有一个C语言编译程序，当它对多个终端用户的C语言源程序进行编译时，就产生了多个编译进程。</p>\n<h4 id=\"进程类型\"><a href=\"#进程类型\" class=\"headerlink\" title=\"进程类型\"></a>进程类型</h4><p>有些进程起着资源管理和控制的作用，称为系统进程；而另一些是为用户算题任务而建立的进程称为用户进程。它们是有区别的。①系统进程被分配一个初始的资源集合，这些资源可为它所独占，也可以最高优先级的资格优先使用。用户进程通过系统服务请求的手段竞争系统资源。②用户进程不能做直接I&#x2F;O操作，而系统进程可以做显示的、直接的I&#x2F;O操作。③系统进程在管态下活动，而用户进程在用户态下活动。</p>\n<h4 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h4><p>进程有着“执行—暂停—执行”的活动规律。一般说来，一个进程并不是自始至终连续不停地运行的，它与并发执行中的其他进程的执行是相互制约的。它有时处于运行状态，有时又由于某种原因而暂停运行处于等待状态，当使它暂停的原因消失后，它又进入准备运行状态。所以，在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、等待状态（又称阻塞状态）。①就绪状态（ready）。当进程获得了除CPU之外所有的资源，它已经准备就绪，一旦得到CPU控制权，就可以立即运行，该进程所处的状态为就绪状态。②运行状态（running）。当进程由调度／分派模块分派后，得到中央处理机控制权，它的程序正在运行，该进程所处的状态为运行状态。③等待状态（wait）。若一进程正在等待某一事件发生（如等待输入／输出操作的完成）而暂时停止执行，这时，即使给它CPU控制权，它也无法执行，则称该进程处于等待状态，又可称为阻塞状态。<br>为了描述一个进程和其他进程以及系统资源的关系，为了刻画一个进程在各个不同时期所处的状态，人们采用了一个与进程相联系的数据块，称为进程控制块（processcontrolblock，PCB）或称为进程描述器（processdescriptor）。系统根据pcb而感知进程的存在，故pcb是标识进程存在的实体。当系统创建一个进程时，必须为它设置一个pcb，然后根据pcb的信息对进程实施控制管理。进程任务完成时，系统撤销它的pcb，进程也随之消亡。</p>\n<h4 id=\"线程概念\"><a href=\"#线程概念\" class=\"headerlink\" title=\"线程概念\"></a>线程概念</h4><p>在操作系统中，为了支持并发活动，引入了进程的概念，在传统的操作系统中，每个进程只存在一条控制线索和一个程序计数器。但在有些现代操作系统中，提供了对单个进程中多条控制线索的支持。这些控制线索通常称为线程（threads），有时也称为轻量级进程（lightweightprocesses）。线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多条执行路径，即线程。这样，在一个进程内部就有多个可以独立活动的单位，可以加快进程处理的速度，进一步提高系统的并行处理能力。<br>①线程是进程中的一条执行路径；②它有自己私用的堆栈和处理机执行环境（尤其是处理器寄存器）；③它共享分配给父进程的主存；④它是单个进程所创建的许多个同时存在的线程中的一个。<br>进程和线程既有联系又有区别，对于进程的组成，可以高度概括为以下几个方面：①一个可执行程序，它定义了初始代码和数据；②一个私用地址空间（addressspace），它使进程可以使用的一组虚拟主存地址；③进程执行时所需的系统资源（如文件、信号灯、通信端口等），是由操作系统分配给进程的；④若系统支持线程运行，那么每个进程至少有一个执行线程。进程是任务调度的单位，也是系统资源的分配单位；而线程是进程中的一条执行路径，当系统支持多线程处理时，线程是任务调度的单位，但不是系统资源的分配单位。线程完全继承父进程占有的资源，当它活动时，具有自己的运行现场。<br>相对进程而言，线程的创建与管理的开销要小得多。因为线程可以共享父进程的所有程序和全局数据，这意味着创建一个新线程只涉及最小量的主存分配（线程表），也意味着一个进程创建的多个线程可以共享地址区域和数据。在进程内创建多线程，可以提高系统的并行处理能力。例如，一个文件服务器，某时刻它正好封锁在等待磁盘操作上，如果这个服务器进程具有多个控制线程，那么当另一个线程在等待磁盘操作时，第二个线程就可以运行，比如它又可接收一个新的文件服务请求。这样可以提高系统的性能。</p>\n<h2 id=\"处理机调度\"><a href=\"#处理机调度\" class=\"headerlink\" title=\"处理机调度\"></a>处理机调度</h2><h3 id=\"多级调度\"><a href=\"#多级调度\" class=\"headerlink\" title=\"多级调度\"></a>多级调度</h3><p>1．批处理系统中的处理机调度<br>在多用户批处理操作系统中，对处理机的分配分为两级：作业调度和进程调度。在这样的系统中，每个用户提交的算题任务，往往作为系统的一个处理单位，称为作业。这样一道作业在处理过程中又可以分为多个并发的活动单位，称为进程。作业调度又称为宏观调度，其任务是对提交给系统的、存放在辅存设备上的大量作业，以一定的策略进行挑选，分配主存等必要的资源，建立作业对应的进程，使其投入运行。进入主存中的进程还可以根据需要创建子进程。作业调度使该作业对应的进程具备使用处理机的权利。而进入主存的诸进程，分别在什么时候真正获得处理机，这是由处理机的进程调度（一般又称为微观调度）来决定的。进程调度的对象是进程，其任务是在进入主存的所有进程中，确定哪个进程在什么时候获得处理机，使用多长时间等。<br>2．多任务操作系统中的处理机调度<br>3．多线程操作系统中的处理机调度<br>在现代操作系统中，有些系统支持多线程运行。在这样的系统中，一个进程可以创建一个线程，也可以创建多个线程。系统为进程分配它所需要的资源（如主存），而处理机的分配单位则为线程，系统提供线程调度程序，其功能是当处理机空闲时，以某种策略选择一个就绪线程去运行，并为它分配处理机时间。</p>\n<h3 id=\"作业调度算法\"><a href=\"#作业调度算法\" class=\"headerlink\" title=\"作业调度算法\"></a>作业调度算法</h3><p>1．先来先服务调度算法<br>2．短作业优先调度算法<br>3．响应比高者优先调度算法<br>4．优先调度算法</p>\n<h3 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h3><h4 id=\"调度／分派结构\"><a href=\"#调度／分派结构\" class=\"headerlink\" title=\"调度／分派结构\"></a>调度／分派结构</h4><p>任何进程都必须通过调度／分派模块来使用处理机。进程调度的功能可细分为调度和分派两部分。其中，调度意味着依照完全确定的策略将一批进程进行排序，而分派则是从就绪队列中移出一个进程并给它提供处理机的使用权。相应的调度程序和分派程序的功能是：调度程序负责将一个进程插入到就绪队列并按一定原则保持队列结构；分派程序是将进程从就绪队列中移出并建立该进程执行的机器状态。<br>但是，在一些系统中常常只提进程调度的概念，而不细分调度和分派这两个部分。因为这里所说的调度功能实际上分散到某些进程控制原语或通信原语中实现了，所以在这些系统中，调度与分派之间不加区别，并统称为调度程序模块。在这里提出调度／分派结构，是希望读者明确处理机的分配包含有两方面内容：一是按确定的调度原则选一个进程；二是给选中进程赋予处理机的控制权。若要强调后者，就使用“分派程序”这一名词；否则就采用“进程调度程序”这一名词。</p>\n<ul>\n<li>CPU现场信息的切换<br>CPU现场信息的切换（即保留原来运行进程的状态信息，并用保留在选中进程PCB中的状态信息设置CPU现场）所需时间是额外开销，因为切换时系统并不能做其他的工作。进程切换所需时间因机器不同而不同，它取决于主存速度、必须复制的寄存器的数量、是否有特殊指令（如装入或保存所有单个指令）等因素。切换时间与硬件支持密切相关。例如，有的处理器（如SUNUltraSPARC）提供了多个寄存器组，切换只需要简单地改变当前寄存器组的指针。当处理器只有一个寄存器组，或活动进程超过了寄存器组的数量时，系统必须在寄存器组与主存之间进行数据复制。而且，操作系统越复杂，这一切换所要做的工作就越多。典型的进程切换时间为1μs到1000μs。进程调度时机可能有以下几种：①进程完成其任务时；②在一次管理程序调用之后，该调用使现行程序暂时不能继续运行时；③在一次出错陷入之后，该陷入使现行进程在出错处理时被挂起时；④在分时系统中，当进程使用完规定的时间片，时钟中断使该进程让出处理机时；⑤在采用可剥夺调度方式的系统中，当具有更高优先级的进程要求处理机时。</li>\n<li>进程调度的准则<br>不同的进程调度算法具有不同的特点，且可能对某些进程更有利。为了对算法进行选择以适用于特定的应用，必须分析各种算法的特点。为了比较各种进程调度算法，分析员提出了许多准则，这些准则对确定算法的优劣有很大的影响，这些准则涉及如下几个因素。（1）CPU使用率。需要使CPU尽可能忙。CPU使用率从0到100％。对于真实系统，它应从40％（轻负荷系统）到90％（重负荷系统）。（2）吞吐量。如果CPU忙于执行进程，那么就要评估其工作量。其中一种测量工作量的方法称为吞吐量。吞吐量是指一个时间单元内所完成的进程数量。若系统中短进程多，则吞吐量较高，可能为每秒十个进程。（3）周转时间。在批处理系统中，从作业进入系统到完成的时间间隔称为周转时间。周转时间是所有时间段之和，包括等待进入主存、在就绪队列中等待、在CPU上执行和I&#x2F;O执行时间。利用特权可以分析运行该作业需要花费的时间。（4）响应时间。对于交互式系统而言，周转时间并不是最佳的准则，通常采用响应时间作为时间度量。响应时间是指从联机用户向计算机发出一个命令到计算机执行完该命令，并将相应的执行结果返回给用户所需的时间。（5）等待时间。进程调度算法并不影响进程运行和执行I&#x2F;O的时间量，它只影响进程在就绪队列中等待所花费的时间。等待时间是进程在就绪队列中等待所花费时间之和。人们需要使CPU使用率和吞吐量最大化，而使周转时间、响应时间和等待时间最小化。在绝大多数情况下要优化平均度量值，不过在有的情况下，需要优化最小值或最大值，而不是平均值。例如，在分时系统中为了保证所有用户都得到好的服务，可能需要使响应时间最小。</li>\n<li>调度方式<br>在优先调度策略下还要确定调度方式。所谓调度方式是指，当一进程正在处理机上执行时，若有某个更为“重要而紧迫”的进程需要进行处理，亦即，若有优先级更高的进程进入就绪队列时，如何分配处理机。通常有两种进程调度方式：一种是仍然让正在执行的进程继续执行，直到该进程完成或发生某事件（如提出I&#x2F;O请求）而进入“完成”或“阻塞”状态时，才把处理机分配给“重要而紧迫”的进程，使之执行，这种进程调度方式称为非剥夺方式；另一种方式则是“重要而紧迫”的进程一到，便暂停正在执行的进程，立即把处理机分配给它，这种方式称为可剥夺调度方式。后者所实施的策略就是可抢占的调度策略。</li>\n<li>进程优先数调度<br>进程优先数调度算法就是一种优先调度，该算法预先确定各进程的优先数，系统将处理机的使用权赋予就绪队列中具备最高优先级（优先数和一定的优先级相对应）的就绪进程。这种算法又可分为不可抢占CPU与可抢占CPU两种情况。在后一种情况下，无论何时，执行着的进程的优先级总要比就绪队列中的任何进程的优先级高。</li>\n</ul>\n<h2 id=\"主存管理\"><a href=\"#主存管理\" class=\"headerlink\" title=\"主存管理\"></a>主存管理</h2><h3 id=\"空间分片\"><a href=\"#空间分片\" class=\"headerlink\" title=\"空间分片\"></a>空间分片</h3><p>现代操作系统区分两类主存：物理主存和逻辑主存。主存共享的基础当然是物理主存。物理主存由0～m-1个物理地址组成。物理地址是计算机主存单元的真实地址，又称为绝对地址或实地址。处理机依据绝对地址可以随机存取存放在其内的信息。物理地址的集合所对应的空间组成了主存空间。而主存中的一个区域是物理地址集合的一个递增整数序列子集{n，n+1，…，n+m}所对应的主存空间。<br>在多用户多进程系统中，主存以分片方式实现共享。主存中分片的方式有两种：一是划分为大小不等的区域，这些区域根据用户程序实际需要而被分割；二是划分为大小相等的块，以块为单位进行分配，操作系统和用户程序根据需要占用若干主存块。前者一般称为按区（或按段）分配，后者称为按页分配。这些分配方法是实现主存共享的主要方法。</p>\n<h3 id=\"主存管理的功能\"><a href=\"#主存管理的功能\" class=\"headerlink\" title=\"主存管理的功能\"></a>主存管理的功能</h3><p>如果直接以物理地址提交给用户使用，这对用户来说是十分困难的事。而且，多个用户程序共享主存，由用户自行分配主存更是不可能的事。为了支持多道程序运行，方便用户使用，系统必须为每个用户提供0～n-1的一组逻辑地址（虚地址），即提供一个虚拟地址空间。每个应用程序相信它的主存是由0单元开始的一组连续地址组成。用户的程序地址（指令地址或操作数地址）均为逻辑地址。对于每个逻辑地址，在主存中并没有一个固定的、真实的物理单元与之对应。因此，根据逻辑地址还不能直接到主存中去存取信息，它是一个虚地址或称为相对地址。用户所看到的虚存（逻辑地址）与被共享的主存（物理地址）之间有一定的映射关系。程序执行时，必须将逻辑地址正确地转换为物理地址，此即为地址映射。假定虚存空间由n表示，主存空间由m表示，那么地址映射可表示成：f：n→m。为了支持多道程序运行，主存管理必须实现主存分配、主存保护、主存扩充等功能。因此，存储管理的功能可归纳为以下几点：①映射逻辑地址到物理主存地址；②在多用户之间分配物理主存；③对各用户区的信息提供保护措施；④扩充逻辑主存区。</p>\n<h4 id=\"虚拟存储器\"><a href=\"#虚拟存储器\" class=\"headerlink\" title=\"虚拟存储器\"></a>虚拟存储器</h4><p>随着科学技术的不断进步和计算机应用的日益广泛，需要计算机解决的问题越来越多、越来越复杂。有些科学计算或数据处理的问题需要相当大的主存容量，尤其在多道程序系统中主存容量显得更为紧张。当系统提供大容量的辅存时，操作系统把主存和辅存统一管理，实现信息的自动移动和覆盖。当一个用户程序的地址空间比主存可用空间大时，操作系统将这个程序的地址空间的一部分放入主存内，而其余部分放在辅存上。当所访问的信息不在主存时，则由操作系统负责调入所需要的部分。由于大多数程序执行时，在一段时间内仅使用它的程序编码的一部分，即并不需要在全部时间内将该程序的全部指令和数据都放在主存中，所以，程序的地址空间部分装入主存时，它还能正确地执行，此即为程序的局部性特征。<br>虚拟存储器（virtualmemory）将用户的逻辑主存与物理主存分开，这是现代计算机对虚存的实质性的描述。更为一般的描述是：计算机系统在处理应用程序时，只装入部分程序代码和数据就启动其运行，由操作系统和硬件相配合完成主存和外围联机存储器之间的信息的动态调度，这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器。之所以称它为虚拟存储器，是因为这样的存储器实际上并不存在，只是由于系统提供了自动覆盖功能后，给用户造成的一种虚拟的感觉，仿佛有一个很大的主存供他使用一样。<br>虚拟存储器的核心问题是将程序的访问地址和主存的可用地址相脱离。程序的访问地址称为虚地址，它可以访问的虚地址范围叫做程序的虚地址空间V，虚地址范围是由虚地址寄存器的位数决定的。在指定的计算机系统中，可使用的实地址范围叫做计算机的实地址空间R。当然，虚地址空间可以比实地址空间大，也可以比实际主存小。在多道程序运行环境下，操作系统把实际主存扩充成若干个虚存，系统可以为每个应用程序建立一个虚存。这样每个应用可以在自己的地址空间中编制程序，在各自的虚存上运行。引入虚存概念后，用户无需了解实存的物理性能，只需在自己的虚存上编制程序，这给用户带来了极大的方便。主存空间的分配由系统完成；逻辑地址转换成物理地址是通过地址变换机构自动完成的，这样，既消除了普通用户对主存分配细节、具体问题了解的困难，方便了用户，又能根据主存的情况和应用程序的实际需要进行动态分配，从而充分利用了主存。而且，多道程序设计所要求的存储保护、程序浮动都可以很方便地实现。必须指出，实现虚拟存储技术，需要有一定的物质基础。其一是需要有相当容量的辅存，以便足以存放多用户的作业的地址空间；其二是要有一定容量的主存；其三是地址变换机构。</p>\n<h3 id=\"分区存储管理\"><a href=\"#分区存储管理\" class=\"headerlink\" title=\"分区存储管理\"></a>分区存储管理</h3><p>分区存储管理是满足多道程序设计的最简单的一种存储管理方法。它允许多个用户作业共享主存空间，这些作业在主存内是以划分分区而共存的。早期的分区存储管理技术只有固定式分区方法，后来才发展形成动态分区方法。<br>分区存储管理技术能满足多道程序设计的需要，但它也存在着一个非常严重的碎片问题。解决这个问题的办法之一是采用拼接技术。所谓拼接技术是指移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲区，拼接要消耗大量的系统资源，且有时为拼接所花费的系统开销要大于拼接所得到的效益，因而这种方法的使用受到了限制。</p>\n<h3 id=\"页式存储管理\"><a href=\"#页式存储管理\" class=\"headerlink\" title=\"页式存储管理\"></a>页式存储管理</h3><p>为了寻找解决碎片问题的新途径，人们很容易想到能否避开程序对连续连续性的要求，让程序的地址空间去适应存储器的现状。例如，有一个作业要求投入运行，其程序的地址空间为3KB，而主存当前只有两个各为1KB和2KB的空闲区。显然，每个空闲区的大小都比该程序的地址空间小，而总和却同它相等。这时可以把该程序存放到主存中这两个不相邻的区域中。这正是分页的思想。<br>在分页存储管理方法中，主存被等分成一系列的块，程序的地址空间被等分成一系列的页面，然后将页面存放到主存块中。为了便于实现动态地址变换，一般主存的块和页面大小相等且为2的幂次。<br>另外，在按区分配方案中，当作业程序的地址空间小于主存可用空间时，该作业是不能投入运行的，即不能方便地实现主存扩充。但是，在页式系统中则可方便地支持虚拟存储，扩充主存，因为它不需限定作业在投入运行之前必须把它的全部地址空间装入主存，而只要求把当前所需要的一部分页面装入主存即可。这样，对虚地址空间的限制，至少从理论上来说被取消了。换句话说，这种系统为用户提供了一个很大的地址空间。但系统必须完成主存和辅存之间的信息的自动调度。因为，一个作业的全部页面存放在辅存上，当它投入运行时，只是将运行进程的部分页面装入主存（这些页面称为活动页面），在进程活动期间，系统根据其需要再从辅存调入所需的页面。</p>\n<h4 id=\"页表\"><a href=\"#页表\" class=\"headerlink\" title=\"页表\"></a>页表</h4><p>程序的虚地址空间划分为若干页，并被装入主存的空闲块中。于是，一个连续的程序空间在主存中可能是不连续的。为了保证程序能正确地运行，必须在执行每条指令时将程序中的逻辑地址变换为实际的物理地址，即进行动态重定位。在页式系统中，实现这种地址变换的机构称为页面映像表，简称页表。在页式系统中，当程序按页划分装入存储器时，操作系统为该程序建立一个页表。页表是记录程序虚页与其在主存中块（实页）的对应关系的数据结构。页表中的每一个数据项用来描述页面在主存中的物理块号以及页面的使用特性（根据需要扩充页表的功能）。在简单的页式系统中，页表只是虚页和主存物理块的对照表。<br>页表可由高速缓冲存储器组成，这样做的结果是，地址变换速度快，但成本较高。另一个办法是在主存固定区域内，用存储单元来存放页表。这种方法要占用一部分主存空间，而且地址变换速度较慢。现代的计算机系统采用硬件与主存页表相结合的方法实现地址变换。</p>\n<p><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/9.jpg\">根据实际使用的经验，一般页面尺寸为1KB、2KB或4KB。<br>当请求调页程序要调进一个页面、而此时该作业所分得的主存块已全部用完，则必须淘汰该作业已在主存中的一个页。这时，就产生了在诸页面中淘汰哪个页面的实际问题，这也就涉及淘汰算法即置换算法的问题。算法设计不好将造成巨大系统开销，称为颠簸。</p>\n<h3 id=\"段式系统\"><a href=\"#段式系统\" class=\"headerlink\" title=\"段式系统\"></a>段式系统</h3><p>在前述的分区存储管理和页式系统中，程序的地址空间是一维线性的，因为指令或操作数地址只要给出一个信息量即可决定。分区存储管理方法易出现碎片。页式系统中一页或页号相连的几个虚页上存放的内容一般都不是一个逻辑意义完整的信息单位。请调一页，可能只用到页中的一部分内容。这种情况，对于要调用许多子程序的大型用户程序来说，仍然会感到感到主存空间的使用效率不高。为此，提出了段式存储管理技术。在这样的系统中作业的地址空间由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，它是一个连续的地址区。在主存中，每个分段占一分区。由于分段是一个有意义的信息单位，所以分段的共享和对分段的保护更有意义，同时也容易实现。</p>\n<h3 id=\"段页式存储管理\"><a href=\"#段页式存储管理\" class=\"headerlink\" title=\"段页式存储管理\"></a>段页式存储管理</h3><p>在段式存储管理中结合分页存储管理技术，即在程序地址空间内分段，在一个分段内划分页面，这就形成了段页式存储管理。具有段页式地址结构的用户地址空间。<br>段页式存储管理的用户地址空间是二维的、按段划分的。在段中再划分成若干大小相等的页。这样，地址结构就由段号、段内页号和页内位移三部分组成。用户使用的仍是段号和段内相对地址，由地址变换机构自动将段内相对地址的高几位解释为段内页号，将剩余的低位解释为页内位移。用户地址空间的最小单位不是段而是页，而主存按页的大小划分，按页装入。这样，一个段可以装入到若干个不连续的主存块内，段的大小不再受主存可用区的限制了。</p>\n<p><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/10.jpg\">段页式地址变换中要得到物理地址须经过三次主存访问（若段表、页表都在主存），第一次访问段表，得到页表起始地址；第二次访问页表，得到主存块号；第三次将主存块号与页内位移组合，得到物理地址。可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但在方便用户和提高存储器利用率上很好地实现了存储管理的目标。<br>请求调页策略是在主存和辅存之间传送存储页，而不是整个进程。这样，整个进程并不需要全部驻留在主存中就可运行，即当进程访问页面时，核心为进程装入该页。请求调页的优点是，它使进程的虚地址空间到机器的物理存储空间的映射更为灵活，允许进程的大小比可用的物理存储空间大得多，还允许将更多的进程同时装入主存。</p>\n<h2 id=\"输入／输出管理\"><a href=\"#输入／输出管理\" class=\"headerlink\" title=\"输入／输出管理\"></a>输入／输出管理</h2><p>I&#x2F;O设备是计算机系统中除中央处理机、主存储器之外的所有其他的设备。<br>为了便于用户作业及相应进程在运行期间利用各类设备I&#x2F;O，管理程序应能屏蔽设备的物理特性，为用户建立虚环境。现代操作系统一般采用“设备独立性”的概念。<br>所谓设备独立性是指用户在编制程序时所使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。逻辑设备名是用户自己指定的设备名（或设备号），它是暂时的、可更改的。而物理设备名是系统提供的设备的标准名称，它是永久的、不可更改的。虽然程序在实际执行中必须使用实际的物理设备，就好像程序在主存中一定要使用物理地址一样，但在用户程序中则应避免使用实际的物理名，而采用逻辑设备名。这样做的道理就和用户程序中要使用逻辑地址而不使用物理地址的道理一样。设备管理的任务之一就是把逻辑设备名转换成物理设备名。</p>\n<h3 id=\"缓冲技术\"><a href=\"#缓冲技术\" class=\"headerlink\" title=\"缓冲技术\"></a>缓冲技术</h3><ul>\n<li><p>什么是缓冲<br>缓冲是在两种不同速度的设备之间传输信息时平滑传输过程的常用手段。缓冲器是以硬件的方法来实现缓冲的，它容量较小，是用来暂时存放数据的一种存储装置。从经济上考虑，除了在关键的地方采用少量必要的硬件缓冲器之外，大都采用软件缓冲。软件缓冲区是指在I&#x2F;O操作期间用来临时存放I&#x2F;O数据的一块存储区域。缓冲是为了解决中央处理机的速度和I&#x2F;O设备的速度不匹配的问题而提出来的，缓冲也可用于解决程序所请求的逻辑记录大小和设备的物理记录大小失配的问题，是有效地利用中央处理机的重要技术。下面看看缓冲是如何工作的。当用户要求在某个设备上进行读操作时，从系统中获得一个空的缓冲区，并将一个物理记录读到缓冲区中。当用户要求使用这些数据时，系统将依据逻辑记录特性从缓冲区中提取并发送到用户进程存储区中。当缓冲区空而进程又要从中取数据时该进程被迫等待。此时，操作系统需要重新送数据填满缓冲区，进程则从中取数据继续运行。当用户要求写操作时，先从系统获得一个空缓冲区，并且将一个逻辑记录从用户的进程存储区传送到缓冲区中。若为顺序写请求，则把数据写到缓冲区中，直到它完全装满为止。然后系统将缓冲区的内容作为物理记录文件写到设备上，使缓冲区再次为空。只有在系统还来不及腾空缓冲区之前，进程又企图输出信息时，它才需要等待。</p>\n</li>\n<li><p>使用缓冲的理由<br>1）处理数据流的生产者与消费者之间的速度差异<br>2）协调传输数据大小的不一致<br>3）应用程序的拷贝语义</p>\n</li>\n</ul>\n<h3 id=\"输入／输出控制方式\"><a href=\"#输入／输出控制方式\" class=\"headerlink\" title=\"输入／输出控制方式\"></a>输入／输出控制方式</h3><p>外部设备在中央处理机的控制之下完成信息的传输。在信息传输中，中央处理机做多少工作、外部设备做多少工作呢？这个问题将决定CPU和I&#x2F;O设备的并行能力，同时它也取决于软、硬技术的基础。CPU一般通过I&#x2F;O控制器与物理设备打交道。按照I&#x2F;O控制器智能化程度的高低，可把I&#x2F;O设备的控制方式分为四类：循环测试I&#x2F;O方式、I&#x2F;O中断方式、DMA方式和通道方式。</p>\n<ul>\n<li><p>I&#x2F;O中断方式<br>与循环测试方式相比，I&#x2F;O中断方式使CPU的利用率大大提高了。但缺点是由于每台设备每次输入／输出一个数据，都要求中断CPU，当系统配置的设备较多时，系统进行中断处理的次数就很多，这会使CPU的有效计算时间大大减少。为减少I&#x2F;O中断处理对CPU造成的负担，又出现了通道方式和DMA方式。</p>\n</li>\n<li><p>通道方式<br>在大、中型和超级小型机中，一般采用I&#x2F;O通道控制I&#x2F;O设备的各种操作。I&#x2F;O通道是用来控制外部设备与主存之间进行成批数据传输的部件。每个通道可以连接多台外部设备并控制它们的I&#x2F;O操作。通道有自己的一套简单的指令系统和执行通道程序，通道接收CPU的委托，而又独立于CPU工作。因此，可以把通道看做是一台小型的处理I&#x2F;O的处理机，或称I&#x2F;O处理机。<br>与前面两种I&#x2F;O方式相比，通道方式有更强的I&#x2F;O处理能力。有关I&#x2F;O的工作，CPU委托通道去做，当通道完成了I&#x2F;O任务后，向CPU发中断信号，请求CPU处理。这样就使CPU基本上摆脱了I&#x2F;O控制工作，并大大提高了CPU与外部设备的并行工作的程度。</p>\n</li>\n<li><p>DMA方式<br>在DMA方式中，I&#x2F;O控制器有更强的功能。它除了具有上述的中断功能外，还有一个DMA控制机构。在DMA控制器的控制下，设备和主存之间可成批地进行数据交换，而不用CPU干预。这样既大大减轻了CPU的负担，也使I&#x2F;O的数据传送速度大大提高。在DMA方式下，允许DMA控制器“接管”地址线的控制权，而直接控制DMA控制器与主存的数据交换。因此，I&#x2F;O设备与主存之间的数据传送不需要CPU介入，从而减轻了CPU的负担。</p>\n</li>\n</ul>\n<h3 id=\"UNIX系统设备管理的主要特点\"><a href=\"#UNIX系统设备管理的主要特点\" class=\"headerlink\" title=\"UNIX系统设备管理的主要特点\"></a>UNIX系统设备管理的主要特点</h3><p>  1．将外部设备看做文件，由文件系统统一处理<br>  2．系统的设备配置灵活、方便<br>  3．使用块设备缓冲技术，提高了文件系统的存取速度块设备的文件存储部分是文件系统存在的介质，而文件系统与用户界面的联系最为密切，故文件系统存取文件的效率是十分重要的。文件系统通过高速缓冲机制存取文件数据，缓冲机制调节核心与文件存储设备之间的数据流。UNIX提供由数据缓冲区组成的高速缓冲，每个缓冲区的大小为512字节。当用户程序要把信息写入文件时，先写入缓冲区里立即返回，由系统作延迟写处理。当用户程序要从磁盘读文件信息时，先要查看在缓冲区缓冲区中有无含有此信息的块，如果有就不必启动磁盘I&#x2F;O，可立即从缓冲区内取出。这种做法大大加快了文件的访问速度。</p>\n<ul>\n<li>UNIX缓冲区的管理<br>对文件系统的一切存取操作，核心都能通过每次直接从磁盘上读或往磁盘上写来实现。但磁盘的传输速率与CPU的速度相比还是慢的。为了加快系统的响应时间和增加系统的吞吐量，UNIX构造了一个由高速缓冲组成的内部数据缓冲池，以降低磁盘的存取频率。UNIX缓冲管理策略试图将尽可能多的有用数据保存在高速缓冲中。核心体系结构中的高速缓冲模块的位置处于文件子系统与块设备驱动程序之间。当从磁盘中读数据时，核心试图先从高速缓冲区中读。如果数据已在高速缓冲中，核心可以不必启动磁盘I&#x2F;O。如果数据不在该高速缓冲区中，则核心从磁盘上读数据，并将其暂时保存在缓冲区中。类似地，要往磁盘上写数据时，也先往高速缓冲区中写入，以便核心随后又试图读它时，它能在高速缓冲中。但是，被写在高速缓冲中的数据要延迟写到非往磁盘上写不可的时候才进行。所以，高速缓冲模块的算法实现了数据的预先缓存和延迟发送的功能。</li>\n</ul>\n<h2 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h2><p>文件的物理结构：连续文件、串联文件、随机文件、索引文件</p>\n<h3 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h3><p>文件系统是用户和外部设备之间的接口和界面。用户可通过文件系统去管理和使用各种设备介质上的信息。文件系统的大部分工作是为了解决“用户所需的信息结构及其操作”与“设备介质的实际结构和I&#x2F;O指令”之间的差异。用户所希望的信息结构是按照简单的逻辑关系组织在一起的，他们所希望的操作是一些只用名字就能存取所需信息的读写操作。然而，计算机只能使用各种I&#x2F;O指令去存取相应介质上的信息，其信息结构又是按照设备介质的各自特点组织的。因此，文件系统所要解决的核心问题，就是按照充分发挥主机和外部设备效率的原则，把信息的逻辑结构映像成设备介质上的物理结构，把用户的文件操作转换成相应的I&#x2F;O指令。转换过程所使用的主要数据结构是文件目录和辅存空间使用情况表。这样，文件目录就将每个文件的符号名和它们在辅存空间的物理地址与有关文件情况的说明信息联系起来了。因此，用户只需向系统提供一个文件符号名，系统就能准确地找出所要的文件来，这就是文件系统的基本功能。实现符号名与具体物理地址之间的转换，其主要环节是查目录。所以，目录的编排应以如何能准确地找到所需的文件为原则，而选择查目录的方法应以查找速度快为准则。</p>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>无</p>\n","site":{"data":{}},"wordcount":17213,"excerpt":"","more":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《操作系统原理(第4版)》 庞丽萍 华中科技大学出版社</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><h2 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h2><h3 id=\"存储程序式计算机\"><a href=\"#存储程序式计算机\" class=\"headerlink\" title=\"存储程序式计算机\"></a>存储程序式计算机</h3><ul>\n<li>冯·诺依曼计算机体系结构<br><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/1.jpg\"><br>从20世纪40年代至今，计算机体系结构不断地发展变化，但冯·诺依曼计算机体系结构定义的一个存储程序式计算机的家族，几乎是当代所有计算机系统的构成基础（除专门设计用于处理特殊任务的计算机外）。存储程序式计算机由中央处理器（处理器（CPU））、存储器和输入／输出设备组成。所有的单元都通过总线连接，总线分为地址总线和数据总线，分别连接不同的部件。<br>由于冯·诺依曼型计算机的计算模型是顺序过程计算模型，所以它的特点是集中顺序过程，在当代的CPU中，可有32～64个通用寄存器，每个寄存器能够保存一个32位（bit）的数值。通用寄存器可以为功能单元提供操作数，并能接收、保存操作的结果。控制单元负责从主存储器提取指令、分析其类型，并产生信号通知计算机其他部分执行指令所指定的操作。控制单元包含一个程序计数器（programcounter，PC）和一个指令寄存器（instructionregister，IR）。程序计数器指示下一步应该执行的指令，而指令寄存器包含当前指令的拷贝。</li>\n</ul>\n<h3 id=\"操作系统的发展历程\"><a href=\"#操作系统的发展历程\" class=\"headerlink\" title=\"操作系统的发展历程\"></a>操作系统的发展历程</h3><p>操作系统是构成计算机系统的另一个重要的系统软件，它负责管理计算机系统的硬件、软件资源并控制整个计算机的工作流程。</p>\n<ul>\n<li><p>发展历程<br>从1950年至今，操作系统的发展主要经历了如下的几个阶段：①手工操作阶段——无操作系统；②批处理系统——早期批处理、执行系统；③操作系统形成——批处理操作系统、分时操作系统、实时操作系统；④现代操作系统——个人计算机操作系统、网络操作系统、分布式操作系统。</p>\n</li>\n<li><p>中断和通道<br>20世纪60年代初期，硬件获得了两方面的进展：一是通道的引入；二是中断技术的出现。这两项重大成果导致操作系统进入执行系统阶段。通道是一种专用处理部件，它能控制一台或多台外设的工作，负责外部设备与主存之间的信息传输。它一旦被启动，就能独立于CPU运行，这样就可使CPU和通道并行操作，而且CPU和各种外部设备也能并行操作。所谓中断是指当主机接到某种信号信号（如I&#x2F;O设备完成信号）时，马上停止原来的工作，转去处理这一事件，当事件处理完毕，主机又回到原来的工作点继续工作。</p>\n</li>\n<li><p>多道程序<br>中断和通道技术出现以后，I&#x2F;O设备和中央处理机可以并行操作，初步解决了高速处理机和低速外部设备的矛盾，提高了计算机的工作效率。但不久又发现，这种并行是有限度的，并不能完全消除中央处理机对外部传输的等待。比如，一个作业在运行过程中依此输入n批数据，每批输入1000个字符，输入机每输入1000个字符需用1000ms，而处理机处理这些数据则需300ms。可见，尽管处理机具有和外部设备并行工作的能力，但是在这种情况下无法让它多做工作，处理机仍有空闲等待现象。那么，为了提高设备的利用率，能否在系统内同时存放几道程序呢？这就引入了多道程序的概念。<br>多道程序运行的特征是：①多道——计算机主存中同时存放几道相互独立的程序；②宏观上并行——同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕；③微观上串行——从微观上看，主存中的多道程序轮流或分时地占有处理机，交替执行。</p>\n</li>\n<li><p>分时技术<br>当计算机技术和软件技术发展到20世纪60年代中期，由于主机速度不断提高而采用了分时技术，使一台计算机可同时为多个终端用户服务。每个终端用户在自己的终端设备上联机使用计算机，好像自己独占机器一样。</p>\n</li>\n</ul>\n<h3 id=\"操作系统的基本概念\"><a href=\"#操作系统的基本概念\" class=\"headerlink\" title=\"操作系统的基本概念\"></a>操作系统的基本概念</h3><ul>\n<li><p>计算机系统的组成<br><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/2.jpg\"><br>操作系统是一个大型的程序系统，它负责计算机系统软、硬件资源的分配和管理；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境。<br>操作系统是重要的系统软件，只有配置了操作系统这一系统软件后，才使计算机系统体现出系统的完整性和可利用性。当用户要计算机帮助完成其计算任务时，用户仅编制源程序（用户在源程序中，可以利用操作系统提供的系统调用请求操作系统相应的服务），而其余的大量工作，如作业控制、系统资源的合理分配和利用，各种调度策略的制订、人机联系方式等都是由操作系统实施的。所以，操作系统使整个计算机系统实现了高度自动化、高效率、高利用率、高可靠性。操作系统是整个计算机系统的核心。</p>\n</li>\n<li><p>操作系统的资源管理功能<br>操作系统的主要功能是管理系统的软、硬件资源。这些资源按其性质来分，可以归纳为四类：处理机、存储器、外部设备和软件资源。这四类资源就构成了系统程序和用户程序赖以活动的物质基础和工作环境。针对这四类资源，操作系统就有相应的资源管理程序：处理机管理、存储管理、设备管理和软件资源管理程序。这些资源管理程序组成了操作系统这一程序系统。</p>\n</li>\n<li><p>操作系统的基本类型<br>（1）批量操作系统；（2）分时操作系统；（3）实时操作系统；（4）个人计算机操作系统；（5）网络操作系统；（6）分布式操作系统。</p>\n</li>\n</ul>\n<h2 id=\"操作系统的组织结构\"><a href=\"#操作系统的组织结构\" class=\"headerlink\" title=\"操作系统的组织结构\"></a>操作系统的组织结构</h2><h3 id=\"操作系统虚拟机\"><a href=\"#操作系统虚拟机\" class=\"headerlink\" title=\"操作系统虚拟机\"></a>操作系统虚拟机</h3><p>在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。扩充后的虚拟机不仅可以使用原来裸机提供的各种基本硬件指令，而且还可使用操作系统中所增加的许多其他“指令”。这些指令统称为扩充机器的指令系统，又称为操作命令语言。<br>  <img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/3.jpg\"><br>操作系统虚拟机提供了协助用户解决问题的装置，其功能是通过它提供的命令来体现的，用户也是通过这一组命令和操作系统虚拟机打交道的。系统所提供的全部操作命令的集合称为操作命令语言，它是用户和系统进行通信的手段和界面。这一用户界面分为两个方面：操作命令（又称命令接口）和系统功能调用（又称程序接口）。<br>操作系统在计算机系统中所处的位置是硬件层（裸机）和其他所有软件之间，是所有软件中与硬件相连的第一层软件，它在裸机上运行，又是系统<br>软件和应用程序运行的基础。它与硬件、应用程序和用户都有接口。具有一体化结构的操作系统提供的接口如下图所示，从该结构中可以看出操作系统提供的多种接口。<br>  <img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/4.jpg\" alt=\"loading-ag-517\"></p>\n<h3 id=\"处理机的状态\"><a href=\"#处理机的状态\" class=\"headerlink\" title=\"处理机的状态\"></a>处理机的状态</h3><p>操作系统是计算机系统中最重要的系统软件，为了能正确地进行管理和控制，其本身是不能被破坏的。为此，系统应能建立一个保护环境，采用的办法是区分处理机的工作状态。因为，在系统中有两类程序在运行，一类是管理程序（如处理机调度程序、主存分配程序、I&#x2F;O管理程序等）；另一类是用户程序。这两类程序是不同的，前者是管理和控制者，它负责管理和分配系统资源，为用户提供服务。而用户程序运行时，所需资源必须向操作系统提出请求，自己不能随意取用系统资源，如直接启动外部设备进行工作，更不能改变机器状态等。这两类不同程序执行时应有不同的权限，为此根据对资源和机器指令的使用权限，将处理执行时的工作状态区分为不同的状态（或称为模式）。所谓处理机的态，就是处理机当前处于何种状态，正在执行哪类程序。为了保护操作系统，至少需要区分两种状态：管态和用户态。管态（supervisormode）：又称为系统态，是操作系统的管理程序执行时机器所处的状态。在此状态下允许中央处理机使用全部系统资源和全部指令，其中包括一组特权指令（例如，涉及外部设备的输入／输出指令、改变机器状态或修改存储保护的某些指令），允许访问整个存储区。用户态（usermode）：又称为目态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用系统资源与改变机器状态，并且只允许用户程序访问自己的存储区域。有的系统将管理程序执行时的机器状态进一步分为核态和管态，这时，管态的权限有所变化，管态只允许使用一些在用户态下所不能使用的资源，但不能使用修改机器的状态指令。而核态（kernelmode）就具有上述管态所具有的所有权限。无核态的系统，管态执行核态的全部功能。管态比核态权限要低，用户态的权限更低。为了区分处理机的工作状态，需要硬件的支持。在计算机状态寄存器中需设置一个系统状态位（或称模式位）。若有了系统状态位，就可以区分当前正在执行的是系统程序还是用户程序。<strong>若用户程序执行时，超出了它的权限，如要访问操作系统核心数据或企图执行一个特权指令，都将从用户态转为管态，由操作系统得到CPU控制权，处理这一非法操作。这样可以有效地保护操作系统不受破坏。当用户程序执行时，若需要请求操作系统服务，则要通过一种受控方式进入操作系统，将用户态转为核态，由操作系统得到控制权，在核态下执行其相应的服务例程，服务完毕后，返回到用户态，让用户继续执行。</strong></p>\n<h3 id=\"中断机制\"><a href=\"#中断机制\" class=\"headerlink\" title=\"中断机制\"></a>中断机制</h3><p>所谓中断是指某个事件（例如电源掉电、定点加法溢出或I&#x2F;O传输结束等）发生时，系统中止现行程序的运行、引出处理该事件程序进行处理，处理完毕后返回断点，继续执行。<br>  <img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/5.jpg\"><br>中断响应的实质是交换指令执行地址和处理器状态，以达到如下目的：①保留程序断点及有关信息；②自动转入相应的中断处理程序执行。中断响应所需的硬件支持包括：指令计数器、处理器状态寄存器、中断向量表和系统堆栈。<br>整个中断处理的功能是由硬件和软件配合完成的。硬件负责中断进入过程，即发现和响应中断请求，把中断的原因和断点记下来供软件处理时查用，同时负责引出中断处理程序。而中断分析、中断处理、恢复被中断程序的现场等工作则由软件的中断处理程序来完成。<br>java里数组越界的一场应该算一种中断。</p>\n<h3 id=\"UNIX系统结构\"><a href=\"#UNIX系统结构\" class=\"headerlink\" title=\"UNIX系统结构\"></a>UNIX系统结构</h3><p>UNIX系统核心层的功能包括文件管理、设备管理、存储管理和处理机管理，此外还有中断和俘获的处理。<strong>现代计算机系统的硬件机构支持核心态和用户态，使得核心程序在核心态下运行，实用程序在用户态下运行。每一种状态都有自己的栈和栈指针，都有自己的地址映射部件。所以，用户态的程序不能直接访问核心态的程序和数据，只能通过访问管理程序指令（访管指令，如trap指令）自陷到核心内的操作系统服务程序。<br>UNIX系统的核心结构是一体化结构。</strong><br><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/6.jpg\" alt=\"loading-ag-518\"></p>\n<h3 id=\"静态连接和动态链接\"><a href=\"#静态连接和动态链接\" class=\"headerlink\" title=\"静态连接和动态链接\"></a>静态连接和动态链接</h3><p>连接这一处理步骤，以前通常采用静态连接方式。静态连接是将所需的外部调用函数连接到目标文件中形成一个完整的主存映像文件。采用这种静态连接的缺点是，当有多个应用程序都需要调用同一个库函数时，那么，这些应用程序的目标文件中都将包含这个外部函数对应的代码。这将造成主存的极大浪费，不能支持有效的共享。动态链接是将这一连接工作延迟到程序运行的时候进行。它需要的支持是动态链接库（DLL）。动态链接不需要将应用程序所需要的外部函数代码从库中提取出来并连接到目标文件中，而是在应用程序需要调用外部函数的地方作记录，并说明要使用的外部函数名和引用入口号，形成调用链表。当所需的动态链接库DLL在主存时，就可以确定所需函数的主存绝对地址，并将它填入调用链表相应位置中。当应用程序运行时，就可以正确地引用这个外部函数了。现代操作系统有的已采用了动态链接技术，如Windows系统，现在的动态链接库一般是系统库。</p>\n<h3 id=\"操作系统提供的用户界面\"><a href=\"#操作系统提供的用户界面\" class=\"headerlink\" title=\"操作系统提供的用户界面\"></a>操作系统提供的用户界面</h3><p>操作系统提供的用户界面如下图所示：一是操作界面，又称为操作命令；二是程序界面，又称为系统功能调用。<br><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/7.jpg\" alt=\"loading-ag-519\"></p>\n<h3 id=\"系统功能调用\"><a href=\"#系统功能调用\" class=\"headerlink\" title=\"系统功能调用\"></a>系统功能调用</h3><p>为了实现在程序级的服务支持，操作系统提供统一的系统功能调用，采用统一的调用方式——访问管理程序来实现对这些功能的调用。<br><strong>对于用户所需要的功能，由系统设计者事先编制好能实现这些功能的例行子程序，作为操作系统程序模块的一部分。这些例行子程序不能像一般的用户子程序那样可随便调用，因为这些能实现各种功能的例行子程序是操作系统的程序部分，它运行时，机器处于管态（管理程序状态），而用户程序运行时，机器处于用户态。所以，用户程序对这些例行子程序的调用应以一种特殊的调用方式——访管方式来实现。</strong><br>这样一个带有一定功能号的访管指令定义了一个系统调用。因此，系统调用是用户在程序一级请求操作系统服务的一种手段，它不是一条简单的硬指令，而是带有一定功能号的访管指令。它的功能并非由硬件直接提供，而是由操作系统中的一段程序完成的，即由软件方法实现的。用户可以用带有不同功能号的访管指令来请求各种不同的功能。可以这样说，系统调用是利用访管指令定义的指令。操作系统服务例程与一般子程序的区别在于，前者所实现的功能都是与计算机系统本身有关的，对前者的调用是通过一条访管指令来实现的。不同的程序设计语言调用操作系统服务的方式是不同的，它们有显式调用和隐式调用之分。<strong>在汇编语言中是直接使用系统调用对操作系统提出各种要求的，因为在这种情况下，系统调用具有汇编指令的形式。而在高级语言中一般是隐式的调用（经编译后转成某种直接调用）。</strong></p>\n<h2 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h2><h3 id=\"进程概念\"><a href=\"#进程概念\" class=\"headerlink\" title=\"进程概念\"></a>进程概念</h3><h4 id=\"进程定义\"><a href=\"#进程定义\" class=\"headerlink\" title=\"进程定义\"></a>进程定义</h4><p>根据1978年在庐山召开的全国操作系统会议上关于进程的讨论，结合国外的各种观点，国内对进程这一概念作了如下描述：进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动。<br>进程和程序是既有联系又有区别的两个概念，它们的区别如下。（1）程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态概念。而进程是程序在处理机上的一次执行过程，它是一动态概念。程序可以作为一种软件资料长期保存，而进程则是有一定生命期的，它能够动态地产生和消亡。即进程可由“创建”而产生，由调度而执行，因得不到资源而暂停，以致最后由“撤销”而消亡。（2）进程是一个能独立运行的单位，能与其他进程并行地活动。（3）进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。<br>进程和程序又是有联系的。在支持多任务运行的操作系统中，活动的最小单位是进程。进程一定包含一个程序，因为程序是进程应完成功能的逻辑描述；而一个程序可以对应多个进程。如果同一程序同时运行于若干不同的数据集合上，它将属于若干个不同的进程。或者说，若干不同的进程可以包含相同的程序。这句话的意思是：用同一程序对不同的数据先后或同时加以处理，就对应于好几个进程。例如，系统具有一个C语言编译程序，当它对多个终端用户的C语言源程序进行编译时，就产生了多个编译进程。</p>\n<h4 id=\"进程类型\"><a href=\"#进程类型\" class=\"headerlink\" title=\"进程类型\"></a>进程类型</h4><p>有些进程起着资源管理和控制的作用，称为系统进程；而另一些是为用户算题任务而建立的进程称为用户进程。它们是有区别的。①系统进程被分配一个初始的资源集合，这些资源可为它所独占，也可以最高优先级的资格优先使用。用户进程通过系统服务请求的手段竞争系统资源。②用户进程不能做直接I&#x2F;O操作，而系统进程可以做显示的、直接的I&#x2F;O操作。③系统进程在管态下活动，而用户进程在用户态下活动。</p>\n<h4 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h4><p>进程有着“执行—暂停—执行”的活动规律。一般说来，一个进程并不是自始至终连续不停地运行的，它与并发执行中的其他进程的执行是相互制约的。它有时处于运行状态，有时又由于某种原因而暂停运行处于等待状态，当使它暂停的原因消失后，它又进入准备运行状态。所以，在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、等待状态（又称阻塞状态）。①就绪状态（ready）。当进程获得了除CPU之外所有的资源，它已经准备就绪，一旦得到CPU控制权，就可以立即运行，该进程所处的状态为就绪状态。②运行状态（running）。当进程由调度／分派模块分派后，得到中央处理机控制权，它的程序正在运行，该进程所处的状态为运行状态。③等待状态（wait）。若一进程正在等待某一事件发生（如等待输入／输出操作的完成）而暂时停止执行，这时，即使给它CPU控制权，它也无法执行，则称该进程处于等待状态，又可称为阻塞状态。<br>为了描述一个进程和其他进程以及系统资源的关系，为了刻画一个进程在各个不同时期所处的状态，人们采用了一个与进程相联系的数据块，称为进程控制块（processcontrolblock，PCB）或称为进程描述器（processdescriptor）。系统根据pcb而感知进程的存在，故pcb是标识进程存在的实体。当系统创建一个进程时，必须为它设置一个pcb，然后根据pcb的信息对进程实施控制管理。进程任务完成时，系统撤销它的pcb，进程也随之消亡。</p>\n<h4 id=\"线程概念\"><a href=\"#线程概念\" class=\"headerlink\" title=\"线程概念\"></a>线程概念</h4><p>在操作系统中，为了支持并发活动，引入了进程的概念，在传统的操作系统中，每个进程只存在一条控制线索和一个程序计数器。但在有些现代操作系统中，提供了对单个进程中多条控制线索的支持。这些控制线索通常称为线程（threads），有时也称为轻量级进程（lightweightprocesses）。线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多条执行路径，即线程。这样，在一个进程内部就有多个可以独立活动的单位，可以加快进程处理的速度，进一步提高系统的并行处理能力。<br>①线程是进程中的一条执行路径；②它有自己私用的堆栈和处理机执行环境（尤其是处理器寄存器）；③它共享分配给父进程的主存；④它是单个进程所创建的许多个同时存在的线程中的一个。<br>进程和线程既有联系又有区别，对于进程的组成，可以高度概括为以下几个方面：①一个可执行程序，它定义了初始代码和数据；②一个私用地址空间（addressspace），它使进程可以使用的一组虚拟主存地址；③进程执行时所需的系统资源（如文件、信号灯、通信端口等），是由操作系统分配给进程的；④若系统支持线程运行，那么每个进程至少有一个执行线程。进程是任务调度的单位，也是系统资源的分配单位；而线程是进程中的一条执行路径，当系统支持多线程处理时，线程是任务调度的单位，但不是系统资源的分配单位。线程完全继承父进程占有的资源，当它活动时，具有自己的运行现场。<br>相对进程而言，线程的创建与管理的开销要小得多。因为线程可以共享父进程的所有程序和全局数据，这意味着创建一个新线程只涉及最小量的主存分配（线程表），也意味着一个进程创建的多个线程可以共享地址区域和数据。在进程内创建多线程，可以提高系统的并行处理能力。例如，一个文件服务器，某时刻它正好封锁在等待磁盘操作上，如果这个服务器进程具有多个控制线程，那么当另一个线程在等待磁盘操作时，第二个线程就可以运行，比如它又可接收一个新的文件服务请求。这样可以提高系统的性能。</p>\n<h2 id=\"处理机调度\"><a href=\"#处理机调度\" class=\"headerlink\" title=\"处理机调度\"></a>处理机调度</h2><h3 id=\"多级调度\"><a href=\"#多级调度\" class=\"headerlink\" title=\"多级调度\"></a>多级调度</h3><p>1．批处理系统中的处理机调度<br>在多用户批处理操作系统中，对处理机的分配分为两级：作业调度和进程调度。在这样的系统中，每个用户提交的算题任务，往往作为系统的一个处理单位，称为作业。这样一道作业在处理过程中又可以分为多个并发的活动单位，称为进程。作业调度又称为宏观调度，其任务是对提交给系统的、存放在辅存设备上的大量作业，以一定的策略进行挑选，分配主存等必要的资源，建立作业对应的进程，使其投入运行。进入主存中的进程还可以根据需要创建子进程。作业调度使该作业对应的进程具备使用处理机的权利。而进入主存的诸进程，分别在什么时候真正获得处理机，这是由处理机的进程调度（一般又称为微观调度）来决定的。进程调度的对象是进程，其任务是在进入主存的所有进程中，确定哪个进程在什么时候获得处理机，使用多长时间等。<br>2．多任务操作系统中的处理机调度<br>3．多线程操作系统中的处理机调度<br>在现代操作系统中，有些系统支持多线程运行。在这样的系统中，一个进程可以创建一个线程，也可以创建多个线程。系统为进程分配它所需要的资源（如主存），而处理机的分配单位则为线程，系统提供线程调度程序，其功能是当处理机空闲时，以某种策略选择一个就绪线程去运行，并为它分配处理机时间。</p>\n<h3 id=\"作业调度算法\"><a href=\"#作业调度算法\" class=\"headerlink\" title=\"作业调度算法\"></a>作业调度算法</h3><p>1．先来先服务调度算法<br>2．短作业优先调度算法<br>3．响应比高者优先调度算法<br>4．优先调度算法</p>\n<h3 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h3><h4 id=\"调度／分派结构\"><a href=\"#调度／分派结构\" class=\"headerlink\" title=\"调度／分派结构\"></a>调度／分派结构</h4><p>任何进程都必须通过调度／分派模块来使用处理机。进程调度的功能可细分为调度和分派两部分。其中，调度意味着依照完全确定的策略将一批进程进行排序，而分派则是从就绪队列中移出一个进程并给它提供处理机的使用权。相应的调度程序和分派程序的功能是：调度程序负责将一个进程插入到就绪队列并按一定原则保持队列结构；分派程序是将进程从就绪队列中移出并建立该进程执行的机器状态。<br>但是，在一些系统中常常只提进程调度的概念，而不细分调度和分派这两个部分。因为这里所说的调度功能实际上分散到某些进程控制原语或通信原语中实现了，所以在这些系统中，调度与分派之间不加区别，并统称为调度程序模块。在这里提出调度／分派结构，是希望读者明确处理机的分配包含有两方面内容：一是按确定的调度原则选一个进程；二是给选中进程赋予处理机的控制权。若要强调后者，就使用“分派程序”这一名词；否则就采用“进程调度程序”这一名词。</p>\n<ul>\n<li>CPU现场信息的切换<br>CPU现场信息的切换（即保留原来运行进程的状态信息，并用保留在选中进程PCB中的状态信息设置CPU现场）所需时间是额外开销，因为切换时系统并不能做其他的工作。进程切换所需时间因机器不同而不同，它取决于主存速度、必须复制的寄存器的数量、是否有特殊指令（如装入或保存所有单个指令）等因素。切换时间与硬件支持密切相关。例如，有的处理器（如SUNUltraSPARC）提供了多个寄存器组，切换只需要简单地改变当前寄存器组的指针。当处理器只有一个寄存器组，或活动进程超过了寄存器组的数量时，系统必须在寄存器组与主存之间进行数据复制。而且，操作系统越复杂，这一切换所要做的工作就越多。典型的进程切换时间为1μs到1000μs。进程调度时机可能有以下几种：①进程完成其任务时；②在一次管理程序调用之后，该调用使现行程序暂时不能继续运行时；③在一次出错陷入之后，该陷入使现行进程在出错处理时被挂起时；④在分时系统中，当进程使用完规定的时间片，时钟中断使该进程让出处理机时；⑤在采用可剥夺调度方式的系统中，当具有更高优先级的进程要求处理机时。</li>\n<li>进程调度的准则<br>不同的进程调度算法具有不同的特点，且可能对某些进程更有利。为了对算法进行选择以适用于特定的应用，必须分析各种算法的特点。为了比较各种进程调度算法，分析员提出了许多准则，这些准则对确定算法的优劣有很大的影响，这些准则涉及如下几个因素。（1）CPU使用率。需要使CPU尽可能忙。CPU使用率从0到100％。对于真实系统，它应从40％（轻负荷系统）到90％（重负荷系统）。（2）吞吐量。如果CPU忙于执行进程，那么就要评估其工作量。其中一种测量工作量的方法称为吞吐量。吞吐量是指一个时间单元内所完成的进程数量。若系统中短进程多，则吞吐量较高，可能为每秒十个进程。（3）周转时间。在批处理系统中，从作业进入系统到完成的时间间隔称为周转时间。周转时间是所有时间段之和，包括等待进入主存、在就绪队列中等待、在CPU上执行和I&#x2F;O执行时间。利用特权可以分析运行该作业需要花费的时间。（4）响应时间。对于交互式系统而言，周转时间并不是最佳的准则，通常采用响应时间作为时间度量。响应时间是指从联机用户向计算机发出一个命令到计算机执行完该命令，并将相应的执行结果返回给用户所需的时间。（5）等待时间。进程调度算法并不影响进程运行和执行I&#x2F;O的时间量，它只影响进程在就绪队列中等待所花费的时间。等待时间是进程在就绪队列中等待所花费时间之和。人们需要使CPU使用率和吞吐量最大化，而使周转时间、响应时间和等待时间最小化。在绝大多数情况下要优化平均度量值，不过在有的情况下，需要优化最小值或最大值，而不是平均值。例如，在分时系统中为了保证所有用户都得到好的服务，可能需要使响应时间最小。</li>\n<li>调度方式<br>在优先调度策略下还要确定调度方式。所谓调度方式是指，当一进程正在处理机上执行时，若有某个更为“重要而紧迫”的进程需要进行处理，亦即，若有优先级更高的进程进入就绪队列时，如何分配处理机。通常有两种进程调度方式：一种是仍然让正在执行的进程继续执行，直到该进程完成或发生某事件（如提出I&#x2F;O请求）而进入“完成”或“阻塞”状态时，才把处理机分配给“重要而紧迫”的进程，使之执行，这种进程调度方式称为非剥夺方式；另一种方式则是“重要而紧迫”的进程一到，便暂停正在执行的进程，立即把处理机分配给它，这种方式称为可剥夺调度方式。后者所实施的策略就是可抢占的调度策略。</li>\n<li>进程优先数调度<br>进程优先数调度算法就是一种优先调度，该算法预先确定各进程的优先数，系统将处理机的使用权赋予就绪队列中具备最高优先级（优先数和一定的优先级相对应）的就绪进程。这种算法又可分为不可抢占CPU与可抢占CPU两种情况。在后一种情况下，无论何时，执行着的进程的优先级总要比就绪队列中的任何进程的优先级高。</li>\n</ul>\n<h2 id=\"主存管理\"><a href=\"#主存管理\" class=\"headerlink\" title=\"主存管理\"></a>主存管理</h2><h3 id=\"空间分片\"><a href=\"#空间分片\" class=\"headerlink\" title=\"空间分片\"></a>空间分片</h3><p>现代操作系统区分两类主存：物理主存和逻辑主存。主存共享的基础当然是物理主存。物理主存由0～m-1个物理地址组成。物理地址是计算机主存单元的真实地址，又称为绝对地址或实地址。处理机依据绝对地址可以随机存取存放在其内的信息。物理地址的集合所对应的空间组成了主存空间。而主存中的一个区域是物理地址集合的一个递增整数序列子集{n，n+1，…，n+m}所对应的主存空间。<br>在多用户多进程系统中，主存以分片方式实现共享。主存中分片的方式有两种：一是划分为大小不等的区域，这些区域根据用户程序实际需要而被分割；二是划分为大小相等的块，以块为单位进行分配，操作系统和用户程序根据需要占用若干主存块。前者一般称为按区（或按段）分配，后者称为按页分配。这些分配方法是实现主存共享的主要方法。</p>\n<h3 id=\"主存管理的功能\"><a href=\"#主存管理的功能\" class=\"headerlink\" title=\"主存管理的功能\"></a>主存管理的功能</h3><p>如果直接以物理地址提交给用户使用，这对用户来说是十分困难的事。而且，多个用户程序共享主存，由用户自行分配主存更是不可能的事。为了支持多道程序运行，方便用户使用，系统必须为每个用户提供0～n-1的一组逻辑地址（虚地址），即提供一个虚拟地址空间。每个应用程序相信它的主存是由0单元开始的一组连续地址组成。用户的程序地址（指令地址或操作数地址）均为逻辑地址。对于每个逻辑地址，在主存中并没有一个固定的、真实的物理单元与之对应。因此，根据逻辑地址还不能直接到主存中去存取信息，它是一个虚地址或称为相对地址。用户所看到的虚存（逻辑地址）与被共享的主存（物理地址）之间有一定的映射关系。程序执行时，必须将逻辑地址正确地转换为物理地址，此即为地址映射。假定虚存空间由n表示，主存空间由m表示，那么地址映射可表示成：f：n→m。为了支持多道程序运行，主存管理必须实现主存分配、主存保护、主存扩充等功能。因此，存储管理的功能可归纳为以下几点：①映射逻辑地址到物理主存地址；②在多用户之间分配物理主存；③对各用户区的信息提供保护措施；④扩充逻辑主存区。</p>\n<h4 id=\"虚拟存储器\"><a href=\"#虚拟存储器\" class=\"headerlink\" title=\"虚拟存储器\"></a>虚拟存储器</h4><p>随着科学技术的不断进步和计算机应用的日益广泛，需要计算机解决的问题越来越多、越来越复杂。有些科学计算或数据处理的问题需要相当大的主存容量，尤其在多道程序系统中主存容量显得更为紧张。当系统提供大容量的辅存时，操作系统把主存和辅存统一管理，实现信息的自动移动和覆盖。当一个用户程序的地址空间比主存可用空间大时，操作系统将这个程序的地址空间的一部分放入主存内，而其余部分放在辅存上。当所访问的信息不在主存时，则由操作系统负责调入所需要的部分。由于大多数程序执行时，在一段时间内仅使用它的程序编码的一部分，即并不需要在全部时间内将该程序的全部指令和数据都放在主存中，所以，程序的地址空间部分装入主存时，它还能正确地执行，此即为程序的局部性特征。<br>虚拟存储器（virtualmemory）将用户的逻辑主存与物理主存分开，这是现代计算机对虚存的实质性的描述。更为一般的描述是：计算机系统在处理应用程序时，只装入部分程序代码和数据就启动其运行，由操作系统和硬件相配合完成主存和外围联机存储器之间的信息的动态调度，这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器。之所以称它为虚拟存储器，是因为这样的存储器实际上并不存在，只是由于系统提供了自动覆盖功能后，给用户造成的一种虚拟的感觉，仿佛有一个很大的主存供他使用一样。<br>虚拟存储器的核心问题是将程序的访问地址和主存的可用地址相脱离。程序的访问地址称为虚地址，它可以访问的虚地址范围叫做程序的虚地址空间V，虚地址范围是由虚地址寄存器的位数决定的。在指定的计算机系统中，可使用的实地址范围叫做计算机的实地址空间R。当然，虚地址空间可以比实地址空间大，也可以比实际主存小。在多道程序运行环境下，操作系统把实际主存扩充成若干个虚存，系统可以为每个应用程序建立一个虚存。这样每个应用可以在自己的地址空间中编制程序，在各自的虚存上运行。引入虚存概念后，用户无需了解实存的物理性能，只需在自己的虚存上编制程序，这给用户带来了极大的方便。主存空间的分配由系统完成；逻辑地址转换成物理地址是通过地址变换机构自动完成的，这样，既消除了普通用户对主存分配细节、具体问题了解的困难，方便了用户，又能根据主存的情况和应用程序的实际需要进行动态分配，从而充分利用了主存。而且，多道程序设计所要求的存储保护、程序浮动都可以很方便地实现。必须指出，实现虚拟存储技术，需要有一定的物质基础。其一是需要有相当容量的辅存，以便足以存放多用户的作业的地址空间；其二是要有一定容量的主存；其三是地址变换机构。</p>\n<h3 id=\"分区存储管理\"><a href=\"#分区存储管理\" class=\"headerlink\" title=\"分区存储管理\"></a>分区存储管理</h3><p>分区存储管理是满足多道程序设计的最简单的一种存储管理方法。它允许多个用户作业共享主存空间，这些作业在主存内是以划分分区而共存的。早期的分区存储管理技术只有固定式分区方法，后来才发展形成动态分区方法。<br>分区存储管理技术能满足多道程序设计的需要，但它也存在着一个非常严重的碎片问题。解决这个问题的办法之一是采用拼接技术。所谓拼接技术是指移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲区，拼接要消耗大量的系统资源，且有时为拼接所花费的系统开销要大于拼接所得到的效益，因而这种方法的使用受到了限制。</p>\n<h3 id=\"页式存储管理\"><a href=\"#页式存储管理\" class=\"headerlink\" title=\"页式存储管理\"></a>页式存储管理</h3><p>为了寻找解决碎片问题的新途径，人们很容易想到能否避开程序对连续连续性的要求，让程序的地址空间去适应存储器的现状。例如，有一个作业要求投入运行，其程序的地址空间为3KB，而主存当前只有两个各为1KB和2KB的空闲区。显然，每个空闲区的大小都比该程序的地址空间小，而总和却同它相等。这时可以把该程序存放到主存中这两个不相邻的区域中。这正是分页的思想。<br>在分页存储管理方法中，主存被等分成一系列的块，程序的地址空间被等分成一系列的页面，然后将页面存放到主存块中。为了便于实现动态地址变换，一般主存的块和页面大小相等且为2的幂次。<br>另外，在按区分配方案中，当作业程序的地址空间小于主存可用空间时，该作业是不能投入运行的，即不能方便地实现主存扩充。但是，在页式系统中则可方便地支持虚拟存储，扩充主存，因为它不需限定作业在投入运行之前必须把它的全部地址空间装入主存，而只要求把当前所需要的一部分页面装入主存即可。这样，对虚地址空间的限制，至少从理论上来说被取消了。换句话说，这种系统为用户提供了一个很大的地址空间。但系统必须完成主存和辅存之间的信息的自动调度。因为，一个作业的全部页面存放在辅存上，当它投入运行时，只是将运行进程的部分页面装入主存（这些页面称为活动页面），在进程活动期间，系统根据其需要再从辅存调入所需的页面。</p>\n<h4 id=\"页表\"><a href=\"#页表\" class=\"headerlink\" title=\"页表\"></a>页表</h4><p>程序的虚地址空间划分为若干页，并被装入主存的空闲块中。于是，一个连续的程序空间在主存中可能是不连续的。为了保证程序能正确地运行，必须在执行每条指令时将程序中的逻辑地址变换为实际的物理地址，即进行动态重定位。在页式系统中，实现这种地址变换的机构称为页面映像表，简称页表。在页式系统中，当程序按页划分装入存储器时，操作系统为该程序建立一个页表。页表是记录程序虚页与其在主存中块（实页）的对应关系的数据结构。页表中的每一个数据项用来描述页面在主存中的物理块号以及页面的使用特性（根据需要扩充页表的功能）。在简单的页式系统中，页表只是虚页和主存物理块的对照表。<br>页表可由高速缓冲存储器组成，这样做的结果是，地址变换速度快，但成本较高。另一个办法是在主存固定区域内，用存储单元来存放页表。这种方法要占用一部分主存空间，而且地址变换速度较慢。现代的计算机系统采用硬件与主存页表相结合的方法实现地址变换。</p>\n<p><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/9.jpg\">根据实际使用的经验，一般页面尺寸为1KB、2KB或4KB。<br>当请求调页程序要调进一个页面、而此时该作业所分得的主存块已全部用完，则必须淘汰该作业已在主存中的一个页。这时，就产生了在诸页面中淘汰哪个页面的实际问题，这也就涉及淘汰算法即置换算法的问题。算法设计不好将造成巨大系统开销，称为颠簸。</p>\n<h3 id=\"段式系统\"><a href=\"#段式系统\" class=\"headerlink\" title=\"段式系统\"></a>段式系统</h3><p>在前述的分区存储管理和页式系统中，程序的地址空间是一维线性的，因为指令或操作数地址只要给出一个信息量即可决定。分区存储管理方法易出现碎片。页式系统中一页或页号相连的几个虚页上存放的内容一般都不是一个逻辑意义完整的信息单位。请调一页，可能只用到页中的一部分内容。这种情况，对于要调用许多子程序的大型用户程序来说，仍然会感到感到主存空间的使用效率不高。为此，提出了段式存储管理技术。在这样的系统中作业的地址空间由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，它是一个连续的地址区。在主存中，每个分段占一分区。由于分段是一个有意义的信息单位，所以分段的共享和对分段的保护更有意义，同时也容易实现。</p>\n<h3 id=\"段页式存储管理\"><a href=\"#段页式存储管理\" class=\"headerlink\" title=\"段页式存储管理\"></a>段页式存储管理</h3><p>在段式存储管理中结合分页存储管理技术，即在程序地址空间内分段，在一个分段内划分页面，这就形成了段页式存储管理。具有段页式地址结构的用户地址空间。<br>段页式存储管理的用户地址空间是二维的、按段划分的。在段中再划分成若干大小相等的页。这样，地址结构就由段号、段内页号和页内位移三部分组成。用户使用的仍是段号和段内相对地址，由地址变换机构自动将段内相对地址的高几位解释为段内页号，将剩余的低位解释为页内位移。用户地址空间的最小单位不是段而是页，而主存按页的大小划分，按页装入。这样，一个段可以装入到若干个不连续的主存块内，段的大小不再受主存可用区的限制了。</p>\n<p><img src=\"/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/10.jpg\">段页式地址变换中要得到物理地址须经过三次主存访问（若段表、页表都在主存），第一次访问段表，得到页表起始地址；第二次访问页表，得到主存块号；第三次将主存块号与页内位移组合，得到物理地址。可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但在方便用户和提高存储器利用率上很好地实现了存储管理的目标。<br>请求调页策略是在主存和辅存之间传送存储页，而不是整个进程。这样，整个进程并不需要全部驻留在主存中就可运行，即当进程访问页面时，核心为进程装入该页。请求调页的优点是，它使进程的虚地址空间到机器的物理存储空间的映射更为灵活，允许进程的大小比可用的物理存储空间大得多，还允许将更多的进程同时装入主存。</p>\n<h2 id=\"输入／输出管理\"><a href=\"#输入／输出管理\" class=\"headerlink\" title=\"输入／输出管理\"></a>输入／输出管理</h2><p>I&#x2F;O设备是计算机系统中除中央处理机、主存储器之外的所有其他的设备。<br>为了便于用户作业及相应进程在运行期间利用各类设备I&#x2F;O，管理程序应能屏蔽设备的物理特性，为用户建立虚环境。现代操作系统一般采用“设备独立性”的概念。<br>所谓设备独立性是指用户在编制程序时所使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。逻辑设备名是用户自己指定的设备名（或设备号），它是暂时的、可更改的。而物理设备名是系统提供的设备的标准名称，它是永久的、不可更改的。虽然程序在实际执行中必须使用实际的物理设备，就好像程序在主存中一定要使用物理地址一样，但在用户程序中则应避免使用实际的物理名，而采用逻辑设备名。这样做的道理就和用户程序中要使用逻辑地址而不使用物理地址的道理一样。设备管理的任务之一就是把逻辑设备名转换成物理设备名。</p>\n<h3 id=\"缓冲技术\"><a href=\"#缓冲技术\" class=\"headerlink\" title=\"缓冲技术\"></a>缓冲技术</h3><ul>\n<li><p>什么是缓冲<br>缓冲是在两种不同速度的设备之间传输信息时平滑传输过程的常用手段。缓冲器是以硬件的方法来实现缓冲的，它容量较小，是用来暂时存放数据的一种存储装置。从经济上考虑，除了在关键的地方采用少量必要的硬件缓冲器之外，大都采用软件缓冲。软件缓冲区是指在I&#x2F;O操作期间用来临时存放I&#x2F;O数据的一块存储区域。缓冲是为了解决中央处理机的速度和I&#x2F;O设备的速度不匹配的问题而提出来的，缓冲也可用于解决程序所请求的逻辑记录大小和设备的物理记录大小失配的问题，是有效地利用中央处理机的重要技术。下面看看缓冲是如何工作的。当用户要求在某个设备上进行读操作时，从系统中获得一个空的缓冲区，并将一个物理记录读到缓冲区中。当用户要求使用这些数据时，系统将依据逻辑记录特性从缓冲区中提取并发送到用户进程存储区中。当缓冲区空而进程又要从中取数据时该进程被迫等待。此时，操作系统需要重新送数据填满缓冲区，进程则从中取数据继续运行。当用户要求写操作时，先从系统获得一个空缓冲区，并且将一个逻辑记录从用户的进程存储区传送到缓冲区中。若为顺序写请求，则把数据写到缓冲区中，直到它完全装满为止。然后系统将缓冲区的内容作为物理记录文件写到设备上，使缓冲区再次为空。只有在系统还来不及腾空缓冲区之前，进程又企图输出信息时，它才需要等待。</p>\n</li>\n<li><p>使用缓冲的理由<br>1）处理数据流的生产者与消费者之间的速度差异<br>2）协调传输数据大小的不一致<br>3）应用程序的拷贝语义</p>\n</li>\n</ul>\n<h3 id=\"输入／输出控制方式\"><a href=\"#输入／输出控制方式\" class=\"headerlink\" title=\"输入／输出控制方式\"></a>输入／输出控制方式</h3><p>外部设备在中央处理机的控制之下完成信息的传输。在信息传输中，中央处理机做多少工作、外部设备做多少工作呢？这个问题将决定CPU和I&#x2F;O设备的并行能力，同时它也取决于软、硬技术的基础。CPU一般通过I&#x2F;O控制器与物理设备打交道。按照I&#x2F;O控制器智能化程度的高低，可把I&#x2F;O设备的控制方式分为四类：循环测试I&#x2F;O方式、I&#x2F;O中断方式、DMA方式和通道方式。</p>\n<ul>\n<li><p>I&#x2F;O中断方式<br>与循环测试方式相比，I&#x2F;O中断方式使CPU的利用率大大提高了。但缺点是由于每台设备每次输入／输出一个数据，都要求中断CPU，当系统配置的设备较多时，系统进行中断处理的次数就很多，这会使CPU的有效计算时间大大减少。为减少I&#x2F;O中断处理对CPU造成的负担，又出现了通道方式和DMA方式。</p>\n</li>\n<li><p>通道方式<br>在大、中型和超级小型机中，一般采用I&#x2F;O通道控制I&#x2F;O设备的各种操作。I&#x2F;O通道是用来控制外部设备与主存之间进行成批数据传输的部件。每个通道可以连接多台外部设备并控制它们的I&#x2F;O操作。通道有自己的一套简单的指令系统和执行通道程序，通道接收CPU的委托，而又独立于CPU工作。因此，可以把通道看做是一台小型的处理I&#x2F;O的处理机，或称I&#x2F;O处理机。<br>与前面两种I&#x2F;O方式相比，通道方式有更强的I&#x2F;O处理能力。有关I&#x2F;O的工作，CPU委托通道去做，当通道完成了I&#x2F;O任务后，向CPU发中断信号，请求CPU处理。这样就使CPU基本上摆脱了I&#x2F;O控制工作，并大大提高了CPU与外部设备的并行工作的程度。</p>\n</li>\n<li><p>DMA方式<br>在DMA方式中，I&#x2F;O控制器有更强的功能。它除了具有上述的中断功能外，还有一个DMA控制机构。在DMA控制器的控制下，设备和主存之间可成批地进行数据交换，而不用CPU干预。这样既大大减轻了CPU的负担，也使I&#x2F;O的数据传送速度大大提高。在DMA方式下，允许DMA控制器“接管”地址线的控制权，而直接控制DMA控制器与主存的数据交换。因此，I&#x2F;O设备与主存之间的数据传送不需要CPU介入，从而减轻了CPU的负担。</p>\n</li>\n</ul>\n<h3 id=\"UNIX系统设备管理的主要特点\"><a href=\"#UNIX系统设备管理的主要特点\" class=\"headerlink\" title=\"UNIX系统设备管理的主要特点\"></a>UNIX系统设备管理的主要特点</h3><p>  1．将外部设备看做文件，由文件系统统一处理<br>  2．系统的设备配置灵活、方便<br>  3．使用块设备缓冲技术，提高了文件系统的存取速度块设备的文件存储部分是文件系统存在的介质，而文件系统与用户界面的联系最为密切，故文件系统存取文件的效率是十分重要的。文件系统通过高速缓冲机制存取文件数据，缓冲机制调节核心与文件存储设备之间的数据流。UNIX提供由数据缓冲区组成的高速缓冲，每个缓冲区的大小为512字节。当用户程序要把信息写入文件时，先写入缓冲区里立即返回，由系统作延迟写处理。当用户程序要从磁盘读文件信息时，先要查看在缓冲区缓冲区中有无含有此信息的块，如果有就不必启动磁盘I&#x2F;O，可立即从缓冲区内取出。这种做法大大加快了文件的访问速度。</p>\n<ul>\n<li>UNIX缓冲区的管理<br>对文件系统的一切存取操作，核心都能通过每次直接从磁盘上读或往磁盘上写来实现。但磁盘的传输速率与CPU的速度相比还是慢的。为了加快系统的响应时间和增加系统的吞吐量，UNIX构造了一个由高速缓冲组成的内部数据缓冲池，以降低磁盘的存取频率。UNIX缓冲管理策略试图将尽可能多的有用数据保存在高速缓冲中。核心体系结构中的高速缓冲模块的位置处于文件子系统与块设备驱动程序之间。当从磁盘中读数据时，核心试图先从高速缓冲区中读。如果数据已在高速缓冲中，核心可以不必启动磁盘I&#x2F;O。如果数据不在该高速缓冲区中，则核心从磁盘上读数据，并将其暂时保存在缓冲区中。类似地，要往磁盘上写数据时，也先往高速缓冲区中写入，以便核心随后又试图读它时，它能在高速缓冲中。但是，被写在高速缓冲中的数据要延迟写到非往磁盘上写不可的时候才进行。所以，高速缓冲模块的算法实现了数据的预先缓存和延迟发送的功能。</li>\n</ul>\n<h2 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h2><p>文件的物理结构：连续文件、串联文件、随机文件、索引文件</p>\n<h3 id=\"文件目录\"><a href=\"#文件目录\" class=\"headerlink\" title=\"文件目录\"></a>文件目录</h3><p>文件系统是用户和外部设备之间的接口和界面。用户可通过文件系统去管理和使用各种设备介质上的信息。文件系统的大部分工作是为了解决“用户所需的信息结构及其操作”与“设备介质的实际结构和I&#x2F;O指令”之间的差异。用户所希望的信息结构是按照简单的逻辑关系组织在一起的，他们所希望的操作是一些只用名字就能存取所需信息的读写操作。然而，计算机只能使用各种I&#x2F;O指令去存取相应介质上的信息，其信息结构又是按照设备介质的各自特点组织的。因此，文件系统所要解决的核心问题，就是按照充分发挥主机和外部设备效率的原则，把信息的逻辑结构映像成设备介质上的物理结构，把用户的文件操作转换成相应的I&#x2F;O指令。转换过程所使用的主要数据结构是文件目录和辅存空间使用情况表。这样，文件目录就将每个文件的符号名和它们在辅存空间的物理地址与有关文件情况的说明信息联系起来了。因此，用户只需向系统提供一个文件符号名，系统就能准确地找出所要的文件来，这就是文件系统的基本功能。实现符号名与具体物理地址之间的转换，其主要环节是查目录。所以，目录的编排应以如何能准确地找到所需的文件为原则，而选择查目录的方法应以查找速度快为准则。</p>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>无</p>\n"},{"title":"读书与做人","date":"2022-09-11T13:56:05.000Z","_content":"\n# 信息\n\n《读书与做人》 季羡林 国际文化出版公司\n\n# 摘录\n\n- 除了马克思主义以外，古今中外一些所谓唯心主义哲学家的著作，他们的思维方式和推理方式，也要认真学习。百分之百的唯物主义哲学家和百分之百的唯心主义哲学家，都是没有的。“智者千虑，必有一失”。我们千万不要像过去那样把十分复杂的问题简单化和教条化。                                                                             \n- 不能说假话，但也不必说真话。\n- 遇事必须深思熟虑，先考虑可行性，考虑的方面越广越好。然后再考虑不可行性，也是考虑的方面越广越好。正反两面仔细考虑完以后，就必须加以比较，做出决定，立即行动。如果你考虑正面，又考虑反面之后，再回头来考虑正面，又再考虑反面，那么，如此循环往复，终无宁日，最终成为考虑的巨人，行动的侏儒。\n- 最好能背诵几百首旧诗词和几十篇古文，让它们随时涵蕴于你们心中，低吟于你们口头。这对于你们的文学创作和人文素质的提高，都会有极大的好处。不管你们现在或将来是教书、研究、经商、从政，或者是专业作家，都是如此，概莫能外。\n- 能够百分之六十为他人着想，百分之四十为自己着想，他就是一个及格的好人。\n\n# 感想\n\n哲学方面可以考虑以马克思主义为主，其他思想为辅，兼顾唯物主义和唯心主义；需要考虑说话的技巧，假话绝不说，真话不说全；做决定时，广泛考虑正反两面后果断做决定；考虑背一些诗词和古文。\n","source":"_posts/读书与做人.md","raw":"---\ntitle: 读书与做人\ndate: 2022-09-11 21:56:05\ncategories: \n- 读书\ntags: \n- 读书与做人\n---\n\n# 信息\n\n《读书与做人》 季羡林 国际文化出版公司\n\n# 摘录\n\n- 除了马克思主义以外，古今中外一些所谓唯心主义哲学家的著作，他们的思维方式和推理方式，也要认真学习。百分之百的唯物主义哲学家和百分之百的唯心主义哲学家，都是没有的。“智者千虑，必有一失”。我们千万不要像过去那样把十分复杂的问题简单化和教条化。                                                                             \n- 不能说假话，但也不必说真话。\n- 遇事必须深思熟虑，先考虑可行性，考虑的方面越广越好。然后再考虑不可行性，也是考虑的方面越广越好。正反两面仔细考虑完以后，就必须加以比较，做出决定，立即行动。如果你考虑正面，又考虑反面之后，再回头来考虑正面，又再考虑反面，那么，如此循环往复，终无宁日，最终成为考虑的巨人，行动的侏儒。\n- 最好能背诵几百首旧诗词和几十篇古文，让它们随时涵蕴于你们心中，低吟于你们口头。这对于你们的文学创作和人文素质的提高，都会有极大的好处。不管你们现在或将来是教书、研究、经商、从政，或者是专业作家，都是如此，概莫能外。\n- 能够百分之六十为他人着想，百分之四十为自己着想，他就是一个及格的好人。\n\n# 感想\n\n哲学方面可以考虑以马克思主义为主，其他思想为辅，兼顾唯物主义和唯心主义；需要考虑说话的技巧，假话绝不说，真话不说全；做决定时，广泛考虑正反两面后果断做决定；考虑背一些诗词和古文。\n","slug":"读书与做人","published":1,"updated":"2022-10-16T08:14:56.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9ye38wl001kq8t71c3b6ddo","content":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《读书与做人》 季羡林 国际文化出版公司</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li>除了马克思主义以外，古今中外一些所谓唯心主义哲学家的著作，他们的思维方式和推理方式，也要认真学习。百分之百的唯物主义哲学家和百分之百的唯心主义哲学家，都是没有的。“智者千虑，必有一失”。我们千万不要像过去那样把十分复杂的问题简单化和教条化。                                                                             </li>\n<li>不能说假话，但也不必说真话。</li>\n<li>遇事必须深思熟虑，先考虑可行性，考虑的方面越广越好。然后再考虑不可行性，也是考虑的方面越广越好。正反两面仔细考虑完以后，就必须加以比较，做出决定，立即行动。如果你考虑正面，又考虑反面之后，再回头来考虑正面，又再考虑反面，那么，如此循环往复，终无宁日，最终成为考虑的巨人，行动的侏儒。</li>\n<li>最好能背诵几百首旧诗词和几十篇古文，让它们随时涵蕴于你们心中，低吟于你们口头。这对于你们的文学创作和人文素质的提高，都会有极大的好处。不管你们现在或将来是教书、研究、经商、从政，或者是专业作家，都是如此，概莫能外。</li>\n<li>能够百分之六十为他人着想，百分之四十为自己着想，他就是一个及格的好人。</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>哲学方面可以考虑以马克思主义为主，其他思想为辅，兼顾唯物主义和唯心主义；需要考虑说话的技巧，假话绝不说，真话不说全；做决定时，广泛考虑正反两面后果断做决定；考虑背一些诗词和古文。</p>\n","site":{"data":{}},"wordcount":530,"excerpt":"","more":"<h1 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h1><p>《读书与做人》 季羡林 国际文化出版公司</p>\n<h1 id=\"摘录\"><a href=\"#摘录\" class=\"headerlink\" title=\"摘录\"></a>摘录</h1><ul>\n<li>除了马克思主义以外，古今中外一些所谓唯心主义哲学家的著作，他们的思维方式和推理方式，也要认真学习。百分之百的唯物主义哲学家和百分之百的唯心主义哲学家，都是没有的。“智者千虑，必有一失”。我们千万不要像过去那样把十分复杂的问题简单化和教条化。                                                                             </li>\n<li>不能说假话，但也不必说真话。</li>\n<li>遇事必须深思熟虑，先考虑可行性，考虑的方面越广越好。然后再考虑不可行性，也是考虑的方面越广越好。正反两面仔细考虑完以后，就必须加以比较，做出决定，立即行动。如果你考虑正面，又考虑反面之后，再回头来考虑正面，又再考虑反面，那么，如此循环往复，终无宁日，最终成为考虑的巨人，行动的侏儒。</li>\n<li>最好能背诵几百首旧诗词和几十篇古文，让它们随时涵蕴于你们心中，低吟于你们口头。这对于你们的文学创作和人文素质的提高，都会有极大的好处。不管你们现在或将来是教书、研究、经商、从政，或者是专业作家，都是如此，概莫能外。</li>\n<li>能够百分之六十为他人着想，百分之四十为自己着想，他就是一个及格的好人。</li>\n</ul>\n<h1 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h1><p>哲学方面可以考虑以马克思主义为主，其他思想为辅，兼顾唯物主义和唯心主义；需要考虑说话的技巧，假话绝不说，真话不说全；做决定时，广泛考虑正反两面后果断做决定；考虑背一些诗词和古文。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Hexo博客备份/git文件.png","slug":"git文件.png","post":"cl9ye38vv0005q8t7ah2uhgtk","modified":0,"renderable":0},{"_id":"source/_posts/git学习整理/1829507-20220316234843811-601091411.png","slug":"1829507-20220316234843811-601091411.png","post":"cl9ye38vw0006q8t7ej1s830c","modified":0,"renderable":0},{"_id":"source/_posts/基于GitHub和Hexo搭建博客/组件版本.png","slug":"组件版本.png","post":"cl9ye38vz000bq8t77ihncz17","modified":0,"renderable":0},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/1.jpg","slug":"1.jpg","post":"cl9ye38w7000uq8t73ca4bplc","modified":0,"renderable":0},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/2.jpg","slug":"2.jpg","post":"cl9ye38w7000uq8t73ca4bplc","modified":0,"renderable":0},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/3.jpg","slug":"3.jpg","post":"cl9ye38w7000uq8t73ca4bplc","modified":0,"renderable":0},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/4.jpg","slug":"4.jpg","post":"cl9ye38w7000uq8t73ca4bplc","modified":0,"renderable":0},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/5.jpg","slug":"5.jpg","post":"cl9ye38w7000uq8t73ca4bplc","modified":0,"renderable":0},{"_id":"source/_posts/计算机组成原理与汇编语言程序设计/6.jpg","slug":"6.jpg","post":"cl9ye38w7000uq8t73ca4bplc","modified":0,"renderable":0},{"_id":"source/_posts/操作系统原理/1.jpg","slug":"1.jpg","post":"cl9ye38wl001jq8t7ei8agunb","modified":0,"renderable":0},{"_id":"source/_posts/操作系统原理/10.jpg","slug":"10.jpg","post":"cl9ye38wl001jq8t7ei8agunb","modified":0,"renderable":0},{"_id":"source/_posts/操作系统原理/2.jpg","slug":"2.jpg","post":"cl9ye38wl001jq8t7ei8agunb","modified":0,"renderable":0},{"_id":"source/_posts/操作系统原理/3.jpg","slug":"3.jpg","post":"cl9ye38wl001jq8t7ei8agunb","modified":0,"renderable":0},{"_id":"source/_posts/操作系统原理/4.jpg","slug":"4.jpg","post":"cl9ye38wl001jq8t7ei8agunb","modified":0,"renderable":0},{"_id":"source/_posts/操作系统原理/5.jpg","slug":"5.jpg","post":"cl9ye38wl001jq8t7ei8agunb","modified":0,"renderable":0},{"_id":"source/_posts/操作系统原理/6.jpg","slug":"6.jpg","post":"cl9ye38wl001jq8t7ei8agunb","modified":0,"renderable":0},{"_id":"source/_posts/操作系统原理/7.jpg","slug":"7.jpg","post":"cl9ye38wl001jq8t7ei8agunb","modified":0,"renderable":0},{"_id":"source/_posts/操作系统原理/9.jpg","slug":"9.jpg","post":"cl9ye38wl001jq8t7ei8agunb","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cl9ye38vo0001q8t7dtwj6q7b","category_id":"cl9ye38vt0003q8t74l8qg7ee","_id":"cl9ye38w0000dq8t77n17hf0b"},{"post_id":"cl9ye38vr0002q8t71du74pcd","category_id":"cl9ye38vx0008q8t74p5q0w71","_id":"cl9ye38w4000kq8t76bt46bq3"},{"post_id":"cl9ye38w0000cq8t7cnxr85kw","category_id":"cl9ye38vx0008q8t74p5q0w71","_id":"cl9ye38w5000oq8t7dbyfeoa0"},{"post_id":"cl9ye38w1000gq8t7dpnrgcz2","category_id":"cl9ye38vx0008q8t74p5q0w71","_id":"cl9ye38w6000rq8t70mar5bb0"},{"post_id":"cl9ye38vv0005q8t7ah2uhgtk","category_id":"cl9ye38w0000eq8t7e2p04vzu","_id":"cl9ye38w9000vq8t74wbrftx5"},{"post_id":"cl9ye38w4000nq8t7bp032856","category_id":"cl9ye38vx0008q8t74p5q0w71","_id":"cl9ye38w9000xq8t7btusc5sh"},{"post_id":"cl9ye38vw0006q8t7ej1s830c","category_id":"cl9ye38w4000lq8t71bm0472k","_id":"cl9ye38wa0010q8t73cie6kws"},{"post_id":"cl9ye38w6000qq8t72by07n55","category_id":"cl9ye38vx0008q8t74p5q0w71","_id":"cl9ye38wa0012q8t72z88dyl9"},{"post_id":"cl9ye38w7000uq8t73ca4bplc","category_id":"cl9ye38vx0008q8t74p5q0w71","_id":"cl9ye38wb0015q8t77woq5wwo"},{"post_id":"cl9ye38vx0007q8t78fgn090j","category_id":"cl9ye38vx0008q8t74p5q0w71","_id":"cl9ye38wb0017q8t7fkt00ha6"},{"post_id":"cl9ye38vz000bq8t77ihncz17","category_id":"cl9ye38w0000eq8t7e2p04vzu","_id":"cl9ye38wc0018q8t736kpfyo5"},{"post_id":"cl9ye38w3000iq8t703w5gi4o","category_id":"cl9ye38wb0013q8t7ea7yao8m","_id":"cl9ye38wc001bq8t774001pal"},{"post_id":"cl9ye38wl001jq8t7ei8agunb","category_id":"cl9ye38vx0008q8t74p5q0w71","_id":"cl9ye38wm001nq8t71ciudhx5"},{"post_id":"cl9ye38wl001kq8t71c3b6ddo","category_id":"cl9ye38vx0008q8t74p5q0w71","_id":"cl9ye38wn001oq8t72vxb05uj"}],"PostTag":[{"post_id":"cl9ye38vo0001q8t7dtwj6q7b","tag_id":"cl9ye38vu0004q8t7eyke0lfc","_id":"cl9ye38vz000aq8t77k27a5n8"},{"post_id":"cl9ye38vr0002q8t71du74pcd","tag_id":"cl9ye38vy0009q8t7chbvdaxs","_id":"cl9ye38w2000hq8t7b2jq5f31"},{"post_id":"cl9ye38w0000cq8t7cnxr85kw","tag_id":"cl9ye38vy0009q8t7chbvdaxs","_id":"cl9ye38w4000jq8t72nwq6ms5"},{"post_id":"cl9ye38vv0005q8t7ah2uhgtk","tag_id":"cl9ye38w1000fq8t70w71f60m","_id":"cl9ye38w5000pq8t72t7s3n7r"},{"post_id":"cl9ye38vw0006q8t7ej1s830c","tag_id":"cl9ye38w4000mq8t78ole34ib","_id":"cl9ye38w9000wq8t79jka9jw1"},{"post_id":"cl9ye38vx0007q8t78fgn090j","tag_id":"cl9ye38w7000tq8t7hrswacp3","_id":"cl9ye38wa0011q8t72ebr2ls4"},{"post_id":"cl9ye38vz000bq8t77ihncz17","tag_id":"cl9ye38w1000fq8t70w71f60m","_id":"cl9ye38wb0016q8t7bfjt27vu"},{"post_id":"cl9ye38w1000gq8t7dpnrgcz2","tag_id":"cl9ye38wb0014q8t7bo9ffvhn","_id":"cl9ye38wc001aq8t7ak4aatmk"},{"post_id":"cl9ye38w3000iq8t703w5gi4o","tag_id":"cl9ye38wc0019q8t791ky72os","_id":"cl9ye38wc001dq8t796tq4zwb"},{"post_id":"cl9ye38w4000nq8t7bp032856","tag_id":"cl9ye38wc001cq8t7201lh41x","_id":"cl9ye38wd001fq8t7ddyc27c2"},{"post_id":"cl9ye38w6000qq8t72by07n55","tag_id":"cl9ye38w7000tq8t7hrswacp3","_id":"cl9ye38wd001hq8t7axfthbh0"},{"post_id":"cl9ye38w7000uq8t73ca4bplc","tag_id":"cl9ye38wd001gq8t7dcxx69vr","_id":"cl9ye38wd001iq8t795vgduvo"},{"post_id":"cl9ye38wl001kq8t71c3b6ddo","tag_id":"cl9ye38vy0009q8t7chbvdaxs","_id":"cl9ye38wm001mq8t72rpigrci"},{"post_id":"cl9ye38wl001jq8t7ei8agunb","tag_id":"cl9ye38wm001lq8t7hgeb3011","_id":"cl9ye38wn001pq8t7fyaihdub"}],"Tag":[{"name":"ubuntu","_id":"cl9ye38vu0004q8t7eyke0lfc"},{"name":"读书与做人","_id":"cl9ye38vy0009q8t7chbvdaxs"},{"name":"博客搭建","_id":"cl9ye38w1000fq8t70w71f60m"},{"name":"git","_id":"cl9ye38w4000mq8t78ole34ib"},{"name":"心理","_id":"cl9ye38w7000tq8t7hrswacp3"},{"name":"理财","_id":"cl9ye38wb0014q8t7bo9ffvhn"},{"name":"排序","_id":"cl9ye38wc0019q8t791ky72os"},{"name":"养生","_id":"cl9ye38wc001cq8t7201lh41x"},{"name":"计算机结构","_id":"cl9ye38wd001gq8t7dcxx69vr"},{"name":"操作系统","_id":"cl9ye38wm001lq8t7hgeb3011"}]}}