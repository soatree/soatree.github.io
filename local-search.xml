<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>传习录</title>
    <link href="/2023/04/22/%E4%BC%A0%E4%B9%A0%E5%BD%95/"/>
    <url>/2023/04/22/%E4%BC%A0%E4%B9%A0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《传习录》 王阳明 江苏文艺出版社</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>略</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="知行"><a href="#知行" class="headerlink" title="知行"></a>知行</h2><ul><li>良知之在人心，不但圣贤，虽常人亦无不如此。若无有物欲牵蔽，但循着良知发用流行将去，即无不是道。但在常人多为物欲牵蔽，不能循得良知。</li><li>真知即所以为行，不行不足谓之知。</li><li>未有知而不行者。知而不行，只是未知。</li><li>无善无恶是心之体，有善有恶是意之动。知善知恶是良知，为善去恶是格物。</li><li>问：“先生尝谓善恶只是一物。善恶两端，如冰炭相反，如何谓只一物？” 先生曰：“至善者，心之本体。本体上才过当些子，便是恶了。不是有一个善，却又有一个恶来相对也。故善恶只是一物。” 直因闻先生之说，则知程子所谓“善固性也，恶亦不可不谓之性”，又曰“善恶皆天理。谓之恶者本非恶，但于本性上过与不及之间耳”，其说皆无可疑。</li></ul><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>先生尝语学者曰：“心体上着不得一念留滞，就如眼着不得些子尘沙。些子能得几多？满眼便昏天黑地了。” 又曰：“这一念不但是私念，便好的念头亦着不得些子。如眼中放些金玉屑，眼亦开不得了。”</li><li>问：“圣人‘生知安行’是自然的，如何？有甚功夫？” 先生曰：“‘知行’二字即是功夫，但有浅深难易之殊耳。良知原是精精明明的，如欲孝亲。‘生知安行’的只是依此良知实落尽孝而已；‘学知利行’者只是时时省觉，务要依此良知尽孝已；至于‘困知勉行’者，蔽锢已深，虽要依此良知去孝，又为私欲所阻，是以不能，必须加人一己百、人十己千之功，方能依此良知以尽其孝。圣人虽是‘生知安行’，然其心不敢自是，肯做‘困知勉行’的功夫。‘困知勉行’的却要思量做‘生知安行’的事，怎生成得？”</li><li>先生曰：“学问功夫，于一切声利嗜好俱能脱落殆尽，尚有一种生死念头毫发挂带，便于全体有未融释处。人于生死念头，本从生身命根上带来，故不易去。若于此处见得破、透得过，此心全体方是流行无碍，方是尽性至命之学。”</li><li>又曰：“诸君功夫，最不可助长。上智绝少，学者无超入圣人之理。一起一伏，一进一退，自是功夫节次。不可以我前日用得功夫了，今却不济，便要矫强做出一个没破绽的模样，这便是助长，连前些子功夫都坏了。此非小过，譬如行路的人遭一蹶跌，起来便走，不要欺人，做那不曾跌倒的样子出来。诸君只要常常怀个‘遁世无闷，不见是而无闷’之心，依此良知，忍耐做去，不管人非笑，不管人毁谤，不管人荣辱，任他功夫有进有退，我只是这致良知的主宰不息，久久自然有得力处，一切外事亦自能不动。” 又曰：“人若着实用功，随人毁谤，随人欺慢，处处得益，处处是进德之资。若不用功，只是魔也，终被累倒。”</li><li>先生尝谓：“人但得好善如好好色，恶恶如恶恶臭，便是圣人。” 直初时闻之，觉甚易，后体验得来，此个功夫着实是难。如一念虽知好善恶恶，然不知不觉，又夹杂去了。才有夹杂，便不是好善如好好色、恶恶如恶恶臭的心。善能实实的好，是无念不善矣；恶能实实的恶，是无念及恶矣。如何不是圣人？故圣人之学，只是一诚而已。</li><li>先生曰：“我这里自有功夫，何缘得他来？只为尔功夫断了，便蔽其知。既断了，则继续旧功便是。何必如此？” 九川曰：“直是难鏖。虽知，丢他不去。” 先生曰：“须是勇。用功久，自有勇。</li><li>又问：“用功收心时，有声、色在前，如常闻见，恐不是专一？” 曰：“如何欲不闻见？除是槁木死灰，耳聋目盲则可。只是虽闻见而不流去便是。” 曰：“昔有人静坐，其子隔壁读书，不知其勤惰。程子称其甚敬。何如？” 曰：“伊川恐亦是讥他。”</li><li>先生又曰：“吾辈用力，只求日减，不求日增。减得一分人欲，便是复得一分天理，何等轻快脱洒！何等简易！”</li><li>“只存得此心常见在便是学。过去未来事，思之何益？徒放心耳。”</li><li>曰仁云：“心犹镜也，圣人心如明镜，常人心如昏镜。近世格物之说，如以镜照物，照上用功，不知镜尚昏在，何能照？先生之格物，如磨镜而使之明，磨上用功，明了后亦未尝废照。”</li><li>是知圣人遇此时，方有此事。只怕镜不明，不怕物来不能照。讲求事变，亦是照时事。然学者却须先有个明的工夫。学者惟患此心之未能明，不患事变之不能尽。</li></ul><h2 id="警惕"><a href="#警惕" class="headerlink" title="警惕"></a>警惕</h2><ul><li>孟子云：“学问之道无他，求其放心而已矣。”非若后世广记博诵古人之言词，以为好古，而汲汲然惟以求功名利达之具于外者也。“</li><li>今曰“养生以清心寡欲为要”，只“养生”二字便是自私自利、将迎意必之根。有此病根潜伏于中，宜其有“灭于东而生于西”“引犬上堂而逐之”之患也。</li><li>先生曰：“人生大病，只是一‘傲’字。为子而傲必不孝，为臣而傲必不忠，为父而傲必不慈，为友而傲必不信。故象与丹朱俱不肖，亦只一‘傲’字，便结果了此生。诸君常要体此。人心本是天然之理，精精明明，无纤介染着，只是一‘无我’而已。胸中切不可‘有’，‘有’即‘傲’也。古先圣人许多好处，也只是‘无我’而已。‘无我’自能谦，谦者众善之基，傲者众恶之魁。”</li><li>先生曰：“此‘格物’之说未透。心何尝有内外？即如惟浚今在此讲论，又岂有一心在内照管？这听讲说时专敬，即是那静坐时心。功夫一贯，何须更起念头？人须在事上磨炼，做功夫乃有益。若只好静，遇事便乱，终无长进。那静时功夫亦差似收敛，而实放溺也。”</li><li>曰：“只要去人欲、存天理，方是功夫。静时念念去人欲、存天理，动时念念去人欲、存天理，不管宁静不宁静。若靠那宁静，不惟渐有喜静厌动之弊，中间许多病痛，只是潜伏在，终不能绝去，遇事依旧滋长。以循理为主，何尝不宁静？以宁静为主，未必能循理。”</li><li>先生曰：“是徒知静养，而不用克己工夫也。如此，临事便要倾倒。人须在事上磨，方立得住，方能‘静亦定，动亦定’。”</li><li>曰：“虽未相着，然平日好色、好利、好名之心，原未尝无。既未尝无，即谓之有。既谓之有，则亦不可谓无偏倚。譬之病疟之人，虽有时不发，而病根原不曾除，则亦不得谓之无病之人矣。须是平日好色、好利、好名等项一应私心扫除荡涤，无复纤毫留滞，而此心全体廓然，纯是天理，方可谓之喜怒哀乐‘未发之中’，方是天下之大本。”</li><li>“克己须要扫除廓清，一毫不存方是。有一毫在，则众恶相引而来。”</li><li>人于此处多认做天理当忧，则一向忧苦，不知已是‘有所忧患，不得其正’。大抵七情所感，多只是过，少不及者。才过便非心之本体。必须调停适中始得。</li><li>问“有所忿懥”一条。 先生曰：“忿懥几件，人心怎能无得，只是不可有所耳。凡人忿懥，着了一分意思，便怒得过当，非廓然大公之体了。故有所忿懥，便不得其正也。如今于凡忿懥等件，只是个物来顺应，不要着一分意思，便心体廓然大公，得其本体之正了。且如出外见人相斗，其不是的，我心亦怒。然虽怒，却此心廓然，不曾动些子气。如今怒人，亦得如此，方才是正。”</li><li>“喜怒哀乐，本体自是中和的，才自家着些意思，便过不及，便是私。”</li><li>问孟子言“执中无权犹执一”。 先生曰：“中只是天理，只是易。随时变易，如何执得？须是因时制宜，难预先定一个规矩在。如后世儒者，要将道理一一说得无罅漏，立定个格式，此正是执一。”</li><li>“日间工夫，觉纷扰，则静坐；觉懒看书，则且看书。是亦因病而药。”</li><li>先生曰：“好色则一心在好色上，好货则一心在好货上，可以为主一乎？是所谓逐物，非主一也。主一是专主一个天理。”</li><li>子夏笃信圣人，曾子反求诸己。笃信固亦是，然不如反求之切。今既不得于心，安可狃于旧闻，不求是当？</li></ul><h2 id="交友"><a href="#交友" class="headerlink" title="交友"></a>交友</h2><ul><li>先生曰：“大凡朋友，须箴规指摘处少，诱掖奖劝意多，方是。” 后又戒九川云：“与朋友论学，须委曲谦下，宽以居之。”</li><li>先生曰：“凡朋友问难，纵有浅近粗疏，或露才扬己，皆是病发，当因其病而药之可也，不可便怀鄙薄之心。非君子与人为善之心矣。”</li><li>“处朋友，务相下，则得益，相上则损。”</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>格物致知，知行合一，诚意坚持</p>]]></content>
    
    
    <categories>
      
      <category>读书与做人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人类简史</title>
    <link href="/2023/03/31/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"/>
    <url>/2023/03/31/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《人类简史：从动物到上帝》 尤瓦尔·赫拉利　中信出版社</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>略</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h2><ul><li>农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚构故事也更为细致完整。人类几乎从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照着这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化”。</li><li>根据这种说法，文化并不是某些人为了剥削他人而设计出的阴谋，而是因为种种机缘巧合所出现的心理寄生虫，从出现之后就开始剥削所有受到感染的人。</li><li>然而，以上所有的区别，不管是自由人／奴隶、白人／黑人、富人／穷人，都只是虚构的想象所建构出来的。（后面会另外来谈男女的阶级问题。）然而历史的铁则告诉我们，每一种由想象建构出来的秩序，都绝不会承认自己出于想象和虚构，而会大谈自己是自然、必然的结果。</li><li>但人类可就不同了，这种事总是不断发生。因为智人的社会秩序是通过想象建构，维持秩序所需的关键信息无法单纯靠DNA复制就传给后代，需要通过各种努力，才能维持种种法律、习俗、程序、礼仪，否则社会秩序很快就会崩溃。</li><li>为了改变现有由想象建构出的秩序，就得先用想象建构出另一套秩序才行。</li><li>身为人类，我们不可能脱离想象所建构出的秩序。每一次我们以为自己打破了监狱的高墙、迈向自由的前方，其实只是到了另一间更大的监狱，把活动范围稍稍加以扩大。</li><li>“主体间”事物的存在，靠的是许多个人主观意识之间的连接网络。就算有某个人改变了想法，甚至过世，对这项事物的影响并不大。但如果是这个网络里面的大多数都死亡或是改变了想法，这种“主体间”的事物就会发生改变或是消失。之所以会有事物存在于主体之间，其目的并不是想存心骗人，也不是只想打哈哈敷衍。虽然它们不像放射线会直接造成实质影响，但对世界的影响仍然不容小觑。历史上有许多最重要的驱动因素，都是这种存在于主体之间的概念想法：法律、金钱、神、国家。</li><li>想象建构的秩序并非个人主观的想象，而是存在于主体之间（inter-subjective），存在于千千万万人共同的想象之中。</li><li>多数人很难接受自己的生活秩序只是虚构的想象，但事实是我们从出生就已经置身于这种想象之中，而且连我们的欲望也深受其影响。于是，个人欲望也就成为虚构秩序最强大的守护者。</li><li>消费主义告诉我们，想要快乐，就该去买更多的产品、更多的服务。如果觉得少了什么，或是有什么不够舒服的地方，那很可能是该买些什么商品（新车、新衣服、有机食品），或是买点什么服务（清洁工、心理咨询、瑜伽课）。就连每一则电视广告，也都是个小小的虚构故事，告诉你买了什么产品或服务可以让日子更好。浪漫主义告诉我们，为了要尽量发挥潜力，就必须尽量累积不同的经验。必须体会不同的情感，尝试不同的关系，品尝不同的美食，还必须学会欣赏不同风格的音乐。而其中最好的一种办法，就是摆脱日常生活及工作，远离熟悉的环境，前往遥远的国度，好亲身“体验”不同的文化、气味、美食和规范。我们总会不断听到浪漫主义的神话，告诉我们“那次的经验让我眼界大开，从此整个生活都不一样了”。现代人之所以要花费大把银子到国外度假，正是因为他们真正相信了浪漫的消费主义神话。</li><li>我们困于人类文化太久了</li></ul><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul><li>历史上的每一个时间点，都像是一个十字路口。虽然从过去到现在已经只剩单行道，但到未来却有无数岔路可走。其中某些路比较宽、比较平坦，路标比较明确，所以也是比较可能的选择。然而，历史有时候就是选了一些完全出人意表的道路。</li><li>无论我们把历史发展的动力称为博弈理论、后现代主义或迷因学，“提升人类福祉”绝不是其主要目标。并没有证据显示史上最成功的文化就一定是对智人最好的文化。而就像演化一样，历史的演进并不在意生物个体是否幸福。</li></ul><h2 id="生活方式"><a href="#生活方式" class="headerlink" title="生活方式"></a>生活方式</h2><ul><li>农业带来的压力影响深远，这正是后代大规模政治和社会制度的基础。但可悲的是，虽然农民勤劳不懈、希望能够保障自己未来的经济安全，但这几乎从来未曾实现。不管在任何地方，都出现了统治者和精英阶级，不仅靠着农民辛苦种出的食粮维生，还几乎全征收抢光，只留给农民勉强可过活的数量。</li><li>农业时代人类的空间缩小，但时间却变长了。一般来说，采集者不会花太多心思考虑下周或下个月的事，但农民却会想象预测着未来几年甚至几十年的事。绝大多数的农民都是住在永久聚落里，只有少数是游牧民族。“定居”这件事，让大多数人的活动范围大幅缩小。远古狩猎采集者的活动范围可能有几十甚至上百平方公里。当时这片范围都是他们的“家”，有山丘、溪流、树林，还有开阔的天空。但对农民而言，几乎整天就是在一小片田地或果园里工作，就算回到“家”，这时的房子也就是个用木头、石头或泥巴盖起的局促结构，每边再长也不过几十米。一般来说，农民就会和房屋这种构造建立起非常强烈的连接。这场革命意义深远，除了影响建筑，更影响了心理。在农业革命之后，人类成了远比过去更以自我为中心的生物，与“自己家”紧密相连，但与周遭其他物种画出界线。</li><li>三不五时，总有些反对提高机械化和自动化的勒德分子（Luddite）坚持不用电子邮件，就像几千年前，也有某些人类部落拒绝农业，所以躲过了奢侈生活的陷阱。</li><li>于是，种种想让生活变得轻松的努力，反而给人带来无穷的麻烦；而且这可不是史上的最后一次。就算今天，仍然如此。有多少年轻的大学毕业生投身大企业、从事各种劳心劳力的工作，发誓要努力赚钱，好在35岁就退休，去从事他们真正有兴趣的事业？但等他们到了35岁，却发现自己背着巨额贷款，要付子女的学费，要养在高级住宅区的豪宅，每家得有两部车，而且觉得生活里不能没有高级红酒和国外的假期。他们该怎么做？他们会放下一切，回去野外采果子挖树根吗？当然不可能，而是加倍努力，继续把自己累得半死。</li><li>谁该负责？这背后的主谋，既不是国王，不是牧师，也不是商人。真正的主要嫌疑人，就是那极少数的植物物种，其中包括小麦、稻米和马铃薯。人类以为自己驯化了植物，但其实是植物驯化了智人。</li><li>普遍来说，农民的工作要比采集者更辛苦，而且到头来的饮食还要更糟。农业革命可说是史上最大的一桩骗局。</li><li>远在人类还没有发明轮子、文字和铁器之前，智人就已经让全球大约一半的大型兽类魂归西天、就此灭绝。</li><li>采集者之所以能够免受饥饿或营养不良的困扰，秘诀就在于多样化的饮食。相较之下，之后农民的饮食往往种类极少，而且不均衡。</li><li>狩猎采集的生活方式依地区、季节有所不同，但整体而言，比起后来的农夫、牧羊人、工人或上班族，他们的生活似乎要来得更舒适，也更有意义。 在现代的富裕社会，平均每周的工时是40-45小时，发展中国家则是60甚至80小时；但如果是狩猎采集者，就算住在最贫瘠的地区（像是卡拉哈里沙漠），平均每周也只需要工作35-45小时。他们大概只需要每三天打猎一次，每天采集3-6小时。</li></ul><h2 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h2><ul><li>痛苦来自欲望；要从痛苦中解脱，就要放下欲望；而要放下欲望，就必须训练心智，体验事物的本质。</li><li>释迦牟尼找到一种方法可以跳出这种恶性循环。在事物带来快乐或痛苦的时候，重点是要看清事物的本质，而不是着重在它带来的感受，于是就能不再为此所困。虽然感受悲伤，但不要希望悲伤结束，于是虽然仍有悲伤，也能不再为此而困。即使仍然悲伤，也是一种丰硕的经验。虽然感受快乐，但不要希望快乐继续，于是虽然仍有快乐，也能不失去心中的平静。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>智人的现代化发展是血腥的，且生活质量也并不是向好的，我们应该积极挖掘生活的意义，更好地度过此生。</p>]]></content>
    
    
    <categories>
      
      <category>读书与做人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>历史</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每个人的战争</title>
    <link href="/2023/03/25/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%88%98%E4%BA%89/"/>
    <url>/2023/03/25/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%88%98%E4%BA%89/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《每个人的战争:抵御癌症的有效生活方式》 大卫·塞尔旺-施莱伯　广西师范大学出版社</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>略</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="影响因素分析"><a href="#影响因素分析" class="headerlink" title="影响因素分析"></a>影响因素分析</h2><ul><li>抑制和活跃免疫细胞的因素</li></ul><table><thead><tr><th>抑制因素</th><th>活跃因素</th></tr></thead><tbody><tr><td>传统西方饮食</td><td>地中海、印度、亚洲饮食烹饪方式</td></tr><tr><td>长期愤怒和绝望情绪</td><td>平静、快乐的情绪</td></tr><tr><td>与世隔绝</td><td>有家人朋友的支持</td></tr><tr><td>久坐习惯</td><td>规律体育锻炼</td></tr></tbody></table><ul><li>影响炎症的主要因素</li></ul><table><thead><tr><th>抑制因素</th><th>活跃因素</th></tr></thead><tbody><tr><td>传统西方饮食</td><td>地中海、印度、亚洲饮食烹饪方式</td></tr><tr><td>精制糖、白面粉</td><td>杂粮</td></tr><tr><td>工业饲养的红肉、白肉、全脂乳品</td><td>草饲乳品、肉类</td></tr><tr><td>w6脂肪如玉米油、大豆油、葵花籽油</td><td>橄榄油、菜籽油</td></tr><tr><td>长期愤怒和绝望情绪</td><td>平静、快乐的情绪</td></tr><tr><td>久坐习惯</td><td>规律体育锻炼，每周6次，每次30分钟</td></tr></tbody></table><ul><li><p>近来已经发现了多种食品具有抗血管生成功效，包括常见的食用菌类、某些绿茶、辣椒和香草</p></li><li><p>很多加工食品的升糖指数都较高，应尽量食用原始的食物，少吃零食。</p></li><li><p>日常饮食保护</p></li></ul><table><thead><tr><th>少吃</th><th>替代</th></tr></thead><tbody><tr><td>高升糖指数食物</td><td>低升糖指数食物</td></tr><tr><td>油炸、w6脂肪酸</td><td>橄榄油、菜籽油，有机草饲食物，豆制品，水果</td></tr><tr><td>非有机红肉和蛋类、家禽皮</td><td>蔬菜、豆类、有机家禽蛋类、有机草饲红肉（每周不超过200g）、鱼类</td></tr><tr><td>非有机蔬菜</td><td>削皮水果、洗过的蔬菜</td></tr><tr><td>污染的饮用水</td><td>包装水或者过滤水</td></tr></tbody></table><ul><li><p>是的，我也许会比预计的更早去世，但是我也有可能比预计的活得更久。无论发生什么，我都要从现在起尽可能地好好活着。无论最后发生什么，这都是最好的应对方式。</p></li><li><p>抗癌购物单</p></li></ul><p>蛋白质 ·鱼类和贝类（含有硒、维生素D和长链ω-3脂肪酸），特别是三文鱼、鲭鱼、鳗鱼 ·有机肉类和家禽肉（适当食用） ·富含ω-3脂肪酸的蛋类（适当食用）·植物蛋白（豆类、豌豆、豆子、鹰嘴豆、绿豆） ·有机大豆类食品：豆腐、印尼豆豉、味噌、素肉排、豆芽、黄豆、豆奶、豆酸奶（含大豆异黄酮） </p><p>谷类和碳水化合物 ·杂粮面包或发酵面包 ·全粒大米（或印度香米、泰国大米） ·藜麦 ·碾碎的干小麦 ·燕麦片（燕麦粥），牛奶什锦早餐、全麸食品、全麦或燕麦、麸、亚麻籽、黑麦、大麦、斯佩尔特小麦混合的谷类食品 ·尼古拉土豆 ·红薯、山药 ·植物蛋白（见蛋白质一栏） </p><p>脂肪 ·橄榄油 ·亚麻籽油（富含ω-3脂肪酸、含有木酚素、植物油类） ·ω-3黄油 ·鱼肝油（含维生素D） ·菜籽油 </p><p>蔬菜 ·卷心菜：小洋白菜、白菜、大白菜、西兰花、花椰菜等 ·富含β胡萝卜素的蔬菜：胡萝卜、红薯、山药、西葫芦、南瓜、某些品种的法国栗子瓜（也叫北海道南瓜）、西红柿、甜菜等（含维生素A和番茄红素） ·菠菜（含镁） </p><p>蘑菇 ·香菇、灰树花菇、金针菇、褐菇、平菇或土耳其尾菇（含多糖和香菇多糖） </p><p>香草和香料 ·姜黄（姜黄素）与黑胡椒和橄榄油混合食用 ·咖喱 ·荷兰芹和芹菜（含芹菜素） ·唇形科植物：薄荷、百里香、墨角兰、牛至、罗勒属植物和迷迭香（含萜烯） ·葱属植物：大蒜、洋葱、韭葱、大葱、香葱（含二烯丙基二硫） ·肉桂（含原花青素） ·姜（含姜辣素）</p><p>益生菌 ·有机酸奶和酸奶酒、豆酸奶 ·德国泡菜、韩国泡菜 </p><p>具有益生作用的食物 ·大蒜、洋葱、西红柿、芦笋、香蕉、小麦 </p><p>海藻 ·紫菜、海带、裙带菜、海草和红皮藻（含褐藻多糖） </p><p>水果 ·浆果：草莓、覆盆子、蓝莓、黑莓、蔓越橘（含鞣花酸和多酚） ·樱桃（含葡萄二酸） ·石榴汁 ·柑橘类水果：橙、橘子（如果是有机水果，皮也可以吃）、柠檬、葡萄柚（含类黄酮） ·柿子和杏（含维生素A和番茄红素）</p><p>干果 ·核桃和榛子（含植物ω-3和镁元素） ·美洲山核桃（含鞣花酸） ·杏仁（含镁元素） </p><p>饮料 ·过滤水、矿物质水、泉水 ·用柠檬调味的水（或是百里香、鼠尾草、橘子、橙皮） ·绿茶（含茶多酚EGCG），特别是日本绿茶（煎茶、玉露茶、抹茶等） ·姜泡制的饮料（姜辣素） </p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>格物致知，善待每一天</p>]]></content>
    
    
    <categories>
      
      <category>读书与做人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>养生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>曾国藩家书</title>
    <link href="/2023/03/25/%E6%9B%BE%E5%9B%BD%E8%97%A9%E5%AE%B6%E4%B9%A6/"/>
    <url>/2023/03/25/%E6%9B%BE%E5%9B%BD%E8%97%A9%E5%AE%B6%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《曾国藩家书》 曾国藩</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="警句"><a href="#警句" class="headerlink" title="警句"></a>警句</h2><ul><li>些小得失不足患，特患业之不精耳。</li><li>所谓诚意者，即其所知而力行之，是不欺也。知一句便行一句，此力行之事也。此二者并进，下学在此，上达亦在此。（所谓诚意，就是根据知道的去做，诚实不欺。知道一句就按照这句说的去做，这是身体力行的事情。能够做到格物与诚意并进，下可以获取渊博的知识，上可以获得腾达的地位。）</li><li>诸弟每人自立课程，必须有日日不断之功，虽行船走路，俱须带在身边。予除此三事外，他课程不必能有成，而此三事者，将终身以之。（弟弟们每天都要自己立下一些课程，必须要天天坚持，即使是行船走路，也要带在身边。我除了这三件事情以外，其他的课程不一定会有所成就，但是这三件事，我将坚持一生。）</li><li>凡遇牢骚欲发之时，则反躬自思，吾果有何不足，而蓄此不平之气，猛然内省，决然去之。不惟平心谦抑，可以早得科名，亦一养此和气，可以稍减病患。(凡是想要发牢骚的时候，就反躬自省一下，我身上有哪些不足，导致积蓄了满腔怨气，猛然反省，果断将怨气扫除。平心气和、谦虚、克制不仅可以让你早日取得科举功名，还可以减轻病痛。)</li><li>凡人为一事，以专而精，以纷而散。荀子称耳不两听而聪，目不两视而明，庄子称用志不纷，乃凝于神。皆至言也！</li><li>凡与人晋接周旋，若无真意，则不足以感人，然徒有真意而无文饰以将之，则真意亦无所托之以出，《礼》所称“无文不行”也。余生平不讲文饰，到处行不动，近来大悟前非。</li><li>长傲、多言二弊，历观前世卿大夫兴衰，及近日官场所以致祸福之由，未尝不视此二者为枢机，故愿与诸弟共相鉴诫。第能惩此二者，而不能勤奋以图自立，则仍无以兴家而立业，故又在乎振刷精神，力求有恒，以改我之旧辙，而振家之丕基。（骄傲、多言二个缺点，历观以前世卿大夫的兴衰，以及最近官场的祸福，其中最关键的原因不外乎这两点，所以希望能够与诸位弟弟互相监督，不犯这种错误。即使是戒除了这两个毛病，如果不能勤奋自立的话，还是无法兴家立业，所以还需要振奋精神，持之以恒，避免走我的老路，这样才能奠定兴家立业的基石。）</li><li>须于说话走路时刻刻留心。</li><li>欲去“骄”字，总以不轻笑非人为第一义。欲去“惰”字，总以不晏起为第一义。</li><li>门第太甚，余教儿女辈，惟以勤俭谦三字为主。</li><li>养生之法，约有五事：一曰眠食有恒；二曰惩忿；三曰节欲；四曰每夜临睡洗脚；五曰每日两饭后各行三千步。</li></ul><h2 id="荐书"><a href="#荐书" class="headerlink" title="荐书"></a>荐书</h2><ul><li><p>以韩退之为千古大儒，而自述其所服膺之书不过数种，曰《易》，曰《书》，曰《诗》，曰《春秋左传》，曰《庄子》，曰《离骚》，曰《诗》，曰《史记》，曰相如、子云。柳子厚自述其所得，正者曰《易》，曰《书》，曰《礼》，曰《春秋》；旁者曰《谷梁》，曰《孟》《荀》，曰《庄》《老》，曰《国语》，曰《离骚》，曰《史记》。二公所读之书，皆不甚多。</p></li><li><p>今观怀祖先生《读书杂志》中所考订之书，曰《逸周书》，曰《战国策》，曰《史记》，曰《汉书》，曰《管子》，曰《晏子》曰《墨子》，曰《荀子》，曰《淮南子》，曰《后汉书》，曰《老》《庄》，曰《吕氏春秋》，曰《韩非子》，曰《杨子》，曰《楚辞》，曰《文选》，凡十六种，又别著《广雅疏证》一种。伯申先生《经义述闻》中所考订之书，曰《易》，曰《书》，曰《诗》，曰《周官》，曰《仪礼》，曰《大戴礼》，曰《礼记》，曰《左传》，曰《国语》，曰《公羊》，曰《谷梁》，曰《尔雅》，凡十二种。王氏父子之博，古今所罕，然亦不满三十种也。</p></li><li><p>余于《四书》《五经》以外，最好《史记》《汉书》《庄子》《韩文》四种，好之十馀年，借不能熟读精考；又好《通鉴》《文选》及姚惜抱所选《古文辞类纂》，余所选《十八家诗抄》四种，共不过十馀种。早岁笃志为学，恒思将此十馀书贯串精通，略作札记，仿顾亭林、王怀祖之法。今年齿衰老，时事日艰，所志不克成就，中夜思之，每用愧悔。泽儿若能成吾之志，将《四书》《五经》及馀所好之八种，一一熟读而深思之，略作札记，以志所得，以著所疑，则余欢欣快慰，夜得甘寝，此外别无所求矣。</p></li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>谦虚、谨慎、诚意、坚持，曾公的家训须时刻铭记于心。<br>关于古籍的推荐可以参考。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书与做人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股文-java多线程-同步协作</title>
    <link href="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/"/>
    <url>/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java多线程同步与协作相关面试题目整理，面经尽量用简短的语句说明问题，详细的信息可以参考每个面经下的参考链接。面经不保证完全正确，欢迎大家邮件联系作者进行相应的修改和交流。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Synchronized和ReentryLock"><a href="#Synchronized和ReentryLock" class="headerlink" title="Synchronized和ReentryLock"></a>Synchronized和ReentryLock</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁可以视作访问共享数据的许可证。锁能够保护共享数据以实现线程安全，其作用包括保障原子性、保障可见性和保障有序性。<br>Java平台中的锁包括内部锁（IntrinsicLock）和显式锁（ExplicitLock）。内部锁是通过synchronized关键字实现的；显式锁是通过java.util.concurrent.locks.Lock接口的实现类（如java.concurrent.locks.ReentrantLock类）实现的。synchronized在软件层面依赖JVM（jvm指令），而j.u.c.Lock在硬件层面依赖特殊的CPU指令。</p><h3 id="锁的调度"><a href="#锁的调度" class="headerlink" title="锁的调度"></a>锁的调度</h3><p>公平调度，多个线程申请锁的时候需要排队，先到先得，不允许插队，在线程任务执行时间较长的情况下使用公平调度效率更高，公平调度适合线程任务执行时间较长的场景；<br>非公平调度，多个线程申请锁的时候需要排队，但是允许插队，一般情况下效率更高；</p><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>Java平台中的任何一个对象都有唯一一个与之关联的锁。这种锁被称为监视器（Monitor）或者内部锁（IntrinsicLock）。内部锁是一种排他锁，它能够保障原子性、可见性和有序性。内部锁是通过synchronized关键字实现的。synchronized关键字可以用来修饰方法以及代码块（花括号“{}”包裹的代码）。<br>同步静态方法，锁为类对象；如果同步实例方法，锁为this，即当前对象实例；同步代码块的时候需要指定的锁句柄，作为锁句柄的变量通常采用final修饰<br>synchronized关键字申请锁和释放锁都是JVM代为实施，不需要手动操作，所以称为内部锁，内部锁是使用最方便的锁。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeCircularSeqGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CircularSeqGenerator</span> </span>&#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">short</span> sequence = <span class="hljs-number">-1</span>; <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">short</span> <span class="hljs-title">nextSequence</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sequence &gt;= <span class="hljs-number">999</span>) &#123;<br>            sequence = <span class="hljs-number">0</span>; <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            sequence++; <br>        &#125; <br>        <span class="hljs-keyword">return</span> sequence; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">short</span> <span class="hljs-title">nextSequence</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123; <br>        <span class="hljs-keyword">if</span> (sequence &gt;= <span class="hljs-number">999</span>) &#123; <br>            sequence = <span class="hljs-number">0</span>; <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            sequence++; <br>        &#125; <br>        <span class="hljs-keyword">return</span> sequence; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReentryLock"><a href="#ReentryLock" class="headerlink" title="ReentryLock"></a>ReentryLock</h3><p>显示锁最常用的是ReentrantLock，需要创建一个ReentrantLock对象lock，并且在同步代码前插入<code>lock.lock()</code>，在同步代码后插入<code>lock.unlock()</code>;，注意<code>lock.unlock();</code>需要放在finally里中，避免锁泄露；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>(); <span class="hljs-comment">// 申请锁lock </span><br><span class="hljs-keyword">try</span>&#123; <br>    <span class="hljs-comment">// 在此对共享数据进行访问 </span><br>    …… <br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">// 总是在finally块中释放锁，以避免锁泄漏 </span><br>    <span class="hljs-keyword">lock</span>.unlock(); <span class="hljs-comment">// 释放锁lock </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>两者都是可重入锁。内部锁只支持非公平调度，ReentrantLock同时支持公平和非公平调度。<br>内部锁和ReentrantLock两者性能接近，内部锁使用简单，ReentrantLock使用复杂，需要手动释放锁。一般情况下使用synchronized内部锁即可，如果需要使用更加复杂的线程协作或者需要公平调度等时候可以考虑使用ReentrantLock。</p><p>参考：<br>《Java多线程编程实战指南》黄文海<br><a href="https://www.cnblogs.com/lllliuxiaoxia/p/15775069.html">java多线程基础 </a></p><h2 id="内存屏障？Java是怎么实现原子性，有序性，可见性呢"><a href="#内存屏障？Java是怎么实现原子性，有序性，可见性呢" class="headerlink" title="内存屏障？Java是怎么实现原子性，有序性，可见性呢?"></a>内存屏障？Java是怎么实现原子性，有序性，可见性呢?</h2><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>内存屏障是对一类仅针对内存读、写操作指令（Instruction）的跨处理器架构（比如x86、ARM）的比较底层的抽象（或者称呼）。内存屏障是被插入到两个指令之间进行使用的，其作用是禁止编译器、处理器重排序从而保障有序性。它在指令序列（如指令1；指令2；指令3）中就像是一堵墙（因此被称为屏障）一样使其两侧（之前和之后）的指令无法“穿越”它（一旦穿越了就是重排序了）。但是，为了实现禁止重排序的功能，这些指令也往往具有一个副作用——刷新处理器缓存、冲刷处理器缓存，从而保证可见性。不同微架构的处理器所提供的这样的指令是不同的，并且出于不同的目的使用的相应指令也是不同的。</p><p>按照可见性保障来划分，内存屏障可分为加载屏障（LoadBarrier）和存储屏障（StoreBarrier）。加载屏障的作用是刷新处理器缓存，存储屏障的作用冲刷处理器缓存。</p><p>按照有序性保障来划分，内存屏障可以分为获取屏障（AcquireBarrier）和释放屏障（ReleaseBarrier）。获取屏障的使用方式是在一个读操作（包括Read-Modify-Write以及普通的读操作）之后插入该内存屏障，其作用是禁止该读操作与其后的任何读写操作之间进行重排序，这相当于在进行后续操作之前先要获得相应共享数据的所有权（这也是该屏障的名称来源）。释放屏障的使用方式是在一个写操作之前插入该内存屏障，其作用是禁止该写操作与其前面的任何读写操作之间进行重排序。这相当于在对相应共享数据操作结束后释放所有权（这也是该屏障的名称来源）。</p><h3 id="内部锁中内存屏障的使用"><a href="#内部锁中内存屏障的使用" class="headerlink" title="内部锁中内存屏障的使用"></a>内部锁中内存屏障的使用</h3><p>由于内部锁的申请与释放对应的Java虚拟机字节码指令分别是monitorenter和monitorexit，因此习惯上我们用MonitorEnter表示锁的申请，用MonitorExit表示锁的释放。</p><p>Java虚拟机会在MonitorExit（释放锁）对应的机器码指令之后插入一个存储屏障，这就保障了写线程在释放锁之前在临界区中对共享变量所做的更新对读线程的执行处理器来说是可同步的；相应地，Java虚拟机会在MonitorEnter（申请锁）对应的机器码指令之后临界区开始之前的地方插入一个加载屏障，这使得读线程的执行处理器能够将写线程对相应共享变量所做的更新从其他处理器同步到该处理器的高速缓存中。</p><p>Java虚拟机会在MonitorEnter（它包含了读操作）对应的机器码指令之后临界区开始之前的地方插入一个获取屏障，并在临界区结束之后MonitorExit（它包含了写操作）对应的机器码指令之前的地方插入一个释放屏障。因此，这两种屏障就像是三明治的两层面包片把火腿夹住一样把临界区中的代码（指令序列）包括起来。由于获取屏障禁止了临界区中的任何读、写操作被重排序到临界区之前的可能性，而释放屏障又禁止了临界区中的任何读、写操作被重排序到临界区之后的可能性，因此临界区内的任何读、写操作都无法被重排序到临界区之外。在锁的排他性的作用下，这使得临界区中执行的操作序列具有原子性。因此，写线程在临界区中对各个共享变量所做的更新会同时对读线程可见，即在读线程看来各个共享变量就像是“一下子”被更新的，于是这些线程无从（也无必要）区分这些共享变量是以何种顺序被更新的。这使得写线程在临界区中执行的操作自然而然地具有有序性——读线程对这些操作的感知顺序与源代码顺序一致。</p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%9C%A8%E9%94%81%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt="内存屏障在锁中的使用"></p><h3 id="Java内部锁是怎么实现原子性，有序性，可见性呢"><a href="#Java内部锁是怎么实现原子性，有序性，可见性呢" class="headerlink" title="Java内部锁是怎么实现原子性，有序性，可见性呢?"></a>Java内部锁是怎么实现原子性，有序性，可见性呢?</h3><p>临界区中执行操作序列的原子性由锁的排他性实现。<br>锁对可见性的保障是通过写线程和读线程成对地使用存储屏障和加载屏障实现的。<br>锁对有序性的保障是通过写线程和读线程配对使用释放屏障与获取屏障屏障实现的。</p><p>参考：<br>《Java多线程编程实战指南》黄文海</p><h2 id="Volatile的作用是什么？底层是怎么实现的？"><a href="#Volatile的作用是什么？底层是怎么实现的？" class="headerlink" title="Volatile的作用是什么？底层是怎么实现的？"></a>Volatile的作用是什么？底层是怎么实现的？</h2><p>volatile关键字用于修饰共享可变变量，即没有使用final关键字修饰的实例变量或静态变量，相应的变量就被称为volatile变量。volatile可以保障可见性、保障有序性和保障long&#x2F;double型变量读写操作的原子性。</p><p>可见性和有序性由内存屏障保障：</p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/volatile%E5%8F%98%E9%87%8F%E5%86%99%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="volatile变量写操作与内存屏障"></p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/volatile%E5%8F%98%E9%87%8F%E8%AF%BB%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="volatile变量读操作与内存屏障"></p><p>注意：</p><p>volatile仅仅保障对其修饰的变量的写操作（以及读操作）本身的原子性，而这并不表示对volatile变量的赋值操作一定具有原子性。</p><p>volatile关键字在可见性方面仅仅是保证读线程能够读取到共享变量的相对新值。对于引用型变量和数组变量，volatile关键字并不能保证读线程能够读取到相应对象的字段（实例变量、静态变量）、元素的相对新值。</p><p>参考：<br>《Java多线程编程实战指南》黄文海</p><h2 id="Java的CAS是怎么实现的？Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别？"><a href="#Java的CAS是怎么实现的？Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别？" class="headerlink" title="Java的CAS是怎么实现的？Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别？"></a>Java的CAS是怎么实现的？Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别？</h2><h3 id="Java的CAS是怎么实现的"><a href="#Java的CAS是怎么实现的" class="headerlink" title="Java的CAS是怎么实现的"></a>Java的CAS是怎么实现的</h3><p>CAS（CompareandSwap）是对一种处理器指令（例如x86处理器中的cmpxchg指令）的称呼。</p><p>原子变量类（Atomics）通常是借助一个volatile变量基于CAS实现的能够保障对共享变量进行read-modify-write更新操作的原子性和可见性的一组工具类。关于CAS的操作都是基于Unsafe类中的一些方法实现的，这些方法对处理器的CAS指令进行了包装。</p><h3 id="简单分析下Atmoicinteger"><a href="#简单分析下Atmoicinteger" class="headerlink" title="简单分析下Atmoicinteger"></a>简单分析下Atmoicinteger</h3><p>主要看下getAndIncrement方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> U.<span class="hljs-title">getAndAddInt</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, VALUE, <span class="hljs-number">1</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的U是<code>private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</code>，是unsafe对象</p><p>AtomicInteger中用value来实际存储值</p><p><code>private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, &quot;value&quot;);</code>，VALUE是value属性的内存地址位置较AtomicInteger对象内存地址位置的偏移量，所以<code>U.getAndAddInt(this, VALUE, 1);</code>中通过this和VALUE可以直接定位到value的内存地址位置。</p><p>再看getAndAddInt方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final <span class="hljs-built_in">int</span> get<span class="hljs-constructor">AndAddInt(Object <span class="hljs-params">o</span>, <span class="hljs-params">long</span> <span class="hljs-params">offset</span>, <span class="hljs-params">int</span> <span class="hljs-params">delta</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = get<span class="hljs-constructor">IntVolatile(<span class="hljs-params">o</span>, <span class="hljs-params">offset</span>)</span>;<br>    &#125; <span class="hljs-keyword">while</span> (!weak<span class="hljs-constructor">CompareAndSetInt(<span class="hljs-params">o</span>, <span class="hljs-params">offset</span>, <span class="hljs-params">v</span>, <span class="hljs-params">v</span> + <span class="hljs-params">delta</span>)</span>);<br>    return v;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先基于value的内存地址位置获取它的当前值，然后尝试CAS对value增加delta，如果成功则返回原value值，否则重复以上操作直到成功。</p><h3 id="Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别"><a href="#Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别" class="headerlink" title="Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别"></a>Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别</h3><p>两者使用对比：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerFieldUpdaterDemo</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Candidate</span> &#123;<br>        <span class="hljs-built_in">int</span> id;<br> <br>        <span class="hljs-keyword">volatile</span> <span class="hljs-built_in">int</span> score = <span class="hljs-number">0</span>;<br> <br>        AtomicInteger score2 = <span class="hljs-keyword">new</span> AtomicInteger();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> final AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater =<br>            AtomicIntegerFieldUpdater.newUpdater(Candidate.<span class="hljs-keyword">class</span>, <span class="hljs-string">&quot;score&quot;</span>);<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AtomicInteger realScore = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>        final Candidate candidate = <span class="hljs-keyword">new</span> Candidate();<br>        Thread[] t = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">10000</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            t[i] = <span class="hljs-keyword">new</span> Thread() &#123;<br>                @Override<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>                    <span class="hljs-keyword">if</span> (Math.random() &gt; <span class="hljs-number">0.4</span>) &#123;<br>                        candidate.score2.incrementAndGet();<br>                        scoreUpdater.incrementAndGet(candidate);<br>                        realScore.incrementAndGet();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            t[i].start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            t[i].<span class="hljs-keyword">join</span>();<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;AtomicIntegerFieldUpdater Score=&quot;</span> + candidate.score);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;AtomicInteger Score=&quot;</span> + candidate.score2.<span class="hljs-keyword">get</span>());<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;realScore=&quot;</span> + realScore.<span class="hljs-keyword">get</span>());<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出台如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">AtomicIntegerFieldUpdater <span class="hljs-attribute">Score</span>=6003<br>AtomicInteger <span class="hljs-attribute">Score</span>=6003<br><span class="hljs-attribute">realScore</span>=6003<br></code></pre></td></tr></table></figure><p>通过上述代码我们不难得知使用AtomicIntegerFieldUpdater与AtomicInteger其实效果是一致的，那既然已经存在了AtomicInteger并发之神又要写一个AtomicIntegerFieldUpdater呢？</p><p>1.从AtomicIntegerFieldUpdaterDemo代码中我们不难发现，通过AtomicIntegerFieldUpdater更新score我们获取最后的int值时相较于AtomicInteger来说不需要调用get()方法！<br>2.对于AtomicIntegerFieldUpdaterDemo类的AtomicIntegerFieldUpdater是static final类型也就是说即使创建了100个对象AtomicIntegerField也只存在一个不会占用对象的内存，但是AtomicInteger会创建多个AtomicInteger对象，占用的内存比AtomicIntegerFieldUpdater大，所以对于熟悉dubbo源码的人都知道，dubbo有个实现轮询负载均衡策略的类AtomicPositiveInteger用的就是AtomicIntegerFieldUpdater。</p><p>参考：<br>《Java多线程编程实战指南》黄文海<br><a href="https://blog.csdn.net/qq_23536449/article/details/103880340">AtomicIntegerFieldUpdater与AtomicInteger使用引发的思考</a></p><h2 id="sleep和wait的区别？notify和notifyall的区别是啥？"><a href="#sleep和wait的区别？notify和notifyall的区别是啥？" class="headerlink" title="sleep和wait的区别？notify和notifyall的区别是啥？"></a>sleep和wait的区别？notify和notifyall的区别是啥？</h2><h3 id="wait-notify-notifyall基本用法"><a href="#wait-notify-notifyall基本用法" class="headerlink" title="wait\notify\notifyall基本用法"></a>wait\notify\notifyall基本用法</h3><p>wait模板</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">synchronized</span>(someObject)&#123;<br>  <span class="hljs-built_in">while</span>(保护条件不成立)（<br>  someObject<span class="hljs-selector-class">.wait</span>();<br>）<br>doAction;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<br>保护条件需要循环判断，防止在获取锁的时候，保护条件又不成立，内部锁支持非公平调度，可能有插队将保护条件给修改了，这是需要让线程重新等待。</p><p>notify模板</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">synchronized</span>(someObject)&#123;<br>  <span class="hljs-built_in">updateShareState</span>();<br>  someObject<span class="hljs-selector-class">.notify</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<br>notify()需要尽可能放在临界区的结束的地方，否则被唤醒线程可能拿不到锁(被其他线程抢占)，导致上下文切换。</p><p>开销和问题:<br>Notifyall（）过早唤醒，保护条件还没有成立就被唤醒，可以利用显示锁的Condition接口来解决，实现分组唤醒；</p><p>notify()和notifyall():<br>只有在特定条件下采用notify()，否则都用notifyall()：<br>条件1：一次通知只唤醒一个线程；条件2：线程同质</p><h3 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h3><p>这两个方法来自不同的类，sleep()是Thread的静态方法，wait()是Object的实例方法；<br>sleep方法没有释放锁，而wait方法释放了锁;<br>wait，notify和notifyAll的调用需要放在同一个对象所引导的临界区中，而sleep可以在任何地方使用;<br>sleep到时间会自动恢复。wait必须使用notify或者是notifyall进行唤醒;<br>Wait通常被用于线程间交互&#x2F;通信，sleep通常被用于暂停执行。</p><p>参考：<br>《Java多线程编程实战指南》黄文海<br><a href="https://zhuanlan.zhihu.com/p/86717279">java多线程中sleep和wait的4个区别，你知道几个？</a><br><a href="https://blog.csdn.net/qq_42787645/article/details/101326366">wait()和sleep()方法的区别</a></p><h2 id="await-x2F-signal-x2F-signalAll-x2F-condition"><a href="#await-x2F-signal-x2F-signalAll-x2F-condition" class="headerlink" title="await&#x2F;signal&#x2F;signalAll&#x2F;condition"></a>await&#x2F;signal&#x2F;signalAll&#x2F;condition</h2><p>Condition接口可作为wait&#x2F;notify的替代品来实现等待&#x2F;通知，它为解决过早唤醒问题提供了支持，并解决了Object.wait(long)不能区分其返回是否是由等待超时而导致的问题。<br>Lock.newCondition()的返回值就是一个Condition实例，因此调用任意一个显式锁实例的newCondition方法可以创建一个相应的Condition接口。Object.wait()&#x2F;notify()要求其执行线程持有这些方法所属对象的内部锁，类似地，Condition.await()&#x2F;signal()也要求其执行线程持有创建该Condition实例的显式锁。<br>通过condition，可以将等待线程分组并进行分组唤醒。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionUsage</span> &#123;<br>    <span class="hljs-keyword">private</span> final Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> final Condition condition = <span class="hljs-keyword">lock</span>.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aGuaredMethod</span>() throws InterruptedException</span> &#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (保护条件不满足) &#123;<br>                condition.<span class="hljs-keyword">await</span>();<br>            &#125;<br>            <span class="hljs-comment">// 执行目标动作 </span><br>            doAction();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAction</span>()</span> &#123;<br>        <span class="hljs-comment">// ... </span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anNotificationMethod</span>() throws InterruptedException</span> &#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 更新共享变量 </span><br>            changeState();<br>            condition.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeState</span>()</span> &#123;<br>        <span class="hljs-comment">// ... </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Condition.awaitUntil(Date)返回值true表示进行的等待尚未达到最后期限，即此时方法的返回是由于其他线程执行了相应条件变量的signal&#x2F;signalAll方法。</p><p>参考：<br>《Java多线程编程实战指南》黄文海</p><h2 id="synchronized原理？锁升级？"><a href="#synchronized原理？锁升级？" class="headerlink" title="synchronized原理？锁升级？"></a>synchronized原理？锁升级？</h2><p>JDK1.5之前synchronized是一个重量级锁，不过，随着Javs SE 1.6对synchronized进行的各种优化后，性能上synchronized和显示锁相差不大，不过显示锁的功能更为强大，且显示锁的读写锁在特定场景性能提升明显。</p><h3 id="synchronized基本原理"><a href="#synchronized基本原理" class="headerlink" title="synchronized基本原理"></a>synchronized基本原理</h3><p>j.u.c.Lock在硬件层面依赖特殊的CPU指令实现同步，synchronized是在软件层面依赖JVM（jvm指令）实现同步，编译后可以看到实际靠monitorenter和monitorexit指令来实现同步。</p><p>monitorenter：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：<br>1）如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者，如果同一个线程反复重入则反复加1；<br>2）如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；<br>3）如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；<br>monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。</p><p>其实wait&#x2F;notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait&#x2F;notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><p>与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的。ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表（ 每个等待锁的线程都会被封装成ObjectWaiter对象 ），_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时：<br>1）首先会进入 _EntryList 集合，当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1；<br>2）若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒；<br>3）若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)；</p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/monitor.png" alt="monitor"></p><h3 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h3><p>JDK1.6对synchronized的实现机制进行了较大调整，包括锁升级、锁消除、锁粗化等优化策略，使得synchronized性能极大提高。锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁升级指锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。在JDK1.6中默认是开启偏向锁和轻量级锁的。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。引入偏向锁是为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令。偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁&#x2F;解锁流程。</p><p>如果一个线程A持有偏向锁，线程B来竞争，如果线程B通过CAS竞争失败，则在安全点偏向锁升级为轻量级锁。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>因为重量级锁会导致线程上下文切换，所以偏向锁不会直接升级到重量级锁，而是会升级到轻量级锁的状态。<br>在轻量锁的状态下，线程间通过自旋加CAS的方式来竞争锁，如果可以很快获得锁资源，这样的开销比较小，如果自旋一定次数后仍然无法竞争到锁，此时轻量级锁升级为重量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>Synchronized是通过对象内部的一个叫做监视器锁（Monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “重量级锁”。“重量级锁”才是我们平时以为的同步锁。</p><h3 id="synchronized其他优化"><a href="#synchronized其他优化" class="headerlink" title="synchronized其他优化"></a>synchronized其他优化</h3><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>为了保证数据的完整性，在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。<br>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</p><p>参考：<br>《Java多线程编程实战指南》黄文海<br><a href="https://www.cnblogs.com/lllliuxiaoxia/p/15711549.html">synchronized原理</a></p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h3><p>AbstractQueuedSynchronizer（AQS），抽象的队列式的同步器。AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程同步队列，多线程争用资源被阻塞时线程被封装成Node加入这个队列中。AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）。<br>AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch，这些同步类内部都有具体的自定义同步器，这些同步器继承了AQS，不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。<br>自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。<br>这些方式不需要都实现，一般实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。</li></ul><h3 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h3><p>AQS使用时比较核心的方法是acquire-release、acquireShared-releaseShared。</p><ul><li>acquire(int)</li></ul><p>ReentrantLock的lock方法，内部其实就是调用的acquire(1)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final void acquire(<span class="hljs-built_in">int</span> arg) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">arg</span>)</span><span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">        </span>acquire<span class="hljs-constructor">Queued(<span class="hljs-params">addWaiter</span>(Node.EXCLUSIVE)</span>, arg))<br>        self<span class="hljs-constructor">Interrupt()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）；<br>如果直接通过tryAcquire()获取资源失败，addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；<br>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false；<br>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/AQS-acquire.png" alt="tryAcquire"></p><ul><li>release(int)</li></ul><p>ReentrantLock的unlock方法，内部其实就是调用的release(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>tryRelease()释放资源，自义定同步器在实现时，如果已经彻底释放资源(state&#x3D;0)，要返回true，否则返回false。<br>如果资源彻底释放了（即state&#x3D;0）,unparkSuccessor()会唤醒等待队列里的其他线程来获取资源</p><p>acquireShared()和releaseShared()类似，不同的是acquireShared()中一个线程拿到资源后如果有剩余资源还会去唤醒后继线程，releaseShared()在释放部分资源后就会唤醒后继线程，不需要完全释放资源。</p><h3 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h3><p>内部的Sync继承AQS，而Sync有两个子类分别为NonfairSync和FairSync，分别对应非公平锁和公平锁的Sync，Sync重写了AQS的tryAcquire和tryRelease等方法。针对公平或不公平的需求，会将Sync设置为NonfairSync或FairSync。<br>ReentrantLock在调用lock和unlock时，实际使用的为Sync(AQS)的acquire(1)和release(1)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span>()</span> &#123;<br>    sync.acquire(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>NonfairSync和FairSync的tryRelease()相同，都是释放一定的资源量，如果资源为0时，则将独占线程设为null然后退出。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected final boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Release(<span class="hljs-params">int</span> <span class="hljs-params">releases</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> c = get<span class="hljs-constructor">State()</span> - releases;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> != get<span class="hljs-constructor">ExclusiveOwnerThread()</span>)<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalMonitorStateException()</span>;<br>    boolean free = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (c<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        set<span class="hljs-constructor">ExclusiveOwnerThread(<span class="hljs-params">null</span>)</span>;<br>    &#125;<br>    set<span class="hljs-constructor">State(<span class="hljs-params">c</span>)</span>;<br>    return free;<br>&#125;<br></code></pre></td></tr></table></figure><p>NonfairSync和FairSync的tryAcquire()因为公平性问题，所以有一些差别：NonfairSync的tryAcquire()在资源为0时（c &#x3D;&#x3D; 0）直接尝试通过cas来增加state并将当前线程设为独占线程，如果当前线程本身就是独占线程的话，则将state增加一定的数量。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static final <span class="hljs-keyword">class</span> NonfairSync extends Sync &#123;<br>    protected final boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">int</span> <span class="hljs-params">acquires</span>)</span> &#123;<br>        return nonfair<span class="hljs-constructor">TryAcquire(<span class="hljs-params">acquires</span>)</span>;<br>    &#125;<br>&#125;<br>final boolean nonfair<span class="hljs-constructor">TryAcquire(<span class="hljs-params">int</span> <span class="hljs-params">acquires</span>)</span> &#123;<br>    final Thread current = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;<br>    <span class="hljs-built_in">int</span> c = get<span class="hljs-constructor">State()</span>;<br>    <span class="hljs-keyword">if</span> (c<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compare<span class="hljs-constructor">AndSetState(0, <span class="hljs-params">acquires</span>)</span>) &#123;<br>            set<span class="hljs-constructor">ExclusiveOwnerThread(<span class="hljs-params">current</span>)</span>;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current<span class="hljs-operator"> == </span>get<span class="hljs-constructor">ExclusiveOwnerThread()</span>) &#123;<br>        <span class="hljs-built_in">int</span> nextc = c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>)</span>;<br>        set<span class="hljs-constructor">State(<span class="hljs-params">nextc</span>)</span>;<br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br>    return <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>FairSync的tryAcquire()在资源为0时（c &#x3D;&#x3D; 0）还要看队列里是否有线程正在排队（hasQueuedPredecessors()），如果有的话，当前线程就得老老实实去排队，不能插队，这里表现了公平性调度。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> boolean tryAcquire(int acquires) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> current = <span class="hljs-type">Thread</span>.currentThread();<br>        int c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            int nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>AQS中除了刚才说的同步队列外，还有等待队列，ReentrantLock中的每个condition都有一个等待队列，这也是condition实现分组唤醒的基础。</p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/condition%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97.png" alt="等待队列"></p><p>查看AQS的newCondition（）方法，实际调用：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">final ConditionObject <span class="hljs-keyword">new</span><span class="hljs-type">Condition</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ConditionObject</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>直接初始化并返回了一个AQS提供的ConditionObject对象。ConditionObject通过维护firstWaiter和lastWaiter来维护Condition等待队列。通过signal操作将Condition等待队列中的线程移到Sync锁等待队列。</p><p>Condition必须与一个独占锁绑定使用，在await或signal之前必须现持有独占锁。Condition队列是一个单向链表，他是公平的，按照先进先出的顺序从队列中被“唤醒”，所谓唤醒指的是完成Condition对象上的等待，被移到Sync锁等待队列中，又参与竞争锁的资格（Sync队列有公平&amp;非公平两种模式，注意区别）。</p><p>参考：<br><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a><br><a href="https://www.cnblogs.com/go2sea/p/5630355.html">Java多线程之JUC包：Condition源码学习笔记</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ">微信公众号:我的IT技术路</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原码、反码、补码的理解</title>
    <link href="/2023/02/08/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2023/02/08/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="机器数、真值"><a href="#机器数、真值" class="headerlink" title="机器数、真值"></a>机器数、真值</h2><ul><li>机器数</li></ul><p>一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用机器数的最高位存放符号，正数为0，负数为1。</p><p>比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是0000 0011。如果是 -3 ，就是 100 00011 。</p><p>那么，这里的 0000 0011 和 1000 0011 就是机器数。</p><ul><li>真值</li></ul><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。</p><p>例如上面的有符号数 1000 0011，其最高位1代表负，其真正数值是 -3，而不是形式值131（1000 0011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><p>例：0000 0001的真值 &#x3D; +000 0001 &#x3D; +1，1000 0001的真值 &#x3D; –000 0001 &#x3D; –1</p><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p>原码、反码、补码是机器存储一个具体数字的编码方式。机器数包含了原码、反码、补码的表示形式。</p><ul><li>原码</li></ul><p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如：如果是8位二进制：</p><p>[+1]原&#x3D; 0000 0001</p><p>[-1]原&#x3D; 1000 0001</p><p>第一位是符号位，因为第一位是符号位，所以8位二进制数的取值范围就是：（即第一位不表示值，只表示正负。）</p><p>[1111 1111 , 0111 1111]</p><p>即</p><p>[-127 , 127]</p><ul><li>反码</li></ul><p>反码的表示方法是：</p><p>正数的反码是其本身；</p><p>负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p><p>[+1] &#x3D; [0000 0001]原&#x3D; [0000 0001]反</p><p>[-1] &#x3D; [1000 0001]原&#x3D; [1111 1110]反</p><p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。</p><p><strong>反码表示在计算机中往往作为数码变换的中间环节。</strong></p><ul><li>补码</li></ul><p>补码的表示方法是：</p><p>正数的补码就是其本身；</p><p>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(也即在反码的基础上+1)</p><p>[+1] &#x3D; [0000 0001]原&#x3D; [0000 0001]反&#x3D; [0000 0001]补</p><p>[-1] &#x3D; [1000 0001]原&#x3D; [1111 1110]反&#x3D; [1111 1111]补</p><p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码再计算其数值。</p><h1 id="为什么用反码和补码"><a href="#为什么用反码和补码" class="headerlink" title="为什么用反码和补码"></a>为什么用反码和补码</h1><p>计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂，所以要把对于负数的减法运算转成加法运算。</p><p>将钟表想象成是一个1位的12进制数。例如钟表上的时间为6点，如果我们希望将时间设置为4点，那么我们可以将钟表往回拨2个小时，即“-2”，或者我们可以将钟表往前拨10个小时，即“+10”</p><ol><li>往回拨2个小时：6 - 2 &#x3D; 4</li><li>往前拨10个小时：(6 + 10)mod 12 &#x3D; 4</li></ol><p>这样就将减法计算转成了加法计算。</p><p>类似钟表，计算机中的数值也是有一定范围的，所以同样可以将计算机中的减法运算改为加法运算，即将真值为负的机器数转为补码形式再做加法，实际上是将负数转换成了这个它的<strong>同余数（概念自行百度）</strong>。</p><p>补码举例：</p><p>2-1 &#x3D; 2+(-1) &#x3D; [0000 0010]原+ [1000 0001]原&#x3D; [0000 0010]补 + [1111 1111]补</p><p>如果把[1111 1111]当成原码，去除符号位，则[0111 1111]原 &#x3D; 127</p><p>相当于</p><p>2-1 ≡ 2+127 (mod 128)</p><h1 id="到底什么是补码"><a href="#到底什么是补码" class="headerlink" title="到底什么是补码"></a>到底什么是补码</h1><p>所以到底什么是补码？</p><p><strong>其实负数的补码等于反码+1只是补码的求法，而不是补码的定义，很多人以为求补码就要先求反码，其实并不是，那些计算机学家并不会心血来潮的把反码+1就定义为补码，只不过补码正好就等于反码+1而已。</strong></p><p>其实负数的补码，是能够和其相反数相加通过溢出从而使计算机内计算结果变为0的二进制码。这是补码设计的初衷，具体目标就是让1+（-1）&#x3D;0，这利用原码是无法得到的：</p><p>0001(1) + 1001(-1) &#x3D; 1010(-2)</p><p>而在补码中：</p><p>0001(1补) + 1111(-1补) &#x3D; 10000(1溢出)</p><p>所以对于一个n位的负数-X，有如下关系</p><p>X<del>补</del> + (-X)<del>补</del> &#x3D; 100…0(n个0) &#x3D; 2^n^</p><p>假设寄存器是n位的，那么-X的补码应该是2^n^ - X的二进制编码</p><p>例如：</p><p>X &#x3D; - 0b11(-3) ，四比特表示原码 &#x3D; 1011(11)，对应反码为 &#x3D; 1100(12)，补码为1101(13);<br>如果寄存器4位，-3对应的补码二进制数为13，刚好是2^4^-3</p><p>正十进制数X补码等于其本身，n位寄存器下-X的补码等于2^n^-X对应的二进制编码。</p><h1 id="已知补码如何求原码"><a href="#已知补码如何求原码" class="headerlink" title="已知补码如何求原码"></a>已知补码如何求原码</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>补码的补码就是原码</p><h2 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h2><p>n位寄存器下-X的补码等于2^n^-X对应的二进制编码。</p><p>（1）十进制的情况下，如果给的补码是无符号数2^n^-X，那么原码即(2^n^-X) - 2^n^ &#x3D; -X:<br>例如前面-3补码无符号数是13，对应的原码就是13-2^4^&#x3D;-3</p><p>（2）十进制的情况下，如果给的补码是有符号数-Y，对应的无符号数就是2^n-1^ + Y，那么原码就是(2^n-1^ + Y)- 2^n^&#x3D;Y-2^n-1^:<br>例如前面-3补码有符号数是-5，对应的原码就是5-2^3^ &#x3D; -3</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/118432554">原码、反码、补码</a><br><a href="https://zhuanlan.zhihu.com/p/99082236">二进制的原码、反码、补码</a><br><a href="https://zhuanlan.zhihu.com/p/376848035">补码的计算方法</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股文-java多线程-基础</title>
    <link href="/2023/01/21/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/01/21/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java多线程基础相关面试题目整理</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="线程和进程的概念？守护线程是干什么的？常见的守护线程有哪些？"><a href="#线程和进程的概念？守护线程是干什么的？常见的守护线程有哪些？" class="headerlink" title="线程和进程的概念？守护线程是干什么的？常见的守护线程有哪些？"></a>线程和进程的概念？守护线程是干什么的？常见的守护线程有哪些？</h2><h3 id="线程和进程的概念"><a href="#线程和进程的概念" class="headerlink" title="线程和进程的概念"></a>线程和进程的概念</h3><p>进程是程序的运行实例，是程序向操作系统申请资源的基本单位，线程是进程的一条执行路径。<br>Java的线程分为两种：用户线程和守护线程。守护线程作用是为其他线程提供服务，如果所有的用户线程死亡，后台线程都会死亡。</p><h3 id="常见的守护线程有哪些"><a href="#常见的守护线程有哪些" class="headerlink" title="常见的守护线程有哪些"></a>常见的守护线程有哪些</h3><p>守护线程最典型代表就是GC线程。</p><p>参考:<br><a href="https://www.jianshu.com/p/f1723dfc0a9d">Java 守护线程Daemon</a><br>《Java多线程编程实战指南》黄文海<br>《Java疯狂讲义》李刚</p><h2 id="并发和并行的概念？Java实现并发的方式？"><a href="#并发和并行的概念？Java实现并发的方式？" class="headerlink" title="并发和并行的概念？Java实现并发的方式？"></a>并发和并行的概念？Java实现并发的方式？</h2><h3 id="并发和并行的概念"><a href="#并发和并行的概念" class="headerlink" title="并发和并行的概念"></a>并发和并行的概念</h3><p>从软件的角度来说，并发就是在一段时间内以交替的方式去完成多个任务，而并行就是以齐头并进的方式去完成多个任务。<br>从硬件的角度来说，在一个处理器一次只能够运行一个线程的情况下，由于处理器可以使用时间片（Time-slice）分配的技术来实现在同一段时间内运行多个线程，因此一个处理器就可以实现并发。而并行则需要靠多个处理器在同一时刻各自运行一个线程来实现。</p><h3 id="Java实现并发的方式"><a href="#Java实现并发的方式" class="headerlink" title="Java实现并发的方式"></a>Java实现并发的方式</h3><ul><li>继承Thread类</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//实现方法的类</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    public void run()&#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;继承Thread类&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行的方法</span><br>public static void main(<span class="hljs-type">String</span>[] args) &#123;<br>        <span class="hljs-type">Demo1</span> demo1=<span class="hljs-keyword">new</span> <span class="hljs-type">Demo1</span>();<br>        demo1.start();<br>&#125;<br><br>执行结果：<br>继承<span class="hljs-type">Thread</span>类<br></code></pre></td></tr></table></figure><ul><li>实现Runnable接口</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//实现的方法类：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;实现runnable接口&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//执行方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Demo2</span> demo2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo2</span>();<br>        <span class="hljs-title class_">Thread</span> thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(demo2);<br>        thread.<span class="hljs-title function_">start</span>();<br>&#125;<br>    <br>执行结果：<br>实现runnable接口<br></code></pre></td></tr></table></figure><ul><li>通过实现Callable接口</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//实现类方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">call</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br><span class="hljs-comment">//创建实现类对象</span><br>        <span class="hljs-title class_">Callable</span> demo3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo3</span>();<br>        <span class="hljs-title class_">FutureTask</span> oneTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(demo3);<br>        <span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(oneTask);<br>        thread.<span class="hljs-title function_">start</span>();<br>        <span class="hljs-title class_">Object</span> o = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取返回值</span><br>            o = oneTask.<span class="hljs-title function_">get</span>();<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">ExecutionException</span> e) &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(o);<br><br>&#125;<br><br>执行结果：<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>通过线程池来实现多线程</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//实现代码如下：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.<span class="hljs-built_in">newFixedThreadPool</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            <span class="hljs-type">int</span> finalI = i;<br>            executorService.<span class="hljs-built_in">execute</span>(()-&gt; &#123;<br>                System.out.<span class="hljs-built_in">println</span>(finalI);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br>执行结果：<br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>参考:<br>《Java多线程编程实战指南》黄文海<br><a href="https://blog.csdn.net/limingxingjy/article/details/102709756">浅谈实现并发的几种方式</a></p><h2 id="native关键字的作用是什么？"><a href="#native关键字的作用是什么？" class="headerlink" title="native关键字的作用是什么？"></a>native关键字的作用是什么？</h2><ul><li>作用</li></ul><p>使用native关键字说明这个方法是原生方法，也就是这个方法是用C&#x2F;C++语言实现的，并且被编译成了DLL，由java去调用。<br>这些函数的实现体在DLL中，JDK的源代码中并不包含。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。</p><ul><li>使用</li></ul><p>可以将native方法比作Java程序同Ｃ程序的接口，其实现步骤：<br>　　１、在Java中声明native()方法，然后编译；<br>　　２、用javac -h产生一个.h文件；<br>　　３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；<br>　　４、将第三步的.cpp文件编译成动态链接库文件；<br>　　５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。</p><p>参考：<br><a href="https://www.cnblogs.com/KingIceMou/p/7239668.html">Java中Native关键字的作用</a></p><h2 id="线程的状态有哪些，是怎么转换的？Jvm怎么查看线程的运行状态？"><a href="#线程的状态有哪些，是怎么转换的？Jvm怎么查看线程的运行状态？" class="headerlink" title="线程的状态有哪些，是怎么转换的？Jvm怎么查看线程的运行状态？"></a>线程的状态有哪些，是怎么转换的？Jvm怎么查看线程的运行状态？</h2><h3 id="线程的状态有哪些，是怎么转换的"><a href="#线程的状态有哪些，是怎么转换的" class="headerlink" title="线程的状态有哪些，是怎么转换的"></a>线程的状态有哪些，是怎么转换的</h3><p>Java线程的状态可以使用监控工具查看，也可以通过Thread.getState()调用来获取。Thread.getState()的返回值类型Thread.State是一个枚举类型（Enum）。Thread.State所定义的线程状态包括以下几种。<br>NEW：一个已创建而未启动的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程只可能有一次处于该状态。<br>RUNNABLE：该状态可以被看成一个复合状态。它包括两个子状态：READY和RUNNING。前者表示处于该状态的线程可以被线程调度器（Scheduler）进行调度而使之处于RUNNING状态。后者表示处于该状态的线程正在运行，即相应线程对象的run方法所对应的指令正在由处理器执行。执行Thread.yield()的线程，其状态可能会由RUNNING转换为READY。处于READY子状态的线程也被称为活跃线程。<br>BLOCKED：一个线程发起一个阻塞式I&#x2F;O（BlockingI&#x2F;O）操作后，或者申请一个由其他线程持有的独占资源（比如锁）时，相应的线程会处于该状态。处于BLOCKED状态的线程并不会占用处理器资源。当阻塞式I&#x2F;O操作完成后，或者线程获得了其申请的资源，该线程的状态又可以转换为RUNNABLE。<br>WAITING：一个线程执行了某些特定方法之后就会处于这种等待其他线程执行另外一些特定操作的状态。能够使其执行线程变更为WAITING状态的方法包括：Object.wait()、Thread.join()和LockSupport.park(Object)。能够使相应线程从WAITING变更为RUNNABLE的相应方法包括：Object.notify()&#x2F;notifyAll()和LockSupport.unpark(Object))。<br>TIMED_WAITING：该状态和WAITING类似，差别在于处于该状态的线程并非无限制地等待其他线程执行特定操作，而是处于带有时间限制的等待状态。当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为RUNNABLE。<br>TERMINATED：已经执行结束的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程也只可能有一次处于该状态。Thread.run()正常返回或者由于抛出异常而提前终止都会导致相应线程处于该状态。一个线程在其整个生命周期中，只可能有一次处于NEW状态和TERMINATED状态。</p><p><img src="/2023/01/21/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80/java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png"></p><h3 id="Jvm怎么查看线程的运行状态"><a href="#Jvm怎么查看线程的运行状态" class="headerlink" title="Jvm怎么查看线程的运行状态"></a>Jvm怎么查看线程的运行状态</h3><p>对线程进行监视的主要途径是获取并查看程序的线程转储（ThreadDump）。一个程序的线程转储包含了获取这个线程转储的那一刻该程序的线程信息。这些信息包括程序中有哪些线程以及这些线程的具体信息。常用线程转储的方法如下：</p><ul><li>jstack</li></ul><p>功能描述：<br>jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。<br>命令用法：<br>jstack [ option ] vmid<br>主要选项：<br>-l 打印锁的额外信息<br>-e 打印线程的额外信息</p><p>举例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs routeros">C:\Users\liuwe&gt;jstack -l 16788<br>2023-01-23 16:57:23<br>Full thread dump OpenJDK 64-Bit<span class="hljs-built_in"> Server </span>VM (11+28 mixed mode):<br><br>Threads class SMR info:<br><span class="hljs-attribute">_java_thread_list</span>=0x0000024591cff610, <span class="hljs-attribute">length</span>=11, elements=&#123;<br>0x00000245f256d000, 0x00000245911b3000, 0x00000245911b4000, 0x0000024591a43000,<br>0x00000245911e9000, 0x00000245911eb800, 0x00000245911f2000, 0x0000024591ab0000,<br>0x00000245f264d000, 0x0000024591d54000, 0x0000024591d2d800<br>&#125;<br><br><span class="hljs-string">&quot;main&quot;</span> #1 <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">os_prio</span>=0 <span class="hljs-attribute">cpu</span>=20078.13ms <span class="hljs-attribute">elapsed</span>=28.27s <span class="hljs-attribute">tid</span>=0x00000245f256d000 <span class="hljs-attribute">nid</span>=0x3f48 runnable  [0x0000005b97bff000]<br>   java.lang.Thread.State: RUNNABLE<br>        at java.io.FileOutputStream.writeBytes(java.base@11/Native Method)<br>        at java.io.FileOutputStream.write(java.base@11/FileOutputStream.java:354)<br>        at java.io.BufferedOutputStream.flushBuffer(java.base@11/BufferedOutputStream.java:81)<br>        at java.io.BufferedOutputStream.flush(java.base@11/BufferedOutputStream.java:142)<br>        - locked &lt;0x00000000847e2818&gt; (a java.io.BufferedOutputStream)<br>        at java.io.PrintStream.write(java.base@11/PrintStream.java:561)<br>        - locked &lt;0x0000000084718cc8&gt; (a java.io.PrintStream)<br>        at sun.nio.cs.StreamEncoder.writeBytes(java.base@11/StreamEncoder.java:233)<br>        at sun.nio.cs.StreamEncoder.implFlushBuffer(java.base@11/StreamEncoder.java:312)<br>        at sun.nio.cs.StreamEncoder.flushBuffer(java.base@11/StreamEncoder.java:104)<br>        - locked &lt;0x0000000084718c88&gt; (a java.io.OutputStreamWriter)<br>        at java.io.OutputStreamWriter.flushBuffer(java.base@11/OutputStreamWriter.java:184)<br>        at java.io.PrintStream.newLine(java.base@11/PrintStream.java:625)<br>        - eliminated &lt;0x0000000084718cc8&gt; (a java.io.PrintStream)<br>        at java.io.PrintStream.println(java.base@11/PrintStream.java:883)<br>        - locked &lt;0x0000000084718cc8&gt; (a java.io.PrintStream)<br>        at TestClass.main(TestClass.java:7)<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Reference Handler&quot;</span> #2 daemon <span class="hljs-attribute">prio</span>=10 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.01s <span class="hljs-attribute">tid</span>=0x00000245911b3000 <span class="hljs-attribute">nid</span>=0x393c waiting on condition  [0x0000005b982ff000]<br>   java.lang.Thread.State: RUNNABLE<br>        at java.lang.ref.Reference.waitForReferencePendingList(java.base@11/Native Method)<br>        at java.lang.ref.Reference.processPendingReferences(java.base@11/Reference.java:241)<br>        at java.lang.ref.Reference<span class="hljs-variable">$ReferenceHandler</span>.<span class="hljs-built_in">run</span>(java.base@11/Reference.java:213)<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Finalizer&quot;</span> #3 daemon <span class="hljs-attribute">prio</span>=8 <span class="hljs-attribute">os_prio</span>=1 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.01s <span class="hljs-attribute">tid</span>=0x00000245911b4000 <span class="hljs-attribute">nid</span>=0x434c <span class="hljs-keyword">in</span> Object.wait()  [0x0000005b983fe000]<br>   java.lang.Thread.State: WAITING (on object monitor)<br>        at java.lang.Object.wait(java.base@11/Native Method)<br>        - waiting on &lt;0x0000000084729c70&gt; (a java.lang.ref.ReferenceQueue<span class="hljs-variable">$Lock</span>)<br>        at java.lang.ref.ReferenceQueue.<span class="hljs-built_in">remove</span>(java.base@11/ReferenceQueue.java:155)<br>        - waiting <span class="hljs-keyword">to</span> re-lock <span class="hljs-keyword">in</span> wait() &lt;0x0000000084729c70&gt; (a java.lang.ref.ReferenceQueue<span class="hljs-variable">$Lock</span>)<br>        at java.lang.ref.ReferenceQueue.<span class="hljs-built_in">remove</span>(java.base@11/ReferenceQueue.java:176)<br>        at java.lang.ref.Finalizer<span class="hljs-variable">$FinalizerThread</span>.<span class="hljs-built_in">run</span>(java.base@11/Finalizer.java:170)<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Signal Dispatcher&quot;</span> #4 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=27.90s <span class="hljs-attribute">tid</span>=0x0000024591a43000 <span class="hljs-attribute">nid</span>=0x3938 runnable  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Attach Listener&quot;</span> #5 daemon <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=62.50ms <span class="hljs-attribute">elapsed</span>=27.90s <span class="hljs-attribute">tid</span>=0x00000245911e9000 <span class="hljs-attribute">nid</span>=0x28fc waiting on condition  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;C2 CompilerThread0&quot;</span> #6 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=437.50ms <span class="hljs-attribute">elapsed</span>=27.90s <span class="hljs-attribute">tid</span>=0x00000245911eb800 <span class="hljs-attribute">nid</span>=0x2e78 waiting on condition  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br>   <span class="hljs-literal">No</span> compile task<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;C1 CompilerThread0&quot;</span> #8 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=187.50ms <span class="hljs-attribute">elapsed</span>=27.90s <span class="hljs-attribute">tid</span>=0x00000245911f2000 <span class="hljs-attribute">nid</span>=0x4be0 waiting on condition  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br>   <span class="hljs-literal">No</span> compile task<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Sweeper thread&quot;</span> #9 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=15.63ms <span class="hljs-attribute">elapsed</span>=27.88s <span class="hljs-attribute">tid</span>=0x0000024591ab0000 <span class="hljs-attribute">nid</span>=0x13b8 runnable  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Common-Cleaner&quot;</span> #10 daemon <span class="hljs-attribute">prio</span>=8 <span class="hljs-attribute">os_prio</span>=1 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=27.66s <span class="hljs-attribute">tid</span>=0x00000245f264d000 <span class="hljs-attribute">nid</span>=0x40e4 <span class="hljs-keyword">in</span> Object.wait()  [0x0000005b989ff000]<br>   java.lang.Thread.State: TIMED_WAITING (on object monitor)<br>        at java.lang.Object.wait(java.base@11/Native Method)<br>        - waiting on &lt;0x000000008472a448&gt; (a java.lang.ref.ReferenceQueue<span class="hljs-variable">$Lock</span>)<br>        at java.lang.ref.ReferenceQueue.<span class="hljs-built_in">remove</span>(java.base@11/ReferenceQueue.java:155)<br>        - waiting <span class="hljs-keyword">to</span> re-lock <span class="hljs-keyword">in</span> wait() &lt;0x000000008472a448&gt; (a java.lang.ref.ReferenceQueue<span class="hljs-variable">$Lock</span>)<br>        at jdk.internal.ref.CleanerImpl.<span class="hljs-built_in">run</span>(java.base@11/CleanerImpl.java:148)<br>        at java.lang.Thread.<span class="hljs-built_in">run</span>(java.base@11/Thread.java:834)<br>        at jdk.internal.misc.InnocuousThread.<span class="hljs-built_in">run</span>(java.base@11/InnocuousThread.java:134)<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Monitor Ctrl-Break&quot;</span> #11 daemon <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">os_prio</span>=0 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=27.45s <span class="hljs-attribute">tid</span>=0x0000024591d54000 <span class="hljs-attribute">nid</span>=0x34b0 runnable  [0x0000005b98afe000]<br>   java.lang.Thread.State: RUNNABLE<br>        at java.net.SocketInputStream.socketRead0(java.base@11/Native Method)<br>        at java.net.SocketInputStream.socketRead(java.base@11/SocketInputStream.java:115)<br>        at java.net.SocketInputStream.read(java.base@11/SocketInputStream.java:168)<br>        at java.net.SocketInputStream.read(java.base@11/SocketInputStream.java:140)<br>        at sun.nio.cs.StreamDecoder.readBytes(java.base@11/StreamDecoder.java:284)<br>        at sun.nio.cs.StreamDecoder.implRead(java.base@11/StreamDecoder.java:326)<br>        at sun.nio.cs.StreamDecoder.read(java.base@11/StreamDecoder.java:178)<br>        - locked &lt;0x000000008471f758&gt; (a java.io.InputStreamReader)<br>        at java.io.InputStreamReader.read(java.base@11/InputStreamReader.java:185)<br>        at java.io.BufferedReader.fill(java.base@11/BufferedReader.java:161)<br>        at java.io.BufferedReader.readLine(java.base@11/BufferedReader.java:326)<br>        - locked &lt;0x000000008471f758&gt; (a java.io.InputStreamReader)<br>        at java.io.BufferedReader.readLine(java.base@11/BufferedReader.java:392)<br>        at com.intellij.rt.execution.application.AppMainV2<span class="hljs-variable">$1</span>.<span class="hljs-built_in">run</span>(AppMainV2.java:55)<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Service Thread&quot;</span> #12 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=0 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=27.45s <span class="hljs-attribute">tid</span>=0x0000024591d2d800 <span class="hljs-attribute">nid</span>=0x3abc runnable  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;VM Thread&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=31.25ms <span class="hljs-attribute">elapsed</span>=28.03s <span class="hljs-attribute">tid</span>=0x00000245911af000 <span class="hljs-attribute">nid</span>=0x41dc runnable<br><br><span class="hljs-string">&quot;GC Thread#0&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.19s <span class="hljs-attribute">tid</span>=0x00000245f2583000 <span class="hljs-attribute">nid</span>=0x3708 runnable<br><br><span class="hljs-string">&quot;GC Thread#1&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=25.42s <span class="hljs-attribute">tid</span>=0x0000024591dfd800 <span class="hljs-attribute">nid</span>=0x223c runnable<br><br><span class="hljs-string">&quot;GC Thread#2&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=25.42s <span class="hljs-attribute">tid</span>=0x0000024591dfe000 <span class="hljs-attribute">nid</span>=0x3e60 runnable<br><br><span class="hljs-string">&quot;G1 Main Marker&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.18s <span class="hljs-attribute">tid</span>=0x00000245f25b1800 <span class="hljs-attribute">nid</span>=0x4a5c runnable<br><br><span class="hljs-string">&quot;G1 Conc#0&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.18s <span class="hljs-attribute">tid</span>=0x00000245f25b4800 <span class="hljs-attribute">nid</span>=0x3378 runnable<br><br><span class="hljs-string">&quot;G1 Refine#0&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.18s <span class="hljs-attribute">tid</span>=0x00000245f2644000 <span class="hljs-attribute">nid</span>=0x1e0c runnable<br><br><span class="hljs-string">&quot;G1 Young RemSet Sampling&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.18s <span class="hljs-attribute">tid</span>=0x00000245f2647000 <span class="hljs-attribute">nid</span>=0x4054 runnable<br><span class="hljs-string">&quot;VM Periodic Task Thread&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=27.45s <span class="hljs-attribute">tid</span>=0x0000024591d93000 <span class="hljs-attribute">nid</span>=0x2c64 waiting on condition<br><br>JNI global refs: 15, weak refs: 0<br></code></pre></td></tr></table></figure><p>线程中参数解释：<br>tid: Java memory address of its internal Thread control structure. 16进制的<br>nid: native thread id. 每一个nid对应于linux下的一个tid, 即lwp (light weight process, or thread). 16进制的，转到10进制后可以用ps命令找到它。<br>prio: java内定义的线程的优先级<br>os_prio: 操作系统级别的优先级<br>cpu: 为cpu运行时间<br>elapsed: 为实际运行时间<br>daemon: 说明是守护线程</p><ul><li>JvisualVm</li></ul><p>VisualVM是一款免费的\集成了多个JDK命令行工具的可视化工具，是功能最强大的运行监控和故障处理程序之一，曾经很长一段时间是oracle官方主力发展的虚拟机故障处理工具。功能包括生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和CPU分析，同时它还支持在MBeans上进行浏览和操作。可以基于该工具实现线程转储和可视化监测。</p><p>参考:<br>《Java多线程编程实战指南》黄文海<br><a href="https://www.cnblogs.com/lllliuxiaoxia/p/15799378.html">jvm监控工具小结</a></p><h2 id="线程安全问题的三个方面"><a href="#线程安全问题的三个方面" class="headerlink" title="线程安全问题的三个方面"></a>线程安全问题的三个方面</h2><p>线程安全问题概括来说表现为3个方面：原子性、可见性和有序性。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子操作的“不可分割”包括以下两层含义。</p><ul><li>访问（读、写）某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生，即其他线程不会“看到”该操作执行了部分的中间效果。</li><li>访问同一组共享变量的原子操作是不能够被交错的。</li></ul><p>Java中有两种方式来实现原子性。一种是使用锁（Lock）。锁具有排他性，即它能够保障一个共享变量在任意一个时刻只能够被一个线程访问。这就排除了多个线程在同一时刻访问同一个共享变量而导致干扰与冲突的可能，即消除了竞态。另一种是利用处理器提供的专门CAS（Compare-and-Swap）指令，CAS算作乐观锁。</p><p>Java语言中针对任何变量的读操作都是原子操作。在Java语言中，long型和double型以外的任何类型的变量的写操作都是原子操作。对long&#x2F;double型变量的写操作由于Java语言规范并不保障其具有原子性，因此在多个线程并发访问同一long&#x2F;double型变量的情况下，一个线程可能会读取到其他线程更新该变量的“中间结果”。尽管如此，Java语言规范特别地规定对于volatile关键字修饰的long&#x2F;double型变量的写操作具有原子性。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性就是指一个线程对共享变量的更新的结果对于读取相应共享变量的线程而言是否可见的问题。多线程程序在可见性方面存在问题意味着某些线程读取到了旧数据（StaleData）。导致可见性问题的原因分为两种，一种是JIT编译器的优化，需要基于一定机制避免多线程情况下的不正常编译优化；另一种是没有及时进行缓存同步，要通过使更新共享变量的处理器执行冲刷处理器缓存的动作，并使读取共享变量的处理器执行刷新处理器缓存的动作来保障可见性。</p><p>可见性的保障仅仅意味着一个线程能够读取到共享变量的相对新值，而不能保障该线程能够读取到相应变量的最新值，即读到数据后到使用的时候，原来的数据可能已经发生了变化。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>多种因素都可能导致程序的感知顺序与源代码顺序不一致，而这种不一致可能导致线程安全问题。避免这个问题实质上就是保证感知顺序与源代码顺序一致，即有序性。</p><p>导致有序性问题的来源分为：（1）指令重排序。指令重排序主要来源于JIT的编译优化和处理器在判断语句场景的猜测执行技术；（2）存储系统重排序。即使在处理器严格依照程序顺序执行两个内存访问操作的情况下，在存储子系统的作用下其他处理器对这两个操作的感知顺序仍然可能与程序顺序不一致，即这两个操作的执行顺序看起来像是发生了变化。这种现象就是存储子系统重排序，也被称为内存重排序（MemoryOrdering）。</p><p>单线程也会发生重排序，但是结果不会出现异常，就仿佛是串行执行的一样；要保证多线程的有序性，需要在逻辑上部分禁止重排序。</p><p>参考:<br>《Java多线程编程实战指南》黄文海</p><h2 id="Thread类中的start和run方法的区别是什么？"><a href="#Thread类中的start和run方法的区别是什么？" class="headerlink" title="Thread类中的start和run方法的区别是什么？"></a>Thread类中的start和run方法的区别是什么？</h2><p>Thread类的start方法的作用是启动相应的线程，并在这个新线程中执行run方法，线程属于“一次性用品”，start方法也只能够被调用一次，多次调用同一个Thread实例的start方法会导致其抛出IllegalThreadStateException异常。</p><p>Thread类的run方法可以反复执行，但是是在当前线程中执行，不会创建新线程，一般不建议这样操作。</p><p>参考:<br>《Java多线程编程实战指南》黄文海</p><h2 id="Runnable和Callable？Future的作用是什么？"><a href="#Runnable和Callable？Future的作用是什么？" class="headerlink" title="Runnable和Callable？Future的作用是什么？"></a>Runnable和Callable？Future的作用是什么？</h2><h3 id="Runnable和Callable"><a href="#Runnable和Callable" class="headerlink" title="Runnable和Callable"></a>Runnable和Callable</h3><p>Runnable接口可以被看作对任务进行的抽象，任务的处理逻辑就体现在run方法之中。Thread类实际上是Runnable接口的一个实现类，其对Runnable接口的实现。</p><p>Callable接口也是对任务的抽象，任务的处理逻辑可以在Callable接口实现类的call方法中实现。Callable接口相当于一个增强型的Runnable接口：call方法的返回值代表相应任务的处理结果，其类型V是通过Callable接口的类型参数指定的；call方法代表的任务在其执行过程中可以抛出异常。而Runnable接口中的run方法既无返回值也不能抛出异常。</p><p>采用Runnable实例来表示异步任务，其优点是任务既可以交给一个专门的工作者线程执行（以相应的Runnable实例为参数创建并启动一个工作者线程），也可以交给一个线程池或者Executor的其他实现类来执行；其缺点是我们无法直接获取任务的执行结果。使用Callable实例来表示异步任务，其优点是我们可以通过ThreadPoolExecutor.submit(Callable<T>)的返回值获取任务的处理结果；其缺点是Callable实例表示的异步任务只能交给线程池执行，而无法直接交给一个专门的工作者线程或者Executor实现类执行。</T></p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future接口实例可被看作任务的处理结果句柄（Handle），Future.get()方法可以用来获取task参数所指定的任务的处理结果，Future.get()是个阻塞方法，该方法能够抛出InterruptedException说明它可以响应线程中断，可以通过捕获Future.get()调用抛出的异常来知晓相应任务执行过程中抛出的异常。ThreadPoolExecutor线程池的一个submit方法声明如下：public<T>Future<T>submit(Callable<T>task)，可以通过提交Callable任务并通过Future.get()获取结果。</T></T></T></p><p>java.util.concurrent.FutureTask类融合了Runnable接口和Callable接口的优点：FutureTask是java.util.concurrent.RunnableFuture接口的一个实现类，由于RunnableFuture接口继承了Future接口和Runnable接口，因此FutureTask既是Runnable接口的实现类也是Future接口的实现。因此FutureTask表示的异步任务可以交给专门的工作者线程执行，也可以交给Executor实例（比如线程池）执行，FutureTask还能够直接返回其代表的异步任务的处理结果。ThreadPoolExecutor.submit(Callable<T>task)的返回值就是一个FutureTask实例。</T></p><p>FutureTask的一个构造器可以将Callable实例转换为Runnable实例，该构造器的声明如下：publicFutureTask(Callable<V>callable)。<br>我们可以将任务的处理逻辑封装在一个Callable实例中，并以该实例为参数创建一个FutureTask实例，我们可以用FutureTask实例（Runnable实例）为参数来创建并启动一个工作者线程以执行相应的任务，也可以将FutureTask实例交给Executor执行（通过Executor.execute(Runnabletask)调用），FutureTask类还实现了Future接口，这使得我们在调用Executor.execute(Runnabletask)这样只认Runnable接口的方法来执行任务的情况下依然能够获取任务的执行结果。</V></p><p>参考:<br>《Java多线程编程实战指南》黄文海</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ">微信公众号:我的IT技术路</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>道德经</title>
    <link href="/2023/01/05/%E9%81%93%E5%BE%B7%E7%BB%8F/"/>
    <url>/2023/01/05/%E9%81%93%E5%BE%B7%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《道德经》 老子 中国华侨出版社</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>略</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>上善若水。水善利万物而不争，处众人之所恶，故几于道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤。</li><li>五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎，令人心发狂，难得之货，令人行妨。是以圣人为腹不为目，故去彼取此。</li><li>企者不立；跨者不行；自见者不明；自是者不彰；自伐者无功；自矜者不长。其在道也，曰：余食赘形。物或恶之，故有道者不处。</li><li>重为轻根，静为躁君。是以君子终日行不离辎重。虽有荣观，燕处超然。奈何万乘之主，而以身轻天下？轻则失根，躁则失君。</li><li>将欲歙之，必固张之；将欲弱之，必固强之；将欲废之，必固兴之；将欲取之，必固与之。是谓微明。柔弱胜刚强。鱼不可脱于渊，国之利器不可以示人。</li><li>名与身孰亲？身与货孰多？得与亡孰病？甚爱必大费；多藏必厚亡。故知足不辱，知止不殆，可以长久。</li><li>反者道之动。弱者道之用。天下万物生于有，有生于无。</li><li>大成若缺，其用不弊。大盈若冲，其用不穷。大直若屈，大巧若拙，大辩若讷。静胜躁，寒胜热。清静为天下正。</li><li>为学日益，为道日损。损之又损，以至于无为。无为而无不为。取天下常以无事，及其有事，不足以取天下。</li><li>其安易持，其未兆易谋。其脆易泮，其微易散。为之于未有，治之于未乱。合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。为者败之，执者失之。是以圣人无为故无败，无执故无失。民之从事，常于几成而败之。慎终如始，则无败事。是以圣人欲不欲，不贵难得之货；学不学，复众人之所过，以辅万物之自然而敢为。</li><li>天下皆谓我：道大，似不肖。夫唯大，故似不肖。若肖，久矣其细也夫！我有三宝，持而保之：一曰慈，二曰俭，三曰不敢为天下先。慈故能勇；俭故能广；不敢为天下先，故能成器长。今舍慈且勇，舍俭且广，舍后且先，死矣！夫慈，以战则胜，以守则固，天将救之，以慈卫之。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>无论顺境逆境，保持一颗平常心，低调做人。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>菜根谭</title>
    <link href="/2023/01/03/%E8%8F%9C%E6%A0%B9%E8%B0%AD/"/>
    <url>/2023/01/03/%E8%8F%9C%E6%A0%B9%E8%B0%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《菜根谭》 洪应明 吉林出版集团有限责任公司</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>略</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>处世让一步为高，退步即进步的张本；待人宽一分是福，利人是利己的根基。</li><li>完名美节，不宜独任，分些与人，可以远害全身；辱行污名，不宜全推，引些归己，可以韬光养德。</li><li>忧勤是美德，太苦则无以适性怡情；澹泊是高风，太枯则无以济人利物。</li><li>澹泊之士，必为浓艳者所疑；检饬之人，多为放肆者所忌。君子处此，故不可稍变其操履，亦不可太露其锋芒！</li><li>善人未能急亲，不宜预扬，恐来谗谮之奸；恶人未能轻去，不宜先发，恐遭媒孽之祸。</li><li>建功立业者，多虚圆之士；偾事失机者，必执拗之人。</li><li>十语九中未必称奇，一语不中则愆尤骈集；十谋九成未必归功，一谋不成则訾议丛兴。君子所以宁默毋躁，宁拙毋巧。</li><li>老来疾病，都是壮时招的；衰后罪孽，都是盛时造的。故持盈履满，君子尤兢兢焉。</li><li>锄奸杜倖，要放他一条去路。若使之一无所容，譬如塞鼠穴者，一切去路都塞尽，则一切好物俱咬破矣。</li><li>事有急之不白者，宽之或自明，毋躁急以速其忿；人有操之不从者，纵之或自化，毋躁切以益其顽。</li><li>恩宜自淡而浓；先浓后淡者，人忘其惠。威宜自严而宽；先宽后严者，人怨其酷。</li><li>忙里要偷闲，须先向闲时讨个把柄；闹中要取静，须先从静处立个主宰。不然未有不因境而迁，随事而靡者。</li><li>闻恶不可就恶，恐为谗夫泄怒；闻善不可即亲，恐引奸人进身。</li><li>不可乘喜而轻诺，不可因醉而生嗔，不可乘快而多事，不可因倦而鲜终。</li><li>今人专求无念，而终不可无。只是前念不滞，后念不迎，但将现在的随缘打发得去，自然渐渐入无。</li><li>不责人小过，不发人阴私，不念人旧恶。三者可以养德，亦可以远害。</li><li>胜私制欲之功，有曰识不早力不易者，有曰识得破忍不过者，盖识是一颗照魔的明珠，力是一把斩魔的慧剑，两不可少也。</li><li>觉人之诈不形于言，受人之侮不动于色，此中有无穷意味，亦有无穷受用。</li><li>损之又损，栽花种竹，尽交还乌有先生；忘无可忘，焚香煮茗，总不问白衣童子。</li><li>无风月花柳不成造化，无情欲嗜好不成心体。只以我转物，不以物役我，则嗜欲莫非天机，尘情即是理境矣。</li><li>忙处不乱性，须闲处心神养得清；死时不动心，须生时事物看得破。</li><li>悠长之趣，不得于酿酽，而得于啜菽饮水；惆恨之怀，不生于枯寂，而是生于品竹调丝。故知浓处味常短，淡中趣独真也。</li><li>知成之必败，则求成之心不必太坚；知生之必死，则保生之道不必过劳。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>嚼得菜根者，百事可做。需要反复品读思考。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书与做人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb学习-MVC</title>
    <link href="/2022/12/31/JavaWeb%E5%AD%A6%E4%B9%A0-MVC/"/>
    <url>/2022/12/31/JavaWeb%E5%AD%A6%E4%B9%A0-MVC/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于JavaWeb基础知识进行优化，形成了MVC的开发模式。</p><h1 id="程序结构优化"><a href="#程序结构优化" class="headerlink" title="程序结构优化"></a>程序结构优化</h1><p>教程原来案例中的servlet太多了，希望只有一个servlet，把原来多个servlet的合并成一个，根据参数operation判断用哪个方法并用反射调用，都写到了新servlet的service方法中了。引入dispatcherservlet，作为中心控制器，把原来整合后的servlet都换成controller，不再是servlet了。<br>dispatcherservlet开始加载不同关键字和controller的对应关系，然后根据前端传入的url关键字(servletpath)调用不同controller，然后根据参数operation调用controller中不同的方法。<br>原来controller中的重定向，改为返回重定向的信息String，由dispatcherservlet接收后统一重定向（如果需要重定向的话），参数获取也由dispatcherservlet统一基于反射获取然后传给controller中的方法，不在需要在controller进行参数获取和重定向，controller变成一个普通类。</p><p><img src="/2022/12/31/JavaWeb%E5%AD%A6%E4%B9%A0-MVC/javaweb%E4%BC%98%E5%8C%96%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF.png"></p><p>另外将业务逻辑抽出为Service层，来将Dao中的单精度操作聚合，使web整体层次更清晰。</p><p><img src="/2022/12/31/JavaWeb%E5%AD%A6%E4%B9%A0-MVC/Service%E5%B1%82.png"></p><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>MVC : Model（模型）、View（视图）、Controller（控制器）<br>视图层：用于做数据展示以及和用户交互的一个界面<br>控制层：能够接受客户端的请求，具体的业务功能还是需要借助于模型组件来完成<br>模型层：模型分为很多种：有比较简单的pojo&#x2F;vo(value object)，有业务模型组件，有数据访问层组件<br>    1) pojo&#x2F;vo : 值对象<br>    2) DAO ： 数据访问对象，DAO中的方法都是单精度方法或者称之为细粒度方法。什么叫单精度？一个方法只考虑一个操作，比如添加，那就是insert操作、查询那就是select操作….<br>    3) BO ： 业务对象，BO中的方法属于业务方法，也实际的业务是比较复杂的，因此业务方法的粒度是比较粗的</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>Filter也属于Servlet规范。</p><p>Filter开发步骤：新建类实现Filter接口，然后实现其中的三个方法：init、doFilter、destroy</p><p>配置Filter，可以用注解@WebFilter，也可以使用xml文件 <filter> <filter-mapping></filter-mapping></filter></p><p>Filter在配置时，和servlet一样，也可以配置通配符，例如 @WebFilter(“*.do”)表示拦截所有以.do结尾的请求</p><p>以下是一个Filter的案例，拦截所有以.do结尾的请求，会在处理请求前先打印”helloA”然后等请求处理完之后再打印”helloA2”</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@WebFilter</span>(<span class="hljs-string">&quot;*.do&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Filter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;helloA&quot;</span>);<br>        <span class="hljs-comment">//放行</span><br>        filterChain.doFilter(servletRequest,servletResponse);<br>        System.out.println(<span class="hljs-string">&quot;helloA2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h2><p>监听器分类：</p><ol><li>ServletContextListener - 监听ServletContext对象的创建和销毁的过程</li><li>HttpSessionListener - 监听HttpSession对象的创建和销毁的过程</li><li>ServletRequestListener - 监听ServletRequest对象的创建和销毁的过程</li><li>ServletContextAttributeListener - 监听ServletContext的保存作用域的改动(add,remove,replace)</li><li>HttpSessionAttributeListener - 监听HttpSession的保存作用域的改动(add,remove,replace)</li><li>ServletRequestAttributeListener - 监听ServletRequest的保存作用域的改动(add,remove,replace)</li><li>HttpSessionBindingListener - 监听某个对象在Session域中的创建与移除</li><li>HttpSessionActivationListener - 监听某个对象在Session域中的序列化和反序列化</li></ol><p>监听器举例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServletContextListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServletContextListener</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">contextInitialized</span>(<span class="hljs-params">ServletContextEvent servletContextEvent</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Servlet上下文对象初始化动作被我监听到了....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">contextDestroyed</span>(<span class="hljs-params">ServletContextEvent servletContextEvent</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Servlet上下文对象销毁动作被我监听到了.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>Cookie是浏览器端的缓存</p><ul><li>设置Cookie的有效时长<br>cookie.setMaxAge(60)  ， 设置cookie的有效时长是60秒</li><li>Cookie的应用：<br>记住用户名和密码十天 setMaxAge(60 * 60 * 24 * 10)<br>十天免登录</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1AS4y177xJ/">尚硅谷javaweb教程</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb学习-tomcat和servlet</title>
    <link href="/2022/12/29/JavaWeb%E5%AD%A6%E4%B9%A0-tomcat%E5%92%8Cservlet/"/>
    <url>/2022/12/29/JavaWeb%E5%AD%A6%E4%B9%A0-tomcat%E5%92%8Cservlet/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍javaweb的基本知识，包括CS和BS的架构形式、web容器、servlet等。</p><h1 id="CS和BS"><a href="#CS和BS" class="headerlink" title="CS和BS"></a>CS和BS</h1><h2 id="CS：客户端服务器架构模式"><a href="#CS：客户端服务器架构模式" class="headerlink" title="CS：客户端服务器架构模式"></a>CS：客户端服务器架构模式</h2><p>优点：充分利用客户端机器的资源，减轻服务器的负荷。<br>缺点：需要安装；升级维护成本较高。</p><h2 id="BS：浏览器服务器架构模式"><a href="#BS：浏览器服务器架构模式" class="headerlink" title="BS：浏览器服务器架构模式"></a>BS：浏览器服务器架构模式</h2><p>优点：客户端不需要安装；维护成本较低。<br>缺点：所有的计算和存储任务都是放在服务器端的，服务器的负荷较重；在服务端计算完成之后把结果再传输给客户端，网络负荷较重。</p><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Tomcat简单的说就是一个运行JAVA的网络服务器，底层是Socket的一个程序，它也是JSP和Serlvet的一个容器。<br>将编译好的java文件和前端文件按照一定格式放入Tomcat的webapps文件夹，然后启动Tomcat即可启动这个javaweb服务。 </p><h1 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h1><p>通过前端页面的表单中的action和method以及web项目中web.xml配置文件，可以将表单中的数据发送给后端指定的servlet，通过在servlet中实现doPost、doGet等方法可以获取前端表单的数据，可以实现前后端的数据交互。</p><h2 id="servlet基本信息"><a href="#servlet基本信息" class="headerlink" title="servlet基本信息"></a>servlet基本信息</h2><ol><li>继承关系：HttpServlet -&gt; GenericServlet -&gt; Servlet</li><li>Servlet中的核心方法： init() , service() , destroy()</li><li>服务方法：当有请求过来时，service方法会自动响应（其实是tomcat容器调用的），在HttpServlet中我们会去分析请求的方式：到底是get、post、head还是delete等等，然后再决定调用的是哪个do开头的方法。</li></ol><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><ol><li>生命周期：从出生到死亡的过程就是生命周期。对应Servlet中的三个方法：init(),service(),destroy()。</li><li>默认情况下：<br>  第一次接收请求时，这个Servlet会进行实例化(调用构造方法)、初始化(调用init())、然后服务(调用service())<br>  从第二次请求开始，每一次都是服务<br>  当容器关闭时，其中的所有的servlet实例会被销毁，调用销毁方法</li><li>通过案例我们发现：</li></ol><ul><li>Servlet实例tomcat只会创建一个，所有的请求都是这个实例去响应。</li><li>默认情况下，第一次请求时，tomcat才会去实例化，初始化，然后再服务。</li><li>因此得出结论：如果需要提高系统的启动速度，当前默认情况就是这样。如果需要提高响应速度，我们应该设置Servlet的初始化时机。</li></ul><ol start="4"><li>Servlet在容器中是：单例的、线程不安全的</li></ol><h2 id="html界面如何把信息传给servlet"><a href="#html界面如何把信息传给servlet" class="headerlink" title="html界面如何把信息传给servlet"></a>html界面如何把信息传给servlet</h2><p>web项目在tomcat中部署后，通过操作前端界面即可将前端界面的信息传给后端，例如以下一个html界面<code>http://localhost:8080/pro07/add.html</code>中有一个表单，当我们填写完信息点击submit按钮是，会触发add方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        名称：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        价格：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;price&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        库存：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fcount&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        备注：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;remark&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;添加&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时地址栏的url变为<code>http://localhost:8080/pro07/add</code>，基于tomcat的web.xml配置，<code>/add</code>将匹配名为<code>AddServlet</code>的servlet，然后这个servlet会匹配<code>com.atguigu.servlets.AddServlet</code>类，根据add的方法为post，将匹配<code>com.atguigu.servlets.AddServlet</code>中的doPost方法并执行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>AddServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.atguigu.servlets.AddServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>AddServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/add<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    1. 用户发请求，action=add</span><br><span class="hljs-comment">    2. 项目中，web.xml中找到url-pattern = /add   -&gt; 第12行</span><br><span class="hljs-comment">    3. 找第11行的servlet-name = AddServlet</span><br><span class="hljs-comment">    4. 找和servlet-mapping中servlet-name一致的servlet ， 找到第7行</span><br><span class="hljs-comment">    5. 找第8行的servlet-class -&gt; com.atguigu.servlets.AddServlet</span><br><span class="hljs-comment">    6. 用户发送的是post请求（method=post） ， 因此 tomcat会执行AddServlet中的doPost方法</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><ol><li>Http是无状态的</li></ol><ul><li>HTTP 无状态：服务器无法判断这两次请求是同一个客户端发过来的，还是不同的客户端发过来的</li><li>无状态带来的现实问题：第一次请求是添加商品到购物车，第二次请求是结账；如果这两次请求服务器无法区分是同一个用户的，那么就会导致混乱</li><li>通过会话跟踪技术来解决无状态的问题。</li></ul><ol start="2"><li>会话跟踪技术</li></ol><ul><li><p>客户端第一次发请求给服务器，服务器获取session，获取不到，则创建新的，然后响应给客户端</p></li><li><p>下次客户端给服务器发请求时，会把sessionID带给服务器，那么服务器就能获取到了，那么服务器就判断这一次请求和上次某次请求是同一个客户端，从而能够区分开客户端</p></li><li><p>常用的API：<br>request.getSession() -&gt; 获取当前的会话，没有则创建一个新的会话<br>request.getSession(true) -&gt; 效果和不带参数相同<br>request.getSession(false) -&gt; 获取当前会话，没有则返回null，不会创建新的</p><p>session.getId() -&gt; 获取sessionID<br>session.isNew() -&gt; 判断当前session是否是新的<br>session.getMaxInactiveInterval() -&gt; session的非激活间隔时长，默认1800秒<br>session.setMaxInactiveInterval()<br>session.invalidate() -&gt; 强制性让会话立即失效<br>….</p></li></ul><ol start="3"><li>session保存作用域，可以在某个session中存放数据，在该session生命周期中有效</li></ol><ul><li>session保存作用域是和具体的某一个session对应的</li><li>常用的API：<br>void session.setAttribute(k,v)<br>Object session.getAttribute(k)<br>void removeAttribute(k)</li></ul><h2 id="服务器内部转发以及客户端重定向"><a href="#服务器内部转发以及客户端重定向" class="headerlink" title="服务器内部转发以及客户端重定向"></a>服务器内部转发以及客户端重定向</h2><ol><li>服务器内部转发 : request.getRequestDispatcher(“…”).forward(request,response);</li></ol><ul><li>一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的</li><li>地址栏没有变化</li></ul><ol start="2"><li>客户端重定向： response.sendRedirect(“….”);</li></ol><ul><li>两次请求响应的过程。客户端肯定知道请求URL有变化</li><li>地址栏有变化</li></ul><h2 id="Thymeleaf-视图模板技术"><a href="#Thymeleaf-视图模板技术" class="headerlink" title="Thymeleaf - 视图模板技术"></a>Thymeleaf - 视图模板技术</h2><p>thymeleaf直接在html中使用，是一个模板引擎，可以将后端的结果动态渲染成前端界面。</p><ol><li>添加thymeleaf的jar包</li><li>新建一个Servlet类ViewBaseServlet</li><li>在web.xml文件中添加配置<ul><li>配置前缀 view-prefix</li><li>配置后缀 view-suffix</li></ul></li><li>使得我们的Servlet继承ViewBaseServlet</li><li>根据逻辑视图名称 得到 物理视图名称<br>&#x2F;&#x2F;此处的视图名称是 index<br>&#x2F;&#x2F;那么thymeleaf会将这个 逻辑视图名称 对应到 物理视图 名称上去<br>&#x2F;&#x2F;逻辑视图名称 ：   index<br>&#x2F;&#x2F;物理视图名称 ：   view-prefix + 逻辑视图名称 + view-suffix<br>&#x2F;&#x2F;所以真实的视图名称是：      &#x2F;       index       .html<br>super.processTemplate(“index”,request,response);</li><li>使用thymeleaf的标签<br>  th:if   ,  th:unless   , th:each   ,   th:text</li></ol><p>以下是thymeleaf的样例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//Servlet从3.0版本开始支持注解方式的注册,不用在web.xml配置表单的action和servlet的关系，直接基于注解匹配</span><br><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">&quot;/index&quot;</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewBaseServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public void doGet(<span class="hljs-type">HttpServletRequest</span> request , <span class="hljs-type">HttpServletResponse</span> response)<span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span>, <span class="hljs-type">ServletException</span> &#123;<br>        <span class="hljs-type">FruitDAO</span> fruitDAO = <span class="hljs-keyword">new</span> <span class="hljs-type">FruitDAOImpl</span>();<br>        <span class="hljs-type">List</span>&lt;<span class="hljs-type">Fruit</span>&gt; fruitList = fruitDAO.getFruitList();<br>        <span class="hljs-comment">//保存到session作用域</span><br>        <span class="hljs-type">HttpSession</span> session = request.getSession() ;<br>        session.setAttribute(<span class="hljs-string">&quot;fruitList&quot;</span>,fruitList);<br>        <span class="hljs-comment">//此处的视图名称是 index</span><br>        <span class="hljs-comment">//那么thymeleaf会将这个 逻辑视图名称 对应到 物理视图 名称上去</span><br>        <span class="hljs-comment">//逻辑视图名称 ：   index</span><br>        <span class="hljs-comment">//物理视图名称 ：   view-prefix + 逻辑视图名称 + view-suffix</span><br>        <span class="hljs-comment">//所以真实的视图名称是：      /       index       .html</span><br>        <span class="hljs-keyword">super</span>.processTemplate(<span class="hljs-string">&quot;index&quot;</span>,request,response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是web.xml中的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置上下文参数 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>view-prefix<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>view-suffix<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>.html<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下是加入thymeleaf的html，实现了后端数据的前端渲染</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div_container&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div_fruit_list&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center f30&quot;</span>&gt;</span>欢迎使用水果库存后台管理系统<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tbl_fruit&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;w20&quot;</span>&gt;</span>名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;w20&quot;</span>&gt;</span>单价<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;w20&quot;</span>&gt;</span>库存<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">lists.isEmpty</span>(session.fruitList)&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>对不起，库存为空！<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:unless</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-tag">&#123;#<span class="hljs-name">lists.isEmpty</span>(session.fruitList)&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;fruit : $</span></span></span><span class="hljs-template-variable">&#123;session.fruitList&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;fruit.fname&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;fruit.price&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;fruit.fcount&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;imgs/del.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;delImg&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><h2 id="保存作用域"><a href="#保存作用域" class="headerlink" title="保存作用域"></a>保存作用域</h2><p>原始情况下，保存作用域我们可以认为有四个： page（页面级别，现在几乎不用） , request（一次请求响应范围） , session（一次会话范围） , application（整个应用程序范围）</p><ol><li>request：一次请求响应范围</li><li>session：一次会话范围有效</li><li>application：一次应用程序范围有效</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1AS4y177xJ/">尚硅谷javaweb教程</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法题集锦</title>
    <link href="/2022/12/28/%E7%AE%97%E6%B3%95%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <url>/2022/12/28/%E7%AE%97%E6%B3%95%E9%A2%98%E9%9B%86%E9%94%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="信件错排"><a href="#信件错排" class="headerlink" title="信件错排"></a>信件错排</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>NowCoder每天要给很多人发邮件。有一天他发现发错了邮件，把发给A的邮件发给了B，把发给B的邮件发给了A。于是他就思考，要给n个人发邮件，在每个人仅收到1封邮件的情况下，有多少种情况是所有人都收到了错误的邮件？即没有人收到属于自己的邮件。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用dp[n]表示，那么dp[n-1]就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推.<br>第一步，把第n个元素放在一个位置，比如位置k，一共有n-1种方法；<br>第二步，放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有dp[n-2]种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有dp[n-1]种方法；</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">erroNum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n=<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(n=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> []dp=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [n+<span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;<br>        dp[i]=(i<span class="hljs-number">-1</span>)*(dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="母牛生产"><a href="#母牛生产" class="headerlink" title="母牛生产"></a>母牛生产</h1><p>题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。</p><p>第 i 年成熟的牛的数量为：<br>dp[i] &#x3D; dp[i - 1] + dp[i - 3]</p><h1 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h1><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p><p>定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p><p>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] &#x3D; dp[i-1][j]。<br>第 i 件物品添加到背包中，dp[i][j] &#x3D; dp[i-1][j-w] + v。</p><p>以下为基本解题思路</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs inform7">public static int knapsack(int W, int N, int<span class="hljs-comment">[]</span> weights, int<span class="hljs-comment">[]</span> values) &#123;<br>    int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> dp = new int<span class="hljs-comment">[N + 1]</span><span class="hljs-comment">[W + 1]</span>;<br>    for (int i = 1; i &lt;= N; i++)&#123;<br>        int weight = weights<span class="hljs-comment">[i - 1]</span>;<br>        int value = values<span class="hljs-comment">[i - 1]</span>;<br>        for (int j = 1; j &lt;= W; j++)&#123;<br>            if (weight &lt;= j)&#123;<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = Math.max(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - weight]</span> + value);<br>            &#125; else &#123;<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return dp<span class="hljs-comment">[N]</span><span class="hljs-comment">[W]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用一维dp来优化空间，在一维的dp上反复更新，即dp[i][j]同时代表dp[i][j]和dp[i - 1][j]，因此将不同物品的那个维度去掉，但是在求<code>dp[i - 1][j - weight] + value</code>时，如果从左往右计算的话，因为计算覆盖的问题，<code>dp[i - 1][j - weight]</code>实际为<code>dp[i][j - weight]</code>，所以需要从右向左计算，这样才能保证计算的正确性。优化空间背后的基本思路还是和原来一样，当成二维dp来计算，只是用一维dp来承接dp结果。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">int</span> knapsack(<span class="hljs-type">int</span> W, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span>[] weights, <span class="hljs-type">int</span>[] <span class="hljs-keyword">values</span>) &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[W + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)&#123;<br>            <span class="hljs-type">int</span> weight = weights[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">values</span>[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = W; j &gt;= <span class="hljs-number">1</span>; j<span class="hljs-comment">--)&#123;</span><br>                <span class="hljs-keyword">if</span> (weight &lt;= j)&#123;<br>                    dp[j] = Math.max(dp[j], dp[j - weight] + <span class="hljs-keyword">value</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[W];<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 最大公约数，辗转相除法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><span class="hljs-comment">// 最小公倍数为两数的乘积除以最大公约数。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a * b / <span class="hljs-built_in">gcd</span>(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="CS-Notes">https://www.cyc2018.xyz/</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb学习-前端知识小结</title>
    <link href="/2022/12/27/JavaWeb%E5%AD%A6%E4%B9%A0-%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    <url>/2022/12/27/JavaWeb%E5%AD%A6%E4%B9%A0-%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从面向对象编程、数据结构都不懂就开始干开发已经三年多了，对于javaweb这块还是一知半解，平时基本全靠框架，所以决定自学习javaweb的相关知识，从B站找了尚硅谷javaweb2022版教程学习，并对相关的学习内容做一些小结，方便加深理解和复习查阅。</p><h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>本文对javaweb的前端知识做个简单的小结，主要内容包括html、css、javascript。其中html表示了前端页面的结构和元素，例如表格、文本框、表单等；css表示前端页面的样式，例如段落中文字的颜色、字体大小，表格中文字的颜色，字体大小等；JavaScript是弱类型的脚本语言，可以基于各种事件表示前端页面的逻辑，例如鼠标悬浮事件背景颜色改变等。</p><h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>html语言是解释型语言，下面是一个html的页面案例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>这是我的第一个网页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>HELLO WORLD!<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>你好，HTML！<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这里是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这里是第二个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;D:\sgg2021\0927_javaweb\1109\02.代码\imgs\girl.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;57&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;73&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;这里是一张图片&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题一<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>标题一<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>标题一<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>标题一<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>标题一<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>标题一<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><br>武林高手排行榜:<br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;i&quot;</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>扫地僧<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>萧远山<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>慕容博<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>虚竹<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>阿紫<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>武林大会人员名单：<br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;circle&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>乔峰<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>阿朱<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>马夫人<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>白世镜<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>你是<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>喜欢<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>是<span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>甜<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>月饼还是<span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>咸<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>月饼<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span>？<br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><br>水分子的化学式： H<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>O <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>氧气的化学式： O<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><br>5<span class="hljs-symbol">&amp;lt;</span>10<br>10<span class="hljs-symbol">&amp;gt;</span>5<br>5<span class="hljs-symbol">&amp;le;</span>10<br>10<span class="hljs-symbol">&amp;ge;</span>5<br>注册商标 <span class="hljs-symbol">&amp;reg;</span><br>版权符号 <span class="hljs-symbol">&amp;copy;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>赵又廷<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>，夺妻之仇。<br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_self&quot;</span>&gt;</span>百度一下<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>元素解释：</p><ul><li><code>&lt;html&gt; </code>称之为开始标签，<code>&lt;/html&gt;</code>称之为结束标签</li><li>title 表示网页的标题</li><li>可以在meta标签中设置编码方式（charset）</li><li><code>&lt;br/&gt;</code>表示换行。br标签是一个单标签。单标签：开始标签和结束标签是同一个，斜杠放在单词后面</li><li>p 表示段落标签</li><li>img 标签图片标签<br>  src属性表示图片文件的路径<br>  width和height表示图片的大小<br>  alt表示图片的提示</li><li>h1~h6 : 标题标签</li><li>ol 有序列表<br>  start 表示从*开始，type 显示的类型：A a I i 1(deafult)</li><li>ul 无序列表<br>  type disc(default) , circle , square</li><li>u 下划线 b 粗体  i 斜体</li><li>上标 sup   下标 sub</li><li>HTML中的实体：小于号 &lt; 大于等于号 &amp;ge; 版权 &amp;copy;</li><li>span 不换行的块标记</li><li>a 表示超链接<br>  href 链接的地址<br>  target:<br>      _self 在本窗口打开<br>      _blank 在一个新窗口打开<br>      _parent 在父窗口打开<br>      _top  在顶层窗口打开</li><li>div 层</li></ul><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>下面是一个表格的样例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>表格标签的学习<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;600&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>门派<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>成名绝技<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>内功值<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>乔峰<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>丐帮<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>少林长拳<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>5000<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>虚竹<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>灵鹫宫<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>北冥神功<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>15000<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>扫地僧<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>少林寺<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>七十二绝技<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>未知<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;16&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;1200&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>单价<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>数量<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>小计<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;imgs/del.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;24&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;24&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>菠萝<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>45<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;imgs/del.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;24&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;24&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>西瓜<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>36<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;imgs/del.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;24&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;24&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>总计<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>181<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>元素解释：</p><ul><li><p>表格基本元素<br>表格table<br>行tr<br>列td<br>表头列th</p></li><li><p>属性<br>  table中有如下属性（基本淘汰，了解即可）</p><ul><li>border：表格边框的粗细</li><li>width:表格的宽度</li><li>cellspacing：单元格间距</li><li>cellpadding：单元格填充</li></ul><p>  tr中有一个属性： align -&gt; center,left,right<br>  rowspan : 行合并<br>  colspan : 列合并</p></li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>表单样例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>表单标签的学习<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo04.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>昵称：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;请输入你的昵称&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pwd&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>性别：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>/&gt;</span>男<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">checked</span>/&gt;</span>女<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>爱好：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;basketball&quot;</span>/&gt;</span>篮球<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;football&quot;</span> <span class="hljs-attr">checked</span>/&gt;</span>足球<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;earth&quot;</span> <span class="hljs-attr">checked</span>/&gt;</span>地球<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>星座：<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;star&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>白羊座<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>金牛座<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>双子座<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>天蝎座<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span>天秤座<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>备注：<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;remark&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot; 注 册 &quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;重置&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;这是一个普通按钮&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>元素解释：</p><ul><li>表单 form<br>  action表示表单信息发往的目的地<br>  method表示表单的发送方式，一般选择post方式发送，如果是get方式密码等信息会显示出来</li><li>input type&#x3D;”text” 表示文本框，其中name属性必须要指定，否则这个文本框的数据将来是不会发送给服务器的</li><li>input type&#x3D;”password” 表示密码框</li><li>input type&#x3D;”radio” 表示单选按钮。需要注意的是，name属性值保持一致，这样才会有互斥的效果;可以通过checked属性设置默认选中的项</li><li>input type&#x3D;”checkbox” 表示复选框。name属性值建议保持一致，这样将来我们服务器端获取值的时候获取的是一个数组</li><li>select 表示下拉列表。每一个选项是option，其中value属性是发送给服务器的值 , selected表示默认选中的项</li><li>textarea 表示多行文本框（或者称之为文本域）,它的value值就是开始结束标签之间的内容</li><li>input type&#x3D;”submit” 表示提交按钮</li><li>input type&#x3D;”reset” 表示重置按钮</li><li>input type&#x3D;”button” 表示普通按钮</li></ul><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><p>css主要用于装饰HTML中的元素，属于特效的范畴，简单了解即可，下面举个含有css的html样例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 内部样式表 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-comment">/* 被style标签包围的范围是CSS环境，可以写CSS代码 */</span></span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-comment">/* 标签样式表 */</span></span><br><span class="language-css"><span class="hljs-selector-tag">p</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-comment">/* 类样式 */</span></span><br><span class="language-css"><span class="hljs-selector-class">.f20</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">font-size</span>:<span class="hljs-number">20px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引用外部的CSS样式表文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/demo01.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">&lt;p&gt;&lt;font color=&quot;red&quot;&gt;这里是段落一&lt;/font&gt;&lt;/p&gt;</span><br><span class="hljs-comment">&lt;p&gt;&lt;font color=&quot;red&quot;&gt;这里是段落二&lt;/font&gt;&lt;/p&gt;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这里是段落一<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这里是段落二<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;f20&quot;</span>&gt;</span>这里是段落三<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p4&quot;</span>&gt;</span>这里是段落四<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!-- id属性在整个HTML文档中，尽量保持唯一（虽然重复也不会报错） --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size:60px;font-weight:bolder;color:yellow;&quot;</span>&gt;</span>HELLO<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size:60px;font-weight:bolder;color:blue;&quot;</span>&gt;</span>WOO<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;f32&quot;</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;f32&quot;</span>&gt;</span>!!!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面是引入的外部css样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* ID样式 */</span><br><span class="hljs-selector-id">#p4</span>&#123;<br><span class="hljs-attribute">background-color</span>:pink;<br><span class="hljs-attribute">font-size</span>:<span class="hljs-number">24px</span>;<br><span class="hljs-attribute">font-weight</span>:bolder;<br><span class="hljs-attribute">font-style</span>:italic;<br><span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;华文彩云&quot;</span>;<br>&#125;<br><span class="hljs-comment">/* 组合样式 */</span><br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br>&#125;<br><br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-class">.f32</span>&#123;<br><span class="hljs-attribute">font-size</span>:<span class="hljs-number">50px</span>;<br><span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;黑体&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>被style标签包围的范围是CSS环境，可以写CSS代码，用来装饰html中的元素，另外可以引入外部的样式表，一般都是引用外部的样式表，便于不同功能的代码分离。</p><p>CSS的最基本的分类: 标签样式表、类样式表、ID样式表</p><p>CSS从位置上的分类：嵌入式样式表、内部样式表、外部样式表</p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>JavaScript是一种弱类型的客户端的脚本语言，变量的数据类型由后面赋的值的类型决定，JavaScript可以给html上的元素绑定各种事件逻辑</p><p>下面是JavaScript基本样例：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hello world&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">alert</span>(<span class="hljs-keyword">typeof</span> str);</span></span><br><span class="language-javascript"><span class="language-xml">str = <span class="hljs-number">9999</span> ;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">alert</span>(<span class="hljs-keyword">typeof</span> str);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 对象</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();</span></span><br><span class="language-javascript"><span class="language-xml">person.<span class="hljs-property">pid</span> = <span class="hljs-string">&quot;p001&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">person.<span class="hljs-property">pname</span>=<span class="hljs-string">&quot;鸠摩智&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">alert</span>(person.<span class="hljs-property">pid</span>+<span class="hljs-string">&quot;_&quot;</span>+person.<span class="hljs-property">pname</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//js 方法</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">num1 , num2 , name</span>)</span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery"><span class="hljs-keyword">if</span>(num1&gt;num2)&#123;</span><br><span class="language-xquery"><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello to&quot;</span> +<span class="hljs-built_in"> name</span> ;</span><br><span class="language-xquery">&#125;</span><span class="language-xml"><span class="language-javascript"><span class="hljs-keyword">else</span></span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery">alert(<span class="hljs-string">&quot;HELLO&quot;</span>);</span><br><span class="language-xquery">&#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>JavaScript一般也通过引入使用，html界面上一般不写JavaScript相关的语句。引入JavaScript脚本后，界面上就会出现一些交互的特效，例如鼠标悬浮显示详情，编辑表格等。</p><p>对于后端开发，其实主要还是关于客户端给服务器发送的实际信息，对于界面编辑、特效相关的应该还是属于前端的工作，了解即可。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1AS4y177xJ/">尚硅谷javaweb教程</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毛泽东选集</title>
    <link href="/2022/12/11/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86/"/>
    <url>/2022/12/11/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《毛泽东选集》 毛泽东 人民出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="做事"><a href="#做事" class="headerlink" title="做事"></a>做事</h2><ul><li>谁是我们的敌人？谁是我们的朋友？这个问题是革命的首要问题。中国过去一切革命斗争成效甚少，其基本原因就是因为不能团结真正的朋友，以攻击真正的敌人。</li><li>许多做领导工作的人，遇到困难问题，只是叹气，不能解决。他恼火，请求调动工作，理由是“才力小，干不下”。这是懦夫讲的话。迈开你的两脚，到你的工作范围的各部分各地方去走走，学个孔夫子的“每事问”，任凭什么才力小也能解决问题，因为你未出门时脑子是空的，归来时脑子已经不是空的了，已经载来了解决问题的各种必要材料，问题就是这样子解决了。一定要出门吗？也不一定，可以召集那些明了情况的人来开个调查会，把你所谓困难问题的“来源”找到手，“现状”弄明白，你的这个困难问题也就容易解决了。 调查就像“十月怀胎”，解决问题就像“一朝分娩”。调查就是解决问题。</li><li>任何一级的首长，应当把自己注意的重心，放在那些对于他所指挥的全局说来最重要最有决定意义的问题或动作上，而不应当放在其他的问题或动作上。</li><li>认识情况的过程，不但存在于军事计划建立之前，而且存在于军事计划建立之后。当执行某一计划时，从开始执行起，到战局终结止，这是又一个认识情况的过程，即实行的过程。此时，第一个过程中的东西是否符合于实况，需要重新加以检查。如果计划和情况不符合，或者不完全符合，就必须依照新的认识，构成新的判断，定下新的决心，把已定计划加以改变，使之适合于新的情况。部分地改变的事差不多每一作战都是有的，全部地改变的事也是间或有的。鲁莽家不知改变，或不愿改变，只是一味盲干，结果又非碰壁不可。</li><li>中国古代大军事学家孙武子书上“知彼知己，百战不殆”这句话，是包括学习和使用两个阶段而说的，包括从认识客观实际中的发展规律，并按照这些规律去决定自己行动克服当前敌人而说的；我们不要看轻这句话。</li><li>但是开始准备的时机问题，一般地说来，与其失之过迟，不如失之过早。因为后者的损失较之前者为小，而其利益，则是有备无患，根本上立于不败之地。</li></ul><h2 id="调查分析"><a href="#调查分析" class="headerlink" title="调查分析"></a>调查分析</h2><ul><li>我们看事情必须要看它的实质，而把它的现象只看作入门的向导，一进了门就要抓住它的实质，这才是可靠的科学的分析方法。</li><li>离开实际调查就要产生唯心的阶级估量和唯心的工作指导，那末，它的结果，不是机会主义，便是盲动主义</li><li>不论做什么事，不懂得那件事的情形，它的性质，它和它以外的事情的关联，就不知道那件事的规律，就不知道如何去做，就不能做好那件事。</li><li>列宁说：马克思主义的最本质的东西，马克思主义的活的灵魂，就在于具体地分析具体的情况。就是说的这个意思。我们的教条主义者违背列宁的指示，从来不用脑筋具体地分析任何事物，做起文章或演说来，总是空洞无物的八股调，在我们党内造成了一种极坏的作风。</li><li>经验对于干部是必需的，失败确是成功之母。但是虚心接受别人的经验也属必需，如果样样要待自己经验，否则固执己见拒不接受，这就是十足的“狭隘经验论”。我们的战争吃这种亏是不少的。</li><li>重复地说，论理的认识所以和感性的认识不同，是因为感性的认识是属于事物之片面的、现象的、外部联系的东西，论理的认识则推进了一大步，到达了事物的全体的、本质的、内部联系的东西，到达了暴露周围世界的内在的矛盾，因而能在周围世界的总体上，在周围世界一切方面的内部联系上去把握周围世界的发展。</li><li>由此看来，认识的过程，第一步，是开始接触外界事情，属于感觉的阶段。第二步，是综合感觉的材料加以整理和改造，属于概念、判断和推理的阶段。只有感觉的材料十分丰富（不是零碎不全）和合于实际（不是错觉），才能根据这样的材料造出正确的概念和论理来。</li></ul><h2 id="发展与矛盾"><a href="#发展与矛盾" class="headerlink" title="发展与矛盾"></a>发展与矛盾</h2><ul><li>由此看来，不论研究何种矛盾的特性——各个物质运动形式的矛盾，各个运动形式在各个发展过程中的矛盾，各个发展过程的矛盾的各方面，各个发展过程在其各个发展阶段上的矛盾以及各个发展阶段上的矛盾的各方面，研究所有这些矛盾的特性，都不能带主观随意性，必须对它们实行具体的分析。离开具体的分析，就不能认识任何矛盾的特性。我们必须时刻记得列宁的话：对于具体的事物作具体的分析。</li><li>由此可知，任何过程如果有多数矛盾存在的话，其中必定有一种是主要的，起着领导的、决定的作用，其他则处于次要和服从的地位。因此，研究任何过程，如果是存在着两个以上矛盾的复杂过程的话，就要用全力找出它的主要矛盾。捉住了这个主要矛盾，一切问题就迎刃而解了。这是马克思研究资本主义社会告诉我们的方法。</li></ul><h2 id="作文"><a href="#作文" class="headerlink" title="作文"></a>作文</h2><ul><li>留心各样的事情，多看看，不看到一点就写。</li><li>写完后至少看两遍，竭力将可有可无的字、句、段删去，毫不可惜。宁可将可作小说的材料缩成速写，决不将速写材料拉成小说。</li><li>孔夫子提倡“再思”，韩愈也说“行成于思”，那是古代的事情。现在的事情，问题很复杂，有些事情甚至想三四回还不够。鲁迅说“至少看两遍”，至多呢？他没有说，我看重要的文章不妨看它十多遍，认真地加以删改，然后发表。文章是客观事物的反映，而事物是曲折复杂的，必须反复研究，才能反映恰当；在这里粗心大意，就是不懂得做文章的起码知识。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>书籍的年代感较强，大部分为抗日战争和国共内战时期的作品，涉及到政策分析、辩论、口号之类的东西对于当代个人而言参考意义不大，毕竟各方都有各方的说辞，不过对于战争分析、调研实践相关的论述非常精彩。战争分析基本准确预估了整个抗日战争和国共战争的走势，指导了战争战略制定，战术理论分析也十分深刻；关于调研实践相关的论述对于个人而言十分有用，应当铭记于心。关于毛选第五卷也从一些渠道获取翻阅了下，确实是不太经得过时间的考验，官方后续没有放出也无可厚非，对于个人的启发意义一般。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Window中搭建centos虚拟机和MySQL</title>
    <link href="/2022/11/27/Window%E4%B8%AD%E6%90%AD%E5%BB%BAcentos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8CMySQL/"/>
    <url>/2022/11/27/Window%E4%B8%AD%E6%90%AD%E5%BB%BAcentos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8CMySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前一段时间，博主为了在家里搭建学习环境，想模拟一个生产环境，尝试了Windows安装WSL、Vmware workstation player 安装Ubuntu、把Window删了直接装Ubuntu、把Ubuntu删了装回Windows(Windows一直无法安装到SSD，最后拆了电脑拔了机械硬盘才装成功)的多个阶段，发现还是Windows用的习惯，曾经还想过有朝一日试试高贵的Macbook，如今兴趣也是减了大半了。话归主题，最后博主决定还是使用Windows基于Vmware workstation player安装centos和其他相关组件。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="VMware-Workstation-16-Player"><a href="#VMware-Workstation-16-Player" class="headerlink" title="VMware Workstation 16 Player"></a>VMware Workstation 16 Player</h2><p>VMware Workstation 16 Player个人使用免费，直接百度搜索官网下载安装，注意软件的安装位置和虚拟机文件的位置选择，其他默认即可。</p><h2 id="centOS镜像"><a href="#centOS镜像" class="headerlink" title="centOS镜像"></a>centOS镜像</h2><p>博主前往<a href="%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E9%95%9C%E5%83%8F%E7%AB%99">https://mirrors.tuna.tsinghua.edu.cn</a>下载的centos7镜像，具体路径是<code>/centos/7/isos/x86_64/</code>，具体镜像名为<strong>CentOS-7-x86_64-DVD-2009.iso</strong></p><h1 id="虚拟机创建"><a href="#虚拟机创建" class="headerlink" title="虚拟机创建"></a>虚拟机创建</h1><p>打开Vmware workstation player，点击<strong>创建新虚拟机</strong>，选择刚才下载下来的镜像，点击下一步</p><p><img src="/2022/11/27/Window%E4%B8%AD%E6%90%AD%E5%BB%BAcentos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8CMySQL/%E9%80%89%E6%8B%A9centos%E9%95%9C%E5%83%8F.png" alt="选择centos镜像"></p><p>填写全名（主机名称）、用户名、密码，本步骤用于Vmware workstation player自动安装centos，点击下一步</p><p>填写Vmware workstation player上显示的虚拟机名称和虚拟机文件的存放位置，点击下一步</p><p>配置磁盘大小，博主设置为了60GB，其他配置默认，点击下一步</p><p>选择<strong>自定义组件</strong>，博主将<strong>虚拟机的内存</strong>设置为了6GB，<strong>处理器内核数量</strong>设置为了8，网络选择了<strong>桥接模式</strong>，其他配置默认，点击关闭，然后点击<strong>完成</strong>，然后后续Vmware workstation player会全自动安装centOS，比使用公司的魔改centos镜像安装还要顺滑~</p><p><a href="https://blog.csdn.net/qq_27088383/article/details/108634985">NAT模式和桥接模式的区别详解</a>中介绍了桥接模式的基本原理</p><h1 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h1><p>因为网络选择的是桥接模式，所以虚拟机会有一个独立的ip，Vmware workstation player已经自动为我们配置好了系统的网卡，直接执行<code>ifconfig</code>可以看到虚拟机的ip信息，但是外部还无法基于ssh连接虚拟机，需要开放ssh的端口。</p><p>修改ssh配置，<code>vim /etc/ssh/sshd_config</code>，将<code>Port 22</code>注释解开,重启sshd<code>sudo service sshd restart</code>，然后使用MabaXterm尝试连接虚拟机即可。</p><p>为了方便后续mysql图形化客户端连接，把防火墙也一并关掉<code>systemctl stop firewalld.service</code>，然后永久关闭防火墙<code>systemctl disable firewalld.service</code></p><h1 id="mysql安装"><a href="#mysql安装" class="headerlink" title="mysql安装"></a>mysql安装</h1><ul><li>安装mysql源</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 下载安装包</span><br>wget https:<span class="hljs-regexp">//</span>dev.mysql.com<span class="hljs-regexp">/get/my</span>sql80-community-release-el7-<span class="hljs-number">3</span>.noarch.rpm<br><span class="hljs-comment"># 安装</span><br>rpm -vih mysql80-community-release-el7-<span class="hljs-number">3</span>.noarch.rpm<br><span class="hljs-comment"># 确认是否安装成功</span><br>yum repolist enabled | grep <span class="hljs-string">&quot;mysql.*-community.*&quot;</span><br></code></pre></td></tr></table></figure><ul><li>修改版本</li></ul><p>以上安装版本一般会安装最新稳定版，但是我们一般用5.6版本，所以需要调整版本</p><p><code>yum repolist all | grep mysql</code>可以展示哪些源被禁用或者启动</p><p>执行<code>yum-config-manager --disable mysql80-community</code>禁用8.0版本，执行<code>yum-config-manager --enable mysql56-community</code>启用5.6版本</p><ul><li>安装Mysql</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">yum install mysql-community-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><ul><li>启动Mysql</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service mysqld <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><p>启动说明里有提示如何修改密码，参照说明进行密码修改可以</p><p><img src="/2022/11/27/Window%E4%B8%AD%E6%90%AD%E5%BB%BAcentos%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8CMySQL/mysql%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE.png" alt="MySQL密码重置"></p><ul><li>MySQL其他命令</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service mysqld <span class="hljs-literal">stop</span>　　　　　　　　<span class="hljs-comment">#关闭MySQL服务</span><br>service mysqld restart　　　　　　<span class="hljs-comment">#重启MySQL服务 </span><br>service mysqld status　　　　　　<span class="hljs-comment">#查看服务状态</span><br></code></pre></td></tr></table></figure><ul><li>登录与简单信息查看</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">mysql -uroot -pve<span class="hljs-meta">#LoVkeU2u!</span><br><span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure><ul><li>图形化MySQL客户端工具连接MySQL报错</li></ul><p>博主使用MySQL Workbench来连接MySQL，端口默认。连接MySQL报错<strong>Host ‘xxx’ is not allowed to connect to this MySQL server</strong>，通过<a href="https://www.cnblogs.com/codecat/p/10729033.html%E5%92%8Chttps://blog.csdn.net/qq_38331606/article/details/79535489%E8%A7%A3%E5%86%B3">https://www.cnblogs.com/codecat/p/10729033.html和https://blog.csdn.net/qq_38331606/article/details/79535489解决</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_27088383/article/details/108634985">NAT模式和桥接模式的区别详解</a><br><a href="https://blog.csdn.net/u013766416/article/details/121351256">在Windows上使用 VMware 16 Player 创建新虚拟机</a><br><a href="https://www.cnblogs.com/hailexuexi/p/15124213.html">Centos7 怎么永久关闭防火墙</a><br><a href="https://www.cnblogs.com/xsge/p/13827288.html">Linux系统发行版ContOS7演示安装MySQL</a><br><a href="https://www.cnblogs.com/codecat/p/10729033.html">解决MySql报错：1130 - Host ‘xxx’ is not allowed to connect to this MySQL server的方法</a><br><a href="https://blog.csdn.net/qq_38331606/article/details/79535489">Duplicate entry ‘%-root’ for key ‘PRIMARY’</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown拾遗</title>
    <link href="/2022/11/24/Markdown%E6%8B%BE%E9%81%97/"/>
    <url>/2022/11/24/Markdown%E6%8B%BE%E9%81%97/</url>
    
    <content type="html"><![CDATA[<h1 id="语法记录"><a href="#语法记录" class="headerlink" title="语法记录"></a>语法记录</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>为了兼容考虑，请在井号和标题文本之间添加一个空格</p><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>在一行的末尾添加两个或多个空格，然后按回车键，即可创建一个换行<br>例如本行是一个新行</p><p>这是一个新段落</p><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p>在单词或短语的前后各添加 <strong>两个星号</strong></p><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p>在单词或短语前后添加 <em>一个星号</em></p><h2 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h2><p>在要突出显示的部分前后各添加 <em><strong>三个星号</strong></em></p><h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><p>请在段落前添加一个 &gt; 符号</p><blockquote><p>块引用</p></blockquote><p>块引用可以包含多个段落。为段落之间的空白行各添加一个 &gt; 符号。</p><blockquote><p>块引用1</p><p>块引用2</p></blockquote><p>带有其它元素的块引用</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">#### <span class="hljs-title class_">The</span> quarterly results look great!</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">- <span class="hljs-title class_">Revenue</span> was off the chart.</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">- <span class="hljs-title class_">Profits</span> were higher than ever.</span><br><span class="hljs-meta prompt_">&gt;</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"> *<span class="hljs-title class_">Everything</span>* is going according to **plan**.</span><br></code></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>不要在同一个列表中混用不同的分隔符</p><p>缩进一个或多个列表项可创建嵌套列表</p><ul><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ul><p>如果你需要以数字开头并且紧跟一个英文句号（也就是 .）的无序列表项，则可以使使用反斜线（\）来 转义 这个英文句号。</p><ul><li>1968. A great year!</li><li>I think 1969 was second best.</li></ul><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格，例如</p><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><p>  I need to add another paragraph below the second list item.</p></li><li><p>And here’s the third list item.</p></li></ul><p>或者</p><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><blockquote><p>A blockquote would look great below the second list item.</p></blockquote></li><li><p>And here’s the third list item.</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>要将单词或短语表示为代码，请将其包裹在反引号 (&#96;) 中</p><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(&#96;&#96;)中。</p><h2 id="围栏代码块"><a href="#围栏代码块" class="headerlink" title="围栏代码块"></a>围栏代码块</h2><p>代码块的前后可以使用三个反引号（&#96;&#96;&#96;）。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>要创建链接，请将链接文本括在方括号（例如 [Duck Duck Go]）中，后面紧跟着括在圆括号中的 URL（例如 (<a href="https://duckduckgo.com/">https://duckduckgo.com</a>) ）。</p><pre><code class="hljs">My favorite search engine is [Duck Duck Go](https://duckduckgo.com).</code></pre><h2 id="网址和电子邮件地址"><a href="#网址和电子邮件地址" class="headerlink" title="网址和电子邮件地址"></a>网址和电子邮件地址</h2><p>要将 URL 或电子邮件地址快速转换为链接，请将其括在尖括号中。</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>感叹号中括号（描述）小括号（位置）</p><pre><code class="hljs">![Tux, the Linux mascot](/assets/images/tux.png)</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>请使用三个或更多个连字符（—）来为每个列创建表头，并使用管道符（|）来分隔每个列。</p><pre><code class="hljs">| Syntax      | Description || ----------- | ----------- || Header      | Title       || Paragraph   | Text        |</code></pre><p>通过在标题行中的连字符（hyphens）的左侧或右侧或两侧添加冒号（:），可以将对应列中的文本向左或向右或居中对齐。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Syntax      </span>|<span class="hljs-string"> Description </span>|<span class="hljs-string"> Test Text     </span>|<br>|<span class="hljs-string"> :---        </span>|<span class="hljs-string">    :----:   </span>|<span class="hljs-string">          ---: </span>|<br>|<span class="hljs-string"> Header      </span>|<span class="hljs-string"> Title       </span>|<span class="hljs-string"> Here&#x27;s this   </span>|<br>|<span class="hljs-string"> Paragraph   </span>|<span class="hljs-string"> Text        </span>|<span class="hljs-string"> And more      </span>|<br></code></pre></td></tr></table></figure><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>[x] Write the press release<br><span class="hljs-bullet">- </span>[ ] Update the website<br><span class="hljs-bullet">- </span>[ ] Contact the media<br></code></pre></td></tr></table></figure><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><pre><code class="hljs">I need to highlight these &lt;mark&gt;very important words&lt;/mark&gt;.或者==高亮==</code></pre><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>下标</p><pre><code class="hljs">H~2~O</code></pre><p>上标</p><pre><code class="hljs">X^2^</code></pre><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><pre><code class="hljs">Here&#39;s a sentence with a footnote. &lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--rounded&quot; aria-label=&quot;This is the footnote.&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.markdown.xyz/"> Markdown 指南中文版 </a><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>This is the footnote.<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql必知必会</title>
    <link href="/2022/11/23/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <url>/2022/11/23/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《MySQL必知必会》 福塔 人民邮电出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><blockquote><p>保存有组织的数据的容器（通常是一个文件或一组文件）。</p></blockquote><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><blockquote><p>某种特定类型数据的结构化清单。</p></blockquote><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><blockquote><p>关于数据库和表的布局及特性的信息。有时，模式用作数据库的同义词。</p></blockquote><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><blockquote><p>一列或一组列，其值可以唯一区分表中的每一行。应该总是定义主键。</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>使用mysql命令行连接或者图形化客户端连接，本人使用MySqlWorkbench图形化客户端。</p><h3 id="选择库"><a href="#选择库" class="headerlink" title="选择库"></a>选择库</h3><p>在mysql命令行中通过<code>use xx</code>选择数据库，在MySqlWorkbench中通过双击库来选择数据库</p><h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price <span class="hljs-keyword">FROM</span> products;<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> products;<br><span class="hljs-comment">-- 检索不同行</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> vend_id <span class="hljs-keyword">FROM</span> products;<br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">5</span>;<br><span class="hljs-comment">-- 从行5开始最多展示5行，MySql的行从0开始计数</span><br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">5</span>, <span class="hljs-number">5</span>;<br><span class="hljs-comment">-- 全限定表明</span><br><span class="hljs-keyword">SELECT</span> products.prod_name <span class="hljs-keyword">FROM</span> crashcourse.products;<br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 只对prod_price倒序</span><br><span class="hljs-keyword">SELECT</span> prod_id, prod_price, prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_price <span class="hljs-keyword">DESC</span>, prod_name;<br><span class="hljs-comment">-- 最贵商品</span><br><span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_price <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> prod_name, prod_price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_price = <span class="hljs-number">2.</span> <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>WHERE 子句操作符 BETWEEN AND 在指定两个值之间（包含）</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>组合过滤，不要依赖默认计算次序，多用括号</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> prod_name, prod_price FROM products WHERE (vend_id = <span class="hljs-number">1002</span> OR vend_id = <span class="hljs-number">1003</span>) AND prod_price &gt;= <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>IN一般比OR执行更快</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> prod_name, prod_price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">1002</span>, <span class="hljs-number">1003</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br></code></pre></td></tr></table></figure><p>MySQL支持使用NOT对IN、BETWEEN和EXISTS子句取反</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> prod_name, prod_price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">1002</span>, <span class="hljs-number">1003</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br></code></pre></td></tr></table></figure><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p>通配符LIKE</p><p>正则表达式REGEXP</p><h3 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> Concat( RTrim( vend_name), <span class="hljs-string">&#x27; (&#x27;</span>, RTrim( vend_country), <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">AS</span> vend_title <span class="hljs-keyword">FROM</span> vendors <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> vend_name;<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> prod_id, quantity, item_price, quantity* item_price <span class="hljs-keyword">AS</span> expanded_price <span class="hljs-keyword">FROM</span> orderitems <span class="hljs-keyword">WHERE</span> order_num = <span class="hljs-number">20005</span>;<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>聚集函数</p><p>AVG()\COUNT()\MAX()\MIN()\SUM()</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>( prod_price) <span class="hljs-keyword">AS</span> avg_price <span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p>使用COUNT(*)对表中行的数目进行计数, 使用COUNT(column) 对特定列中具有值的行进行计数，忽略NULL值。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>( item_price*quantity) <span class="hljs-keyword">AS</span> total_price <span class="hljs-keyword">FROM</span> orderitems <span class="hljs-keyword">WHERE</span> order_num = <span class="hljs-number">20005</span>;<br></code></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</p><p>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p><p>WHERE在数据分组前进行过滤， HAVING在数据分组后进行过滤。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> vend_id, <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">AS</span> num_prods <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> vend_id;<br></code></pre></td></tr></table></figure><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">SELECT</span> vend_id, COUNT<span class="hljs-comment">(*) AS num_prods FROM products WHERE prod_price &gt;= 10 GROUP BY vend_id HAVING COUNT(*)</span> &gt;= <span class="hljs-number">2</span><span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><h3 id="查询子句顺序"><a href="#查询子句顺序" class="headerlink" title="查询子句顺序"></a>查询子句顺序</h3><p>SELECT | FROM | WHERE | GROUP BY | HAVING | ORDER BY | LIMIT</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> cust_id <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> order_num <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> order_num <span class="hljs-keyword">FROM</span> orderitems <span class="hljs-keyword">WHERE</span> prod_id = <span class="hljs-string">&#x27;TNT2&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h3><h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><blockquote><p>外键为某个表中的一列，它包含另一个表的主键，定义了两个表之间的关系</p></blockquote><p>存在一个商品表和一个供应商信息表，供应商ID是供应商信息表的主键，这个供应商ID是商品表的&#x3D;&#x3D;外键&#x3D;&#x3D;，它将商品表和供应商信息表关联。</p><h4 id="联结样例"><a href="#联结样例" class="headerlink" title="联结样例"></a>联结样例</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> vend_name, prod_name, prod_price <span class="hljs-keyword">FROM</span> vendors <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> products <span class="hljs-keyword">ON</span> vendors.vend_id = products.vend_id;<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> customers.cust_id, orders.order_num <span class="hljs-keyword">FROM</span> customers <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> orders <span class="hljs-keyword">ON</span> orders.cust_id = customers.cust_id;<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> customers.cust_name, customers.cust_id, <span class="hljs-built_in">COUNT</span>( orders.order_num) <span class="hljs-keyword">AS</span> num_ord <span class="hljs-keyword">FROM</span> customers <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> orders <span class="hljs-keyword">ON</span> customers. cust_id = orders. cust_id <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> customers.cust_id;<br></code></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> vend_id, prod_id, prod_price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_price &lt;= <span class="hljs-number">5</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">SELECT</span> vend_id, prod_id, prod_price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">1001</span>, <span class="hljs-number">1002</span>);<br></code></pre></td></tr></table></figure><p>如果使用UNION不想去重，应该使用UNION ALL</p><p>在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers( cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27; Pep E. LaPew&#x27;</span>, <span class="hljs-string">&#x27;100 Main Street&#x27;</span>, <span class="hljs-string">&#x27;Los Angeles&#x27;</span>, <span class="hljs-string">&#x27;CA&#x27;</span>, <span class="hljs-string">&#x27;90046&#x27;</span>, <span class="hljs-string">&#x27;USA&#x27;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers( cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country) <span class="hljs-keyword">VALUES</span>( <span class="hljs-string">&#x27;Pep E. LaPew&#x27;</span>, <span class="hljs-string">&#x27;100 Main Street&#x27;</span>, <span class="hljs-string">&#x27;Los Angeles&#x27;</span>, <span class="hljs-string">&#x27;CA&#x27;</span>, <span class="hljs-string">&#x27;90046&#x27;</span>, <span class="hljs-string">&#x27;USA&#x27;</span> ), ( <span class="hljs-string">&#x27;M. Martian&#x27;</span>, <span class="hljs-string">&#x27;42 Galaxy Way&#x27;</span>, <span class="hljs-string">&#x27;New York&#x27;</span>, <span class="hljs-string">&#x27;NY&#x27;</span>, <span class="hljs-string">&#x27;11213&#x27;</span>, <span class="hljs-string">&#x27;USA&#x27;</span> );<br></code></pre></td></tr></table></figure><h2 id="更新和删除"><a href="#更新和删除" class="headerlink" title="更新和删除"></a>更新和删除</h2><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">UPDATE</span> customers <span class="hljs-keyword">SET</span> cust_email = <span class="hljs-string">&#x27;elmer@ fudd. com&#x27;</span> <span class="hljs-keyword">WHERE</span> cust_id = <span class="hljs-number">10005</span>;<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">UPDATE</span> customers <span class="hljs-keyword">SET</span> cust_email = <span class="hljs-literal">NULL</span> <span class="hljs-keyword">WHERE</span> cust_id = <span class="hljs-number">10005</span>;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> customers <span class="hljs-keyword">WHERE</span> cust_id &gt;= <span class="hljs-number">10010</span>;<br></code></pre></td></tr></table></figure><p>全表删除使用<code>TRUNCATE TABLE</code>更快</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用UPDATE和DELETE使用WHERE之前，先用SELECT进行测试，MySQL没有撤销功能。</p><h2 id="表-1"><a href="#表-1" class="headerlink" title="表"></a>表</h2><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> customers ( cust_id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, cust_name <span class="hljs-type">char</span>( <span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , cust_address <span class="hljs-type">char</span>( <span class="hljs-number">50</span>) , cust_city <span class="hljs-type">char</span>( <span class="hljs-number">50</span>) , cust_state <span class="hljs-type">char</span>( <span class="hljs-number">5</span>) , cust_zip <span class="hljs-type">char</span>( <span class="hljs-number">10</span>) , cust_country <span class="hljs-type">char</span>( <span class="hljs-number">50</span>) , cust_contact <span class="hljs-type">char</span>( <span class="hljs-number">50</span>) , cust_email <span class="hljs-type">char</span>( <span class="hljs-number">255</span>) , <span class="hljs-keyword">PRIMARY KEY</span> (cust_id) ) ENGINE= InnoDB;<br></code></pre></td></tr></table></figure><h4 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h4><p>MySQL数据类型：字符串、数值、日期、二进制，具体再查询</p><h4 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orderitems ( order_num <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , order_item <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , prod_id <span class="hljs-type">char</span>( <span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , quantity <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , item_price <span class="hljs-type">decimal</span>( <span class="hljs-number">8</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , <span class="hljs-keyword">PRIMARY</span> KEY (order_num, order_item) ) ENGINE<span class="hljs-operator">=</span> InnoDB;<br></code></pre></td></tr></table></figure><h4 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h4><p>每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。</p><h4 id="常用引擎"><a href="#常用引擎" class="headerlink" title="常用引擎"></a>常用引擎</h4><p>InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索；<br>MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；<br>MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。</p><h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> vendors <span class="hljs-keyword">ADD</span> vend_phone <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> customers2;<br></code></pre></td></tr></table></figure><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TABLE</span> customers2 <span class="hljs-keyword">TO</span> customers;<br></code></pre></td></tr></table></figure><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图可以看成虚拟表，仅仅是用来查看存储在别处的数据的一种设施，视图本身不包含数据，它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> orderitemsexpanded <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> order_num, prod_id, quantity, item_price, quantity* item_price <span class="hljs-keyword">AS</span> expanded_price <span class="hljs-keyword">FROM</span> orderitems;<br></code></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务处理（transactionprocessing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p><p>事务（transaction）指一组SQL语句；<br>回退（rollback）指撤销指定SQL语句的过程；<br>提交（commit）指将未存储的SQL语句结果写入数据库表；<br>保留点（savepoint）指事务处理中设置的临时占位符（place-holder），你可以对它发布回退（与回退整个事务处理不同）</p><h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> ordertotals; <br><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>; <br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> ordertotals; <br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> ordertotals; <br><span class="hljs-keyword">ROLLBACK</span>; <br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> ordertotals;<br></code></pre></td></tr></table></figure><p>INSERT、UPDATE和DELETE可以回退，CREATE或DROP不能回退</p><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>; <br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> orderitems <span class="hljs-keyword">WHERE</span> order_ num = <span class="hljs-number">20010</span>; <br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> order_ num = <span class="hljs-number">20010</span>; <br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><p>当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。</p><h3 id="保留点"><a href="#保留点" class="headerlink" title="保留点"></a>保留点</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SAVEPOINT</span> delete1;<br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> delete1;<br></code></pre></td></tr></table></figure><p>保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>MySQL入门书籍，整理用于后续简单查阅。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统原理</title>
    <link href="/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <url>/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《操作系统原理(第4版)》 庞丽萍 华中科技大学出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="存储程序式计算机"><a href="#存储程序式计算机" class="headerlink" title="存储程序式计算机"></a>存储程序式计算机</h3><ul><li>冯·诺依曼计算机体系结构<br><img src="/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/1.jpg"><br>从20世纪40年代至今，计算机体系结构不断地发展变化，但冯·诺依曼计算机体系结构定义的一个存储程序式计算机的家族，几乎是当代所有计算机系统的构成基础（除专门设计用于处理特殊任务的计算机外）。存储程序式计算机由中央处理器（处理器（CPU））、存储器和输入／输出设备组成。所有的单元都通过总线连接，总线分为地址总线和数据总线，分别连接不同的部件。<br>由于冯·诺依曼型计算机的计算模型是顺序过程计算模型，所以它的特点是集中顺序过程，在当代的CPU中，可有32～64个通用寄存器，每个寄存器能够保存一个32位（bit）的数值。通用寄存器可以为功能单元提供操作数，并能接收、保存操作的结果。控制单元负责从主存储器提取指令、分析其类型，并产生信号通知计算机其他部分执行指令所指定的操作。控制单元包含一个程序计数器（programcounter，PC）和一个指令寄存器（instructionregister，IR）。程序计数器指示下一步应该执行的指令，而指令寄存器包含当前指令的拷贝。</li></ul><h3 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h3><p>操作系统是构成计算机系统的另一个重要的系统软件，它负责管理计算机系统的硬件、软件资源并控制整个计算机的工作流程。</p><ul><li><p>发展历程<br>从1950年至今，操作系统的发展主要经历了如下的几个阶段：①手工操作阶段——无操作系统；②批处理系统——早期批处理、执行系统；③操作系统形成——批处理操作系统、分时操作系统、实时操作系统；④现代操作系统——个人计算机操作系统、网络操作系统、分布式操作系统。</p></li><li><p>中断和通道<br>20世纪60年代初期，硬件获得了两方面的进展：一是通道的引入；二是中断技术的出现。这两项重大成果导致操作系统进入执行系统阶段。通道是一种专用处理部件，它能控制一台或多台外设的工作，负责外部设备与主存之间的信息传输。它一旦被启动，就能独立于CPU运行，这样就可使CPU和通道并行操作，而且CPU和各种外部设备也能并行操作。所谓中断是指当主机接到某种信号信号（如I&#x2F;O设备完成信号）时，马上停止原来的工作，转去处理这一事件，当事件处理完毕，主机又回到原来的工作点继续工作。</p></li><li><p>多道程序<br>中断和通道技术出现以后，I&#x2F;O设备和中央处理机可以并行操作，初步解决了高速处理机和低速外部设备的矛盾，提高了计算机的工作效率。但不久又发现，这种并行是有限度的，并不能完全消除中央处理机对外部传输的等待。比如，一个作业在运行过程中依此输入n批数据，每批输入1000个字符，输入机每输入1000个字符需用1000ms，而处理机处理这些数据则需300ms。可见，尽管处理机具有和外部设备并行工作的能力，但是在这种情况下无法让它多做工作，处理机仍有空闲等待现象。那么，为了提高设备的利用率，能否在系统内同时存放几道程序呢？这就引入了多道程序的概念。<br>多道程序运行的特征是：①多道——计算机主存中同时存放几道相互独立的程序；②宏观上并行——同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕；③微观上串行——从微观上看，主存中的多道程序轮流或分时地占有处理机，交替执行。</p></li><li><p>分时技术<br>当计算机技术和软件技术发展到20世纪60年代中期，由于主机速度不断提高而采用了分时技术，使一台计算机可同时为多个终端用户服务。每个终端用户在自己的终端设备上联机使用计算机，好像自己独占机器一样。</p></li></ul><h3 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h3><ul><li><p>计算机系统的组成<br><img src="/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/2.jpg"><br>操作系统是一个大型的程序系统，它负责计算机系统软、硬件资源的分配和管理；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境。<br>操作系统是重要的系统软件，只有配置了操作系统这一系统软件后，才使计算机系统体现出系统的完整性和可利用性。当用户要计算机帮助完成其计算任务时，用户仅编制源程序（用户在源程序中，可以利用操作系统提供的系统调用请求操作系统相应的服务），而其余的大量工作，如作业控制、系统资源的合理分配和利用，各种调度策略的制订、人机联系方式等都是由操作系统实施的。所以，操作系统使整个计算机系统实现了高度自动化、高效率、高利用率、高可靠性。操作系统是整个计算机系统的核心。</p></li><li><p>操作系统的资源管理功能<br>操作系统的主要功能是管理系统的软、硬件资源。这些资源按其性质来分，可以归纳为四类：处理机、存储器、外部设备和软件资源。这四类资源就构成了系统程序和用户程序赖以活动的物质基础和工作环境。针对这四类资源，操作系统就有相应的资源管理程序：处理机管理、存储管理、设备管理和软件资源管理程序。这些资源管理程序组成了操作系统这一程序系统。</p></li><li><p>操作系统的基本类型<br>（1）批量操作系统；（2）分时操作系统；（3）实时操作系统；（4）个人计算机操作系统；（5）网络操作系统；（6）分布式操作系统。</p></li></ul><h2 id="操作系统的组织结构"><a href="#操作系统的组织结构" class="headerlink" title="操作系统的组织结构"></a>操作系统的组织结构</h2><h3 id="操作系统虚拟机"><a href="#操作系统虚拟机" class="headerlink" title="操作系统虚拟机"></a>操作系统虚拟机</h3><p>在裸机上配置了操作系统程序后就构成了操作系统虚拟机。操作系统的核心在裸机上运行，而用户程序则在扩充后的机器上运行。扩充后的虚拟机不仅可以使用原来裸机提供的各种基本硬件指令，而且还可使用操作系统中所增加的许多其他“指令”。这些指令统称为扩充机器的指令系统，又称为操作命令语言。<br>  <img src="/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/3.jpg"><br>操作系统虚拟机提供了协助用户解决问题的装置，其功能是通过它提供的命令来体现的，用户也是通过这一组命令和操作系统虚拟机打交道的。系统所提供的全部操作命令的集合称为操作命令语言，它是用户和系统进行通信的手段和界面。这一用户界面分为两个方面：操作命令（又称命令接口）和系统功能调用（又称程序接口）。<br>操作系统在计算机系统中所处的位置是硬件层（裸机）和其他所有软件之间，是所有软件中与硬件相连的第一层软件，它在裸机上运行，又是系统<br>软件和应用程序运行的基础。它与硬件、应用程序和用户都有接口。具有一体化结构的操作系统提供的接口如下图所示，从该结构中可以看出操作系统提供的多种接口。<br>  <img src="/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/4.jpg" alt="loading-ag-517"></p><h3 id="处理机的状态"><a href="#处理机的状态" class="headerlink" title="处理机的状态"></a>处理机的状态</h3><p>操作系统是计算机系统中最重要的系统软件，为了能正确地进行管理和控制，其本身是不能被破坏的。为此，系统应能建立一个保护环境，采用的办法是区分处理机的工作状态。因为，在系统中有两类程序在运行，一类是管理程序（如处理机调度程序、主存分配程序、I&#x2F;O管理程序等）；另一类是用户程序。这两类程序是不同的，前者是管理和控制者，它负责管理和分配系统资源，为用户提供服务。而用户程序运行时，所需资源必须向操作系统提出请求，自己不能随意取用系统资源，如直接启动外部设备进行工作，更不能改变机器状态等。这两类不同程序执行时应有不同的权限，为此根据对资源和机器指令的使用权限，将处理执行时的工作状态区分为不同的状态（或称为模式）。所谓处理机的态，就是处理机当前处于何种状态，正在执行哪类程序。为了保护操作系统，至少需要区分两种状态：管态和用户态。管态（supervisormode）：又称为系统态，是操作系统的管理程序执行时机器所处的状态。在此状态下允许中央处理机使用全部系统资源和全部指令，其中包括一组特权指令（例如，涉及外部设备的输入／输出指令、改变机器状态或修改存储保护的某些指令），允许访问整个存储区。用户态（usermode）：又称为目态，是用户程序执行时机器所处的状态。在此状态下禁止使用特权指令，不能直接取用系统资源与改变机器状态，并且只允许用户程序访问自己的存储区域。有的系统将管理程序执行时的机器状态进一步分为核态和管态，这时，管态的权限有所变化，管态只允许使用一些在用户态下所不能使用的资源，但不能使用修改机器的状态指令。而核态（kernelmode）就具有上述管态所具有的所有权限。无核态的系统，管态执行核态的全部功能。管态比核态权限要低，用户态的权限更低。为了区分处理机的工作状态，需要硬件的支持。在计算机状态寄存器中需设置一个系统状态位（或称模式位）。若有了系统状态位，就可以区分当前正在执行的是系统程序还是用户程序。<strong>若用户程序执行时，超出了它的权限，如要访问操作系统核心数据或企图执行一个特权指令，都将从用户态转为管态，由操作系统得到CPU控制权，处理这一非法操作。这样可以有效地保护操作系统不受破坏。当用户程序执行时，若需要请求操作系统服务，则要通过一种受控方式进入操作系统，将用户态转为核态，由操作系统得到控制权，在核态下执行其相应的服务例程，服务完毕后，返回到用户态，让用户继续执行。</strong></p><h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><p>所谓中断是指某个事件（例如电源掉电、定点加法溢出或I&#x2F;O传输结束等）发生时，系统中止现行程序的运行、引出处理该事件程序进行处理，处理完毕后返回断点，继续执行。<br>  <img src="/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/5.jpg"><br>中断响应的实质是交换指令执行地址和处理器状态，以达到如下目的：①保留程序断点及有关信息；②自动转入相应的中断处理程序执行。中断响应所需的硬件支持包括：指令计数器、处理器状态寄存器、中断向量表和系统堆栈。<br>整个中断处理的功能是由硬件和软件配合完成的。硬件负责中断进入过程，即发现和响应中断请求，把中断的原因和断点记下来供软件处理时查用，同时负责引出中断处理程序。而中断分析、中断处理、恢复被中断程序的现场等工作则由软件的中断处理程序来完成。<br>java里数组越界的一场应该算一种中断。</p><h3 id="UNIX系统结构"><a href="#UNIX系统结构" class="headerlink" title="UNIX系统结构"></a>UNIX系统结构</h3><p>UNIX系统核心层的功能包括文件管理、设备管理、存储管理和处理机管理，此外还有中断和俘获的处理。<strong>现代计算机系统的硬件机构支持核心态和用户态，使得核心程序在核心态下运行，实用程序在用户态下运行。每一种状态都有自己的栈和栈指针，都有自己的地址映射部件。所以，用户态的程序不能直接访问核心态的程序和数据，只能通过访问管理程序指令（访管指令，如trap指令）自陷到核心内的操作系统服务程序。<br>UNIX系统的核心结构是一体化结构。</strong><br><img src="/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/6.jpg" alt="loading-ag-518"></p><h3 id="静态连接和动态链接"><a href="#静态连接和动态链接" class="headerlink" title="静态连接和动态链接"></a>静态连接和动态链接</h3><p>连接这一处理步骤，以前通常采用静态连接方式。静态连接是将所需的外部调用函数连接到目标文件中形成一个完整的主存映像文件。采用这种静态连接的缺点是，当有多个应用程序都需要调用同一个库函数时，那么，这些应用程序的目标文件中都将包含这个外部函数对应的代码。这将造成主存的极大浪费，不能支持有效的共享。动态链接是将这一连接工作延迟到程序运行的时候进行。它需要的支持是动态链接库（DLL）。动态链接不需要将应用程序所需要的外部函数代码从库中提取出来并连接到目标文件中，而是在应用程序需要调用外部函数的地方作记录，并说明要使用的外部函数名和引用入口号，形成调用链表。当所需的动态链接库DLL在主存时，就可以确定所需函数的主存绝对地址，并将它填入调用链表相应位置中。当应用程序运行时，就可以正确地引用这个外部函数了。现代操作系统有的已采用了动态链接技术，如Windows系统，现在的动态链接库一般是系统库。</p><h3 id="操作系统提供的用户界面"><a href="#操作系统提供的用户界面" class="headerlink" title="操作系统提供的用户界面"></a>操作系统提供的用户界面</h3><p>操作系统提供的用户界面如下图所示：一是操作界面，又称为操作命令；二是程序界面，又称为系统功能调用。<br><img src="/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/7.jpg" alt="loading-ag-519"></p><h3 id="系统功能调用"><a href="#系统功能调用" class="headerlink" title="系统功能调用"></a>系统功能调用</h3><p>为了实现在程序级的服务支持，操作系统提供统一的系统功能调用，采用统一的调用方式——访问管理程序来实现对这些功能的调用。<br><strong>对于用户所需要的功能，由系统设计者事先编制好能实现这些功能的例行子程序，作为操作系统程序模块的一部分。这些例行子程序不能像一般的用户子程序那样可随便调用，因为这些能实现各种功能的例行子程序是操作系统的程序部分，它运行时，机器处于管态（管理程序状态），而用户程序运行时，机器处于用户态。所以，用户程序对这些例行子程序的调用应以一种特殊的调用方式——访管方式来实现。</strong><br>这样一个带有一定功能号的访管指令定义了一个系统调用。因此，系统调用是用户在程序一级请求操作系统服务的一种手段，它不是一条简单的硬指令，而是带有一定功能号的访管指令。它的功能并非由硬件直接提供，而是由操作系统中的一段程序完成的，即由软件方法实现的。用户可以用带有不同功能号的访管指令来请求各种不同的功能。可以这样说，系统调用是利用访管指令定义的指令。操作系统服务例程与一般子程序的区别在于，前者所实现的功能都是与计算机系统本身有关的，对前者的调用是通过一条访管指令来实现的。不同的程序设计语言调用操作系统服务的方式是不同的，它们有显式调用和隐式调用之分。<strong>在汇编语言中是直接使用系统调用对操作系统提出各种要求的，因为在这种情况下，系统调用具有汇编指令的形式。而在高级语言中一般是隐式的调用（经编译后转成某种直接调用）。</strong></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><h4 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h4><p>根据1978年在庐山召开的全国操作系统会议上关于进程的讨论，结合国外的各种观点，国内对进程这一概念作了如下描述：进程是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动。<br>进程和程序是既有联系又有区别的两个概念，它们的区别如下。（1）程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态概念。而进程是程序在处理机上的一次执行过程，它是一动态概念。程序可以作为一种软件资料长期保存，而进程则是有一定生命期的，它能够动态地产生和消亡。即进程可由“创建”而产生，由调度而执行，因得不到资源而暂停，以致最后由“撤销”而消亡。（2）进程是一个能独立运行的单位，能与其他进程并行地活动。（3）进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。<br>进程和程序又是有联系的。在支持多任务运行的操作系统中，活动的最小单位是进程。进程一定包含一个程序，因为程序是进程应完成功能的逻辑描述；而一个程序可以对应多个进程。如果同一程序同时运行于若干不同的数据集合上，它将属于若干个不同的进程。或者说，若干不同的进程可以包含相同的程序。这句话的意思是：用同一程序对不同的数据先后或同时加以处理，就对应于好几个进程。例如，系统具有一个C语言编译程序，当它对多个终端用户的C语言源程序进行编译时，就产生了多个编译进程。</p><h4 id="进程类型"><a href="#进程类型" class="headerlink" title="进程类型"></a>进程类型</h4><p>有些进程起着资源管理和控制的作用，称为系统进程；而另一些是为用户算题任务而建立的进程称为用户进程。它们是有区别的。①系统进程被分配一个初始的资源集合，这些资源可为它所独占，也可以最高优先级的资格优先使用。用户进程通过系统服务请求的手段竞争系统资源。②用户进程不能做直接I&#x2F;O操作，而系统进程可以做显示的、直接的I&#x2F;O操作。③系统进程在管态下活动，而用户进程在用户态下活动。</p><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>进程有着“执行—暂停—执行”的活动规律。一般说来，一个进程并不是自始至终连续不停地运行的，它与并发执行中的其他进程的执行是相互制约的。它有时处于运行状态，有时又由于某种原因而暂停运行处于等待状态，当使它暂停的原因消失后，它又进入准备运行状态。所以，在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、等待状态（又称阻塞状态）。①就绪状态（ready）。当进程获得了除CPU之外所有的资源，它已经准备就绪，一旦得到CPU控制权，就可以立即运行，该进程所处的状态为就绪状态。②运行状态（running）。当进程由调度／分派模块分派后，得到中央处理机控制权，它的程序正在运行，该进程所处的状态为运行状态。③等待状态（wait）。若一进程正在等待某一事件发生（如等待输入／输出操作的完成）而暂时停止执行，这时，即使给它CPU控制权，它也无法执行，则称该进程处于等待状态，又可称为阻塞状态。<br>为了描述一个进程和其他进程以及系统资源的关系，为了刻画一个进程在各个不同时期所处的状态，人们采用了一个与进程相联系的数据块，称为进程控制块（processcontrolblock，PCB）或称为进程描述器（processdescriptor）。系统根据pcb而感知进程的存在，故pcb是标识进程存在的实体。当系统创建一个进程时，必须为它设置一个pcb，然后根据pcb的信息对进程实施控制管理。进程任务完成时，系统撤销它的pcb，进程也随之消亡。</p><h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><p>在操作系统中，为了支持并发活动，引入了进程的概念，在传统的操作系统中，每个进程只存在一条控制线索和一个程序计数器。但在有些现代操作系统中，提供了对单个进程中多条控制线索的支持。这些控制线索通常称为线程（threads），有时也称为轻量级进程（lightweightprocesses）。线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多条执行路径，即线程。这样，在一个进程内部就有多个可以独立活动的单位，可以加快进程处理的速度，进一步提高系统的并行处理能力。<br>①线程是进程中的一条执行路径；②它有自己私用的堆栈和处理机执行环境（尤其是处理器寄存器）；③它共享分配给父进程的主存；④它是单个进程所创建的许多个同时存在的线程中的一个。<br>进程和线程既有联系又有区别，对于进程的组成，可以高度概括为以下几个方面：①一个可执行程序，它定义了初始代码和数据；②一个私用地址空间（addressspace），它使进程可以使用的一组虚拟主存地址；③进程执行时所需的系统资源（如文件、信号灯、通信端口等），是由操作系统分配给进程的；④若系统支持线程运行，那么每个进程至少有一个执行线程。进程是任务调度的单位，也是系统资源的分配单位；而线程是进程中的一条执行路径，当系统支持多线程处理时，线程是任务调度的单位，但不是系统资源的分配单位。线程完全继承父进程占有的资源，当它活动时，具有自己的运行现场。<br>相对进程而言，线程的创建与管理的开销要小得多。因为线程可以共享父进程的所有程序和全局数据，这意味着创建一个新线程只涉及最小量的主存分配（线程表），也意味着一个进程创建的多个线程可以共享地址区域和数据。在进程内创建多线程，可以提高系统的并行处理能力。例如，一个文件服务器，某时刻它正好封锁在等待磁盘操作上，如果这个服务器进程具有多个控制线程，那么当另一个线程在等待磁盘操作时，第二个线程就可以运行，比如它又可接收一个新的文件服务请求。这样可以提高系统的性能。</p><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="多级调度"><a href="#多级调度" class="headerlink" title="多级调度"></a>多级调度</h3><p>1．批处理系统中的处理机调度<br>在多用户批处理操作系统中，对处理机的分配分为两级：作业调度和进程调度。在这样的系统中，每个用户提交的算题任务，往往作为系统的一个处理单位，称为作业。这样一道作业在处理过程中又可以分为多个并发的活动单位，称为进程。作业调度又称为宏观调度，其任务是对提交给系统的、存放在辅存设备上的大量作业，以一定的策略进行挑选，分配主存等必要的资源，建立作业对应的进程，使其投入运行。进入主存中的进程还可以根据需要创建子进程。作业调度使该作业对应的进程具备使用处理机的权利。而进入主存的诸进程，分别在什么时候真正获得处理机，这是由处理机的进程调度（一般又称为微观调度）来决定的。进程调度的对象是进程，其任务是在进入主存的所有进程中，确定哪个进程在什么时候获得处理机，使用多长时间等。<br>2．多任务操作系统中的处理机调度<br>3．多线程操作系统中的处理机调度<br>在现代操作系统中，有些系统支持多线程运行。在这样的系统中，一个进程可以创建一个线程，也可以创建多个线程。系统为进程分配它所需要的资源（如主存），而处理机的分配单位则为线程，系统提供线程调度程序，其功能是当处理机空闲时，以某种策略选择一个就绪线程去运行，并为它分配处理机时间。</p><h3 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h3><p>1．先来先服务调度算法<br>2．短作业优先调度算法<br>3．响应比高者优先调度算法<br>4．优先调度算法</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="调度／分派结构"><a href="#调度／分派结构" class="headerlink" title="调度／分派结构"></a>调度／分派结构</h4><p>任何进程都必须通过调度／分派模块来使用处理机。进程调度的功能可细分为调度和分派两部分。其中，调度意味着依照完全确定的策略将一批进程进行排序，而分派则是从就绪队列中移出一个进程并给它提供处理机的使用权。相应的调度程序和分派程序的功能是：调度程序负责将一个进程插入到就绪队列并按一定原则保持队列结构；分派程序是将进程从就绪队列中移出并建立该进程执行的机器状态。<br>但是，在一些系统中常常只提进程调度的概念，而不细分调度和分派这两个部分。因为这里所说的调度功能实际上分散到某些进程控制原语或通信原语中实现了，所以在这些系统中，调度与分派之间不加区别，并统称为调度程序模块。在这里提出调度／分派结构，是希望读者明确处理机的分配包含有两方面内容：一是按确定的调度原则选一个进程；二是给选中进程赋予处理机的控制权。若要强调后者，就使用“分派程序”这一名词；否则就采用“进程调度程序”这一名词。</p><ul><li>CPU现场信息的切换<br>CPU现场信息的切换（即保留原来运行进程的状态信息，并用保留在选中进程PCB中的状态信息设置CPU现场）所需时间是额外开销，因为切换时系统并不能做其他的工作。进程切换所需时间因机器不同而不同，它取决于主存速度、必须复制的寄存器的数量、是否有特殊指令（如装入或保存所有单个指令）等因素。切换时间与硬件支持密切相关。例如，有的处理器（如SUNUltraSPARC）提供了多个寄存器组，切换只需要简单地改变当前寄存器组的指针。当处理器只有一个寄存器组，或活动进程超过了寄存器组的数量时，系统必须在寄存器组与主存之间进行数据复制。而且，操作系统越复杂，这一切换所要做的工作就越多。典型的进程切换时间为1μs到1000μs。进程调度时机可能有以下几种：①进程完成其任务时；②在一次管理程序调用之后，该调用使现行程序暂时不能继续运行时；③在一次出错陷入之后，该陷入使现行进程在出错处理时被挂起时；④在分时系统中，当进程使用完规定的时间片，时钟中断使该进程让出处理机时；⑤在采用可剥夺调度方式的系统中，当具有更高优先级的进程要求处理机时。</li><li>进程调度的准则<br>不同的进程调度算法具有不同的特点，且可能对某些进程更有利。为了对算法进行选择以适用于特定的应用，必须分析各种算法的特点。为了比较各种进程调度算法，分析员提出了许多准则，这些准则对确定算法的优劣有很大的影响，这些准则涉及如下几个因素。（1）CPU使用率。需要使CPU尽可能忙。CPU使用率从0到100％。对于真实系统，它应从40％（轻负荷系统）到90％（重负荷系统）。（2）吞吐量。如果CPU忙于执行进程，那么就要评估其工作量。其中一种测量工作量的方法称为吞吐量。吞吐量是指一个时间单元内所完成的进程数量。若系统中短进程多，则吞吐量较高，可能为每秒十个进程。（3）周转时间。在批处理系统中，从作业进入系统到完成的时间间隔称为周转时间。周转时间是所有时间段之和，包括等待进入主存、在就绪队列中等待、在CPU上执行和I&#x2F;O执行时间。利用特权可以分析运行该作业需要花费的时间。（4）响应时间。对于交互式系统而言，周转时间并不是最佳的准则，通常采用响应时间作为时间度量。响应时间是指从联机用户向计算机发出一个命令到计算机执行完该命令，并将相应的执行结果返回给用户所需的时间。（5）等待时间。进程调度算法并不影响进程运行和执行I&#x2F;O的时间量，它只影响进程在就绪队列中等待所花费的时间。等待时间是进程在就绪队列中等待所花费时间之和。人们需要使CPU使用率和吞吐量最大化，而使周转时间、响应时间和等待时间最小化。在绝大多数情况下要优化平均度量值，不过在有的情况下，需要优化最小值或最大值，而不是平均值。例如，在分时系统中为了保证所有用户都得到好的服务，可能需要使响应时间最小。</li><li>调度方式<br>在优先调度策略下还要确定调度方式。所谓调度方式是指，当一进程正在处理机上执行时，若有某个更为“重要而紧迫”的进程需要进行处理，亦即，若有优先级更高的进程进入就绪队列时，如何分配处理机。通常有两种进程调度方式：一种是仍然让正在执行的进程继续执行，直到该进程完成或发生某事件（如提出I&#x2F;O请求）而进入“完成”或“阻塞”状态时，才把处理机分配给“重要而紧迫”的进程，使之执行，这种进程调度方式称为非剥夺方式；另一种方式则是“重要而紧迫”的进程一到，便暂停正在执行的进程，立即把处理机分配给它，这种方式称为可剥夺调度方式。后者所实施的策略就是可抢占的调度策略。</li><li>进程优先数调度<br>进程优先数调度算法就是一种优先调度，该算法预先确定各进程的优先数，系统将处理机的使用权赋予就绪队列中具备最高优先级（优先数和一定的优先级相对应）的就绪进程。这种算法又可分为不可抢占CPU与可抢占CPU两种情况。在后一种情况下，无论何时，执行着的进程的优先级总要比就绪队列中的任何进程的优先级高。</li></ul><h2 id="主存管理"><a href="#主存管理" class="headerlink" title="主存管理"></a>主存管理</h2><h3 id="空间分片"><a href="#空间分片" class="headerlink" title="空间分片"></a>空间分片</h3><p>现代操作系统区分两类主存：物理主存和逻辑主存。主存共享的基础当然是物理主存。物理主存由0～m-1个物理地址组成。物理地址是计算机主存单元的真实地址，又称为绝对地址或实地址。处理机依据绝对地址可以随机存取存放在其内的信息。物理地址的集合所对应的空间组成了主存空间。而主存中的一个区域是物理地址集合的一个递增整数序列子集{n，n+1，…，n+m}所对应的主存空间。<br>在多用户多进程系统中，主存以分片方式实现共享。主存中分片的方式有两种：一是划分为大小不等的区域，这些区域根据用户程序实际需要而被分割；二是划分为大小相等的块，以块为单位进行分配，操作系统和用户程序根据需要占用若干主存块。前者一般称为按区（或按段）分配，后者称为按页分配。这些分配方法是实现主存共享的主要方法。</p><h3 id="主存管理的功能"><a href="#主存管理的功能" class="headerlink" title="主存管理的功能"></a>主存管理的功能</h3><p>如果直接以物理地址提交给用户使用，这对用户来说是十分困难的事。而且，多个用户程序共享主存，由用户自行分配主存更是不可能的事。为了支持多道程序运行，方便用户使用，系统必须为每个用户提供0～n-1的一组逻辑地址（虚地址），即提供一个虚拟地址空间。每个应用程序相信它的主存是由0单元开始的一组连续地址组成。用户的程序地址（指令地址或操作数地址）均为逻辑地址。对于每个逻辑地址，在主存中并没有一个固定的、真实的物理单元与之对应。因此，根据逻辑地址还不能直接到主存中去存取信息，它是一个虚地址或称为相对地址。用户所看到的虚存（逻辑地址）与被共享的主存（物理地址）之间有一定的映射关系。程序执行时，必须将逻辑地址正确地转换为物理地址，此即为地址映射。假定虚存空间由n表示，主存空间由m表示，那么地址映射可表示成：f：n→m。为了支持多道程序运行，主存管理必须实现主存分配、主存保护、主存扩充等功能。因此，存储管理的功能可归纳为以下几点：①映射逻辑地址到物理主存地址；②在多用户之间分配物理主存；③对各用户区的信息提供保护措施；④扩充逻辑主存区。</p><h4 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h4><p>随着科学技术的不断进步和计算机应用的日益广泛，需要计算机解决的问题越来越多、越来越复杂。有些科学计算或数据处理的问题需要相当大的主存容量，尤其在多道程序系统中主存容量显得更为紧张。当系统提供大容量的辅存时，操作系统把主存和辅存统一管理，实现信息的自动移动和覆盖。当一个用户程序的地址空间比主存可用空间大时，操作系统将这个程序的地址空间的一部分放入主存内，而其余部分放在辅存上。当所访问的信息不在主存时，则由操作系统负责调入所需要的部分。由于大多数程序执行时，在一段时间内仅使用它的程序编码的一部分，即并不需要在全部时间内将该程序的全部指令和数据都放在主存中，所以，程序的地址空间部分装入主存时，它还能正确地执行，此即为程序的局部性特征。<br>虚拟存储器（virtualmemory）将用户的逻辑主存与物理主存分开，这是现代计算机对虚存的实质性的描述。更为一般的描述是：计算机系统在处理应用程序时，只装入部分程序代码和数据就启动其运行，由操作系统和硬件相配合完成主存和外围联机存储器之间的信息的动态调度，这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器。之所以称它为虚拟存储器，是因为这样的存储器实际上并不存在，只是由于系统提供了自动覆盖功能后，给用户造成的一种虚拟的感觉，仿佛有一个很大的主存供他使用一样。<br>虚拟存储器的核心问题是将程序的访问地址和主存的可用地址相脱离。程序的访问地址称为虚地址，它可以访问的虚地址范围叫做程序的虚地址空间V，虚地址范围是由虚地址寄存器的位数决定的。在指定的计算机系统中，可使用的实地址范围叫做计算机的实地址空间R。当然，虚地址空间可以比实地址空间大，也可以比实际主存小。在多道程序运行环境下，操作系统把实际主存扩充成若干个虚存，系统可以为每个应用程序建立一个虚存。这样每个应用可以在自己的地址空间中编制程序，在各自的虚存上运行。引入虚存概念后，用户无需了解实存的物理性能，只需在自己的虚存上编制程序，这给用户带来了极大的方便。主存空间的分配由系统完成；逻辑地址转换成物理地址是通过地址变换机构自动完成的，这样，既消除了普通用户对主存分配细节、具体问题了解的困难，方便了用户，又能根据主存的情况和应用程序的实际需要进行动态分配，从而充分利用了主存。而且，多道程序设计所要求的存储保护、程序浮动都可以很方便地实现。必须指出，实现虚拟存储技术，需要有一定的物质基础。其一是需要有相当容量的辅存，以便足以存放多用户的作业的地址空间；其二是要有一定容量的主存；其三是地址变换机构。</p><h3 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h3><p>分区存储管理是满足多道程序设计的最简单的一种存储管理方法。它允许多个用户作业共享主存空间，这些作业在主存内是以划分分区而共存的。早期的分区存储管理技术只有固定式分区方法，后来才发展形成动态分区方法。<br>分区存储管理技术能满足多道程序设计的需要，但它也存在着一个非常严重的碎片问题。解决这个问题的办法之一是采用拼接技术。所谓拼接技术是指移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲区，拼接要消耗大量的系统资源，且有时为拼接所花费的系统开销要大于拼接所得到的效益，因而这种方法的使用受到了限制。</p><h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><p>为了寻找解决碎片问题的新途径，人们很容易想到能否避开程序对连续连续性的要求，让程序的地址空间去适应存储器的现状。例如，有一个作业要求投入运行，其程序的地址空间为3KB，而主存当前只有两个各为1KB和2KB的空闲区。显然，每个空闲区的大小都比该程序的地址空间小，而总和却同它相等。这时可以把该程序存放到主存中这两个不相邻的区域中。这正是分页的思想。<br>在分页存储管理方法中，主存被等分成一系列的块，程序的地址空间被等分成一系列的页面，然后将页面存放到主存块中。为了便于实现动态地址变换，一般主存的块和页面大小相等且为2的幂次。<br>另外，在按区分配方案中，当作业程序的地址空间小于主存可用空间时，该作业是不能投入运行的，即不能方便地实现主存扩充。但是，在页式系统中则可方便地支持虚拟存储，扩充主存，因为它不需限定作业在投入运行之前必须把它的全部地址空间装入主存，而只要求把当前所需要的一部分页面装入主存即可。这样，对虚地址空间的限制，至少从理论上来说被取消了。换句话说，这种系统为用户提供了一个很大的地址空间。但系统必须完成主存和辅存之间的信息的自动调度。因为，一个作业的全部页面存放在辅存上，当它投入运行时，只是将运行进程的部分页面装入主存（这些页面称为活动页面），在进程活动期间，系统根据其需要再从辅存调入所需的页面。</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>程序的虚地址空间划分为若干页，并被装入主存的空闲块中。于是，一个连续的程序空间在主存中可能是不连续的。为了保证程序能正确地运行，必须在执行每条指令时将程序中的逻辑地址变换为实际的物理地址，即进行动态重定位。在页式系统中，实现这种地址变换的机构称为页面映像表，简称页表。在页式系统中，当程序按页划分装入存储器时，操作系统为该程序建立一个页表。页表是记录程序虚页与其在主存中块（实页）的对应关系的数据结构。页表中的每一个数据项用来描述页面在主存中的物理块号以及页面的使用特性（根据需要扩充页表的功能）。在简单的页式系统中，页表只是虚页和主存物理块的对照表。<br>页表可由高速缓冲存储器组成，这样做的结果是，地址变换速度快，但成本较高。另一个办法是在主存固定区域内，用存储单元来存放页表。这种方法要占用一部分主存空间，而且地址变换速度较慢。现代的计算机系统采用硬件与主存页表相结合的方法实现地址变换。</p><p><img src="/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/9.jpg">根据实际使用的经验，一般页面尺寸为1KB、2KB或4KB。<br>当请求调页程序要调进一个页面、而此时该作业所分得的主存块已全部用完，则必须淘汰该作业已在主存中的一个页。这时，就产生了在诸页面中淘汰哪个页面的实际问题，这也就涉及淘汰算法即置换算法的问题。算法设计不好将造成巨大系统开销，称为颠簸。</p><h3 id="段式系统"><a href="#段式系统" class="headerlink" title="段式系统"></a>段式系统</h3><p>在前述的分区存储管理和页式系统中，程序的地址空间是一维线性的，因为指令或操作数地址只要给出一个信息量即可决定。分区存储管理方法易出现碎片。页式系统中一页或页号相连的几个虚页上存放的内容一般都不是一个逻辑意义完整的信息单位。请调一页，可能只用到页中的一部分内容。这种情况，对于要调用许多子程序的大型用户程序来说，仍然会感到感到主存空间的使用效率不高。为此，提出了段式存储管理技术。在这样的系统中作业的地址空间由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，它是一个连续的地址区。在主存中，每个分段占一分区。由于分段是一个有意义的信息单位，所以分段的共享和对分段的保护更有意义，同时也容易实现。</p><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p>在段式存储管理中结合分页存储管理技术，即在程序地址空间内分段，在一个分段内划分页面，这就形成了段页式存储管理。具有段页式地址结构的用户地址空间。<br>段页式存储管理的用户地址空间是二维的、按段划分的。在段中再划分成若干大小相等的页。这样，地址结构就由段号、段内页号和页内位移三部分组成。用户使用的仍是段号和段内相对地址，由地址变换机构自动将段内相对地址的高几位解释为段内页号，将剩余的低位解释为页内位移。用户地址空间的最小单位不是段而是页，而主存按页的大小划分，按页装入。这样，一个段可以装入到若干个不连续的主存块内，段的大小不再受主存可用区的限制了。</p><p><img src="/2022/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/10.jpg">段页式地址变换中要得到物理地址须经过三次主存访问（若段表、页表都在主存），第一次访问段表，得到页表起始地址；第二次访问页表，得到主存块号；第三次将主存块号与页内位移组合，得到物理地址。可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但在方便用户和提高存储器利用率上很好地实现了存储管理的目标。<br>请求调页策略是在主存和辅存之间传送存储页，而不是整个进程。这样，整个进程并不需要全部驻留在主存中就可运行，即当进程访问页面时，核心为进程装入该页。请求调页的优点是，它使进程的虚地址空间到机器的物理存储空间的映射更为灵活，允许进程的大小比可用的物理存储空间大得多，还允许将更多的进程同时装入主存。</p><h2 id="输入／输出管理"><a href="#输入／输出管理" class="headerlink" title="输入／输出管理"></a>输入／输出管理</h2><p>I&#x2F;O设备是计算机系统中除中央处理机、主存储器之外的所有其他的设备。<br>为了便于用户作业及相应进程在运行期间利用各类设备I&#x2F;O，管理程序应能屏蔽设备的物理特性，为用户建立虚环境。现代操作系统一般采用“设备独立性”的概念。<br>所谓设备独立性是指用户在编制程序时所使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。逻辑设备名是用户自己指定的设备名（或设备号），它是暂时的、可更改的。而物理设备名是系统提供的设备的标准名称，它是永久的、不可更改的。虽然程序在实际执行中必须使用实际的物理设备，就好像程序在主存中一定要使用物理地址一样，但在用户程序中则应避免使用实际的物理名，而采用逻辑设备名。这样做的道理就和用户程序中要使用逻辑地址而不使用物理地址的道理一样。设备管理的任务之一就是把逻辑设备名转换成物理设备名。</p><h3 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h3><ul><li><p>什么是缓冲<br>缓冲是在两种不同速度的设备之间传输信息时平滑传输过程的常用手段。缓冲器是以硬件的方法来实现缓冲的，它容量较小，是用来暂时存放数据的一种存储装置。从经济上考虑，除了在关键的地方采用少量必要的硬件缓冲器之外，大都采用软件缓冲。软件缓冲区是指在I&#x2F;O操作期间用来临时存放I&#x2F;O数据的一块存储区域。缓冲是为了解决中央处理机的速度和I&#x2F;O设备的速度不匹配的问题而提出来的，缓冲也可用于解决程序所请求的逻辑记录大小和设备的物理记录大小失配的问题，是有效地利用中央处理机的重要技术。下面看看缓冲是如何工作的。当用户要求在某个设备上进行读操作时，从系统中获得一个空的缓冲区，并将一个物理记录读到缓冲区中。当用户要求使用这些数据时，系统将依据逻辑记录特性从缓冲区中提取并发送到用户进程存储区中。当缓冲区空而进程又要从中取数据时该进程被迫等待。此时，操作系统需要重新送数据填满缓冲区，进程则从中取数据继续运行。当用户要求写操作时，先从系统获得一个空缓冲区，并且将一个逻辑记录从用户的进程存储区传送到缓冲区中。若为顺序写请求，则把数据写到缓冲区中，直到它完全装满为止。然后系统将缓冲区的内容作为物理记录文件写到设备上，使缓冲区再次为空。只有在系统还来不及腾空缓冲区之前，进程又企图输出信息时，它才需要等待。</p></li><li><p>使用缓冲的理由<br>1）处理数据流的生产者与消费者之间的速度差异<br>2）协调传输数据大小的不一致<br>3）应用程序的拷贝语义</p></li></ul><h3 id="输入／输出控制方式"><a href="#输入／输出控制方式" class="headerlink" title="输入／输出控制方式"></a>输入／输出控制方式</h3><p>外部设备在中央处理机的控制之下完成信息的传输。在信息传输中，中央处理机做多少工作、外部设备做多少工作呢？这个问题将决定CPU和I&#x2F;O设备的并行能力，同时它也取决于软、硬技术的基础。CPU一般通过I&#x2F;O控制器与物理设备打交道。按照I&#x2F;O控制器智能化程度的高低，可把I&#x2F;O设备的控制方式分为四类：循环测试I&#x2F;O方式、I&#x2F;O中断方式、DMA方式和通道方式。</p><ul><li><p>I&#x2F;O中断方式<br>与循环测试方式相比，I&#x2F;O中断方式使CPU的利用率大大提高了。但缺点是由于每台设备每次输入／输出一个数据，都要求中断CPU，当系统配置的设备较多时，系统进行中断处理的次数就很多，这会使CPU的有效计算时间大大减少。为减少I&#x2F;O中断处理对CPU造成的负担，又出现了通道方式和DMA方式。</p></li><li><p>通道方式<br>在大、中型和超级小型机中，一般采用I&#x2F;O通道控制I&#x2F;O设备的各种操作。I&#x2F;O通道是用来控制外部设备与主存之间进行成批数据传输的部件。每个通道可以连接多台外部设备并控制它们的I&#x2F;O操作。通道有自己的一套简单的指令系统和执行通道程序，通道接收CPU的委托，而又独立于CPU工作。因此，可以把通道看做是一台小型的处理I&#x2F;O的处理机，或称I&#x2F;O处理机。<br>与前面两种I&#x2F;O方式相比，通道方式有更强的I&#x2F;O处理能力。有关I&#x2F;O的工作，CPU委托通道去做，当通道完成了I&#x2F;O任务后，向CPU发中断信号，请求CPU处理。这样就使CPU基本上摆脱了I&#x2F;O控制工作，并大大提高了CPU与外部设备的并行工作的程度。</p></li><li><p>DMA方式<br>在DMA方式中，I&#x2F;O控制器有更强的功能。它除了具有上述的中断功能外，还有一个DMA控制机构。在DMA控制器的控制下，设备和主存之间可成批地进行数据交换，而不用CPU干预。这样既大大减轻了CPU的负担，也使I&#x2F;O的数据传送速度大大提高。在DMA方式下，允许DMA控制器“接管”地址线的控制权，而直接控制DMA控制器与主存的数据交换。因此，I&#x2F;O设备与主存之间的数据传送不需要CPU介入，从而减轻了CPU的负担。</p></li></ul><h3 id="UNIX系统设备管理的主要特点"><a href="#UNIX系统设备管理的主要特点" class="headerlink" title="UNIX系统设备管理的主要特点"></a>UNIX系统设备管理的主要特点</h3><p>  1．将外部设备看做文件，由文件系统统一处理<br>  2．系统的设备配置灵活、方便<br>  3．使用块设备缓冲技术，提高了文件系统的存取速度块设备的文件存储部分是文件系统存在的介质，而文件系统与用户界面的联系最为密切，故文件系统存取文件的效率是十分重要的。文件系统通过高速缓冲机制存取文件数据，缓冲机制调节核心与文件存储设备之间的数据流。UNIX提供由数据缓冲区组成的高速缓冲，每个缓冲区的大小为512字节。当用户程序要把信息写入文件时，先写入缓冲区里立即返回，由系统作延迟写处理。当用户程序要从磁盘读文件信息时，先要查看在缓冲区缓冲区中有无含有此信息的块，如果有就不必启动磁盘I&#x2F;O，可立即从缓冲区内取出。这种做法大大加快了文件的访问速度。</p><ul><li>UNIX缓冲区的管理<br>对文件系统的一切存取操作，核心都能通过每次直接从磁盘上读或往磁盘上写来实现。但磁盘的传输速率与CPU的速度相比还是慢的。为了加快系统的响应时间和增加系统的吞吐量，UNIX构造了一个由高速缓冲组成的内部数据缓冲池，以降低磁盘的存取频率。UNIX缓冲管理策略试图将尽可能多的有用数据保存在高速缓冲中。核心体系结构中的高速缓冲模块的位置处于文件子系统与块设备驱动程序之间。当从磁盘中读数据时，核心试图先从高速缓冲区中读。如果数据已在高速缓冲中，核心可以不必启动磁盘I&#x2F;O。如果数据不在该高速缓冲区中，则核心从磁盘上读数据，并将其暂时保存在缓冲区中。类似地，要往磁盘上写数据时，也先往高速缓冲区中写入，以便核心随后又试图读它时，它能在高速缓冲中。但是，被写在高速缓冲中的数据要延迟写到非往磁盘上写不可的时候才进行。所以，高速缓冲模块的算法实现了数据的预先缓存和延迟发送的功能。</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件的物理结构：连续文件、串联文件、随机文件、索引文件</p><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p>文件系统是用户和外部设备之间的接口和界面。用户可通过文件系统去管理和使用各种设备介质上的信息。文件系统的大部分工作是为了解决“用户所需的信息结构及其操作”与“设备介质的实际结构和I&#x2F;O指令”之间的差异。用户所希望的信息结构是按照简单的逻辑关系组织在一起的，他们所希望的操作是一些只用名字就能存取所需信息的读写操作。然而，计算机只能使用各种I&#x2F;O指令去存取相应介质上的信息，其信息结构又是按照设备介质的各自特点组织的。因此，文件系统所要解决的核心问题，就是按照充分发挥主机和外部设备效率的原则，把信息的逻辑结构映像成设备介质上的物理结构，把用户的文件操作转换成相应的I&#x2F;O指令。转换过程所使用的主要数据结构是文件目录和辅存空间使用情况表。这样，文件目录就将每个文件的符号名和它们在辅存空间的物理地址与有关文件情况的说明信息联系起来了。因此，用户只需向系统提供一个文件符号名，系统就能准确地找出所要的文件来，这就是文件系统的基本功能。实现符号名与具体物理地址之间的转换，其主要环节是查目录。所以，目录的编排应以如何能准确地找到所需的文件为原则，而选择查目录的方法应以查找速度快为准则。</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>操作系统基本概念原理介绍。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理与汇编语言程序设计</title>
    <link href="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《计算机组成原理与汇编语言程序设计（第4版）(高等学校规划教材)》 徐洁 电子工业出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><p>在早期，冯·诺依曼将计算机的硬件组成分为5大部件。几十年来，计算机硬件系统已有了许多重大变化。首先，现在采用的大规模及超大规模集成电路，可将运算器和控制器集成在一块芯片上，合称为中央处理器（CPU）。它是负责执行程序，实现运算处理，控制整个系统的部件。相应地，原来的运算器现在作为CPU中的运算部件（又称为算术逻辑部件），它与控制器之间的界限已不像原来那样分明。其次，存储器分为高速缓存、主存储器、外存储器三个层次。其中高速缓存常集成在CPU内部，作为CPU的一个部分，也可以在CPU之外再设置一级高速缓存。通常将CPU与主存储器合在一起称为主机，主存储器（简称主存）就是因为位于主机之内而得名，有的书中又称它为内存储器（内存）。位于主机之外的磁盘、光盘、磁带等，则作为外存储器（外存）。还有，输入设备的任务是将外部信息输入主机，输出设备则是将主机的运算处理结果或其他信息从主机输出。但从信息传送控制的角度看，它们并无多大区别，不过是传送方向不同而已。有些设备还兼有输入与输出两种功能，所以在描述系统结构时常将它们合称为输入&#x2F;输出设备，简称I&#x2F;O设备。 </p><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/1.jpg"></p><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>CPU（CentralProcessingUnit）即中央处理器，是硬件系统的核心部件，负责读取并执行指令，也就是执行程序。<br>在CPU中有一个程序计数器PC（ProgramCounter），它存放着当前指令所在存储单元的地址。如果程序是顺序执行，在读取一个或连续几个存储单元的指令代码后，PC的内容就加1或加几，以指出下一条指令的地址；如果程序需要转移，则将转移地址送入PC。因此，PC就像一个指针，指引着程序的执行顺序。虽然指令与数据都采用二进制代码表示，在外形上没有区别，但可按照PC中的中的地址信息去读取指令，再按照指令给出的操作数地址去读取数据。<br>CPU内有一个或多个算术逻辑部件ALU（ArithmeticLogicUnit）。通常按照指令的要求将有关数据送入ALU，进行指定的算术或逻辑运算，然后将运算结果送到主存单元，或暂存在CPU内的寄存器中。CPU内的主要部分是控制器（又称为控制部件），它的任务是控制整个系统的工作，决定在什么时候，根据什么，发出什么命令，做什么操作。例如它控制着从主存中读取指令，根据指令代码分时地发出一些最基本的控制信号即微命令，控制存储器的读写、ALU的运算处理、数据的输入&#x2F;输出等。按照产生微命令的方式不同，控制器可分为两大类：组合逻辑控制器及微程序控制器。<br>组合逻辑控制器完全靠若干组合逻辑电路（即硬件）产生微命令序列，将指令代码、状态信息、时序信号等输入到这些组合逻辑电路，电路将分时产生相应的微操作命令。这种控制器又称硬连逻辑控制器，其优点是形成微命令的速度快，常用于精简指令系统计算机（RISC）中。<br>微程序控制器是将微命令序列以代码形式编制成微程序，存入一个控制存储器中；当CPU执行指令时，通过读取并执行对应的一段微程序，产生微命令序列，控制完成指定的操作。微程序控制方式比较规整，硬件代价较小，易于扩充功能，但速度较慢。</p><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p>我们总是希望计算机系统中的存储器容量大，存取速度快，但这往往是有矛盾的，所以常将存储器分为几级。其中主存储器用半导体存储器构成，工作速度较高，也有一定的存储容量。外存储器为主存提供后援，由磁盘、光盘、磁带等构成，其存储容量很大，但速度较主存储器低。高速缓冲存储器、主存储器和外存储器，组合成一个完整的多级存储系统，使得整个系统既有很大的存储容量，而CPU又可以高速地访问存储器。主存储器用来存放需要执行的程序及需要处理的数据，能由CPU直接读出或写入。<br>主存储器的一项重要特性是：能按地址（单元编号）存放或读取内容，也就是允许CPU直接编址访问，通常以字节为编址单位。对主存储器来说，寻找存储单元（寻址）的依据是地址码，所存取的内容是指令或数据。</p><h3 id="外存储器"><a href="#外存储器" class="headerlink" title="外存储器"></a>外存储器</h3><p>外存储器用来存放那些需要联机存放，但暂不执行的程序和数据，当需要运行它们时再由外存调入主存。例如在光盘中存放着几个备用的软件，但当前暂时只用得着用得着其中的一个，我们先将它调入主存，其余软件仍存放在光盘上。又如一个信息管理系统所保存的数据很多，可将它们存放在磁盘之中，只将当前需要查询的部分调入主存，以后再调换。这样，主存的容量就不需要很大，可以做到速度比较快。而由磁盘、光盘等构成的外存储器容量很大，可为整个系统提供后援支持，其速度要求可以比主存低一些。<br>由于外存储器不由CPU直接编址访问，也就是说不需要按字节地从外存储器读取或写入，因此外存储器中的内容一般都按文件的形式进行组织，一个文件常分解为若干数据块，可以包含许多字节的信息。用户按文件名进行调用，CPU找到该文件在外存中的存放位置，以数据块为单位进行读写。</p><h3 id="输入-x2F-输出设备"><a href="#输入-x2F-输出设备" class="headerlink" title="输入&#x2F;输出设备"></a>输入&#x2F;输出设备</h3><p>计算机系统大多配备了键盘、鼠标、显示器、打印机等常规输入&#x2F;输出设备，简称I&#x2F;O设备。</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>怎样将CPU、主存、多台I&#x2F;O设备连接成整机系统呢？现在普遍采用总线结构。所谓总线是指一组能为多个部件分时共享的信息传输线。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>一台计算机系统需连接哪些I&#x2F;O设备，这要根据该系统的应用场合而定，因此通过系统总线连接的设备，其类型与数量都应当可以扩充。某种型号的计算机系统，其系统总线往往是标准的，也就是说，有多少根地址线、数据线，有哪些控制信号线，每个信号的名称及作用等，都是规定好的。</p><p>概括地说，计算机硬件系统是由三大子系统：CPU、存储系统（包括高速缓存、主存和外存）、输入&#x2F;输出系统（包括输入&#x2F;输出设备和接口），以及连接它们的总线构成。</p><h2 id="计算机软件系统"><a href="#计算机软件系统" class="headerlink" title="计算机软件系统"></a>计算机软件系统</h2><h3 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h3><ul><li><p>操作系统</p></li><li><p>编译程序与解释程序</p></li></ul><p>计算机硬件能够直接识别的是数字代码，所以让计算机硬件执行的基本命令，如传送、加、减等，必须用0、1这样的数字编码来表示。由硬件执行的程序的最终形态是由若干指令组成的序列，即指令是程序（可执行形态）的基本单位。一般地，一条指令规定了一种基本操作（如传送、加、减），并提供操作数地址或直接提供操作数，这些信息都由数字代码表示。一台计算机可以执行的各种指令的集合，称为这种计算机的指令系统。显然，不同的机型往往具有不同的指令系统，以及相应的指令格式约定，所以机器指令代码又称为机器语言，即面向特定机器结构的一种内部语言。<br>如果直接用机器语言（0、1代码）编制程序，将非常不便，于是人们想到用一些约定的符号，如英文缩写的字符串，去表示操作含义、操作数、地址等，这就产生了汇编语言。汇编语言是一种用符号表示的与机器指令基本对应的程序设计语言，它专属于某种机型或某种系列机，其他计算机不能直接使用，所以是一种面向机器结构的程序设计语言，不是通用语言。<br>为了便于编制程序，现在所使用的绝大多数编程语言是高级程序设计语言，这是一些面向用户，与特定机器属性相分离的语言。高级程序设计语言与机器指令之间没有直接的对应关系，所以它可以在各种机型中通用，编程者使用高级语言也不必了解具体的机器指令系统及其他硬件属性。高级程序设计语言需要遵循一定的严格语法规定与格式，才能为语言处理程序（编译、解释）所识别。<br>机器语言是机器内部使用的、用数字代码表示的指令代码，面向某一特定机型，可由硬件直接识别并执行。汇编语言是一种用符号表示的，面向某一特定机型的程序设计语言，它的指令语句与机器指令一一对应。高级程序设计语言则是面向用户，与特定机器属性相分离的程序设计语言，具有通用性。<br>大多数情况下，用户采用高级程序设计语言编写程序，个别情况采用汇编语言编写程序。用这些程序设计语言编写出的程序叫做源程序，它们由一些语句组成。将源程序输入计算机后，计算机先执行一种语言处理程序，将源程序转换为机器语言代码序列，即机器语言程序，然后由计算机硬件执行这些用机器语言代码表示的指令序列，从而完成用户程序的执行过程。这种语言处理程序也是一种必需的系统软件。<br>语言处理方式有两种类型：解释与编译。解释方式是边解释边执行，为此需要一种针对某种程序设计语言的解释程序（又称解释器）作为系统软件的组成部分之一。将源程序输入计算机后，启动并执行相应的解释程序，它的作用是逐步分析源程序中的语句，按照源程序描述的过程，执行一个与此等价的机器语言指令序列，直到整个源程序都被扫描一遍，并被解释执行完毕为止。这有点像口译外语的情形，边说边翻译。解释方式适用于比较简单的程序设计语言，如BASIC。它的优点是支持人机对话方式的程序设计，可以边执行边修改；所需要的主存空间较小。但是这种方式的执行速度较慢，不能解释那些前后关联较多、较难理解的程序设计语言。大多数程序设计语言采用编译方式。将源程序输入计算机后，先启动并执行相应的编译程序（又称编译器），将源程序全部翻译成目标程序（目标代码）的机器语言指令序列。执行时，计算机将直接执行目标程序，不再需要源程序与翻译程序。因此，这种编译方式有点像笔译，得到完整的译文后就可以不要原文与译者了。在编译过程中，它所需的主存空间比解释方式多些，既要容纳源程序又要容纳一个比较大的编译程序；需花费的时间也要长些。但运行用户程序时，所需的主存空间比较小，执行速度也较快。<br>将汇编语言源程序转换为机器代码的目标程序的过程也是一种编译，人们将它专门称为“汇编”，相应的翻译程序称为汇编程序（又称汇编器）。它的逆过程叫做“反汇编”，即将用机器代码表示的目标程序（指令序列）反汇编成用汇编语言描述的程序。为利于二次开发，在剖析一些已有的重要软件时，常常需要进行反汇编。</p><ul><li>各种软件平台</li></ul><h3 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h3><p>应用软件不胜枚举，它一般包括：①科学计算类；②数据处理类；③自动控制类；④计算机辅助设计类；⑤人工智能类；等等。</p><h2 id="计算机系统层次"><a href="#计算机系统层次" class="headerlink" title="计算机系统层次"></a>计算机系统层次</h2><h3 id="从计算机系统组成角度划分层次结构"><a href="#从计算机系统组成角度划分层次结构" class="headerlink" title="从计算机系统组成角度划分层次结构"></a>从计算机系统组成角度划分层次结构</h3><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/2.jpg"></p><ol><li><p>微体系结构层<br>微体系结构层是具体存在的硬件层次，在这一层我们看到的不是由大部件（即CPU、存储系统、输入&#x2F;输出系统及互连机构）构成的计算机，而是更细微的机器结构。微体系结构层执行机器指令，它可看作是指令系统层指令的解释器。在由微程序控制数据通路的计算机上，微程序就是上一层指令的解释器。它通过数据通路逐条对指令进行取指、译码和执行。例如，对加法ADD指令，将首先取出指令进行译码分析，然后找到操作数送入寄存器，由ALU求和，最后存结果。结果到指定地方，如某个存储器单元。而在硬件直接控制数据通路的计算机上，执行的步骤与此类似，但是由硬件直接解释执行指令，并不存在一个真正的程序来解释上一层的指令。</p></li><li><p>指令系统层<br>原则上，指令系统层是机器语言程序员眼中所看到的计算机，当然现在人们并不使用机器语言编程。指令系统层位于微体系结构层之上，是一个抽象的层次，其主要特征就是指令系统。指令系统（又称指令集）是指一台计算机所能执行的全部指令的集合。其指令是由微体系结构层的微程序解释执行或硬件电路直接执行的。<br>指令系统是计算机软件与硬件之间的一种接口。硬件系统的基本任务是实现指令系统所规定的各种指令功能，而各种程序只有最终转化为用机器语言（即代码表示的指令序列）才能被硬件执行。尽管现在已广泛应用各种高级语言编程，但需通过编译器或解释器将高级语言程序转换为硬件可以识别与执行的机器指令序列。<br>指令系统层定义了硬件和编译器之间的接口，它是一种硬件和编译器都能理解的语言。一方面，指令系统表明了一台计算机具有哪些硬件功能，是硬件逻辑设计的基础。因此，在指令系统层，应该定义一套在当前和将来的技术条件下能够高效率实现的指令集，从而使高效率的设计可用于今后的若干代计算机中。另一方面，指令系统层应该为编译器提供明确的编译目标，使编译结果具有规律性和完整性。</p></li><li><p>操作系统层<br>从程序员的观点来看，操作系统是一个在指令系统层提供的指令和特性之上又增加了新指令和特性的程序。这一层有新的指令集，有不同的存储器结构，有同时运行两个或多个程序的能力，以及其他一些特性。<br>尽管操作系统层和指令系统层都是抽象层次，但它们之间具有重要的区别。操作系统层指令集是系统程序员完全可用的指令集。它包括几乎所有的指令系统层的指令和操作系统层增加的新指令。这些新指令称为系统调用（SystemCall），如DOS操作系统的系统功能调用“INT21H”用于设备、文件和目录等管理，Linux操作系统的系统调用“fork()”用来创建一个进程。一个系统调用使用一条新指令调用一个预先定义好的操作系统服务，这样效率很高。一个典型的系统调用是从一个文件中读取数据。这一层增加的系统调用是由运行在指令系统层上的操作系统解释执行的。当一个用户程序执行一个系统调用时，比如从一个文件中读取数据，操作系统将一步步地执行这个调用。但是，那些和第2层指令相同的本层指令将直接交给微体系结构层执行，而不是由操作系统执行。换句话说，本层的新增指令由操作系统解释，而其他指令由微体系结构层直接执行，因此又将本层称为“混合层”。<br>这一层并不是为普通程序员的使用而设计的，主要是为支持高层所需的解释器或翻译器运行而设计的。</p></li><li><p>汇编语言层<br>微体系结构层可看作指令系统层指令的解释器，使指令系统的功能得以实现。但是，直接用机器指令代码编程是非常困难的，而让微体系结构层直接执行高级语言也不是好办法。因此，人们为所有的计算机都设计了一个汇编语言层，它位于指令系统层、操作系统层与面向问题语言层之间。从这一层看去，每一种计算机都有一套自己的汇编语言、解释它的汇编器，以及相应的程序设计与开发方法。汇编语言层以及上层是提供给解决应用问题的应用程序员使用的。第1、2、3层提供的机器语言都是二进制代码，适合机器执行，但不容易被人理解。从第4层开始，其提供的语言是人们能理解的单词和缩略语。汇编语言实际就是“符号化”的机器语言，每一条汇编指令语句都对应一条机器语言指令，它是它是面向机器结构的语言。用汇编语言编写的程序先由汇编器翻译成机器语言程序，然后由微体系结构层解释执行。这一层支持上层的方法与低层不同。第2层和第3层主要用的是解释；而第4层和第5层通常用的是编译。</p></li><li><p>面向问题语言层<br>BASIC、C、C++、Java、LISP等</p></li></ol><h3 id="从语言功能角度划分层次结构"><a href="#从语言功能角度划分层次结构" class="headerlink" title="从语言功能角度划分层次结构"></a>从语言功能角度划分层次结构</h3><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/3.jpg"></p><p>如果将计算机功能描述为“能执行用某些程序设计语言编写的程序”，那么用户看到的就是上图的语言功能层次模型。计算机硬件的物理功能是执行机器语言，称为机器语言物理机，从这一级看到的是一台实际的机器。而用户看到的是能执行某种语言程序的虚拟机，即通过配置某种语言处理程序后所形成的一台计算机。<br>与机器语言最接近的是汇编语言，它的基本成分是与指令系统一一对应的用助记符描述的汇编语句。与算法、数学模型甚至自然语言接近的，称为高级语言，它具有较强的通用性，在这一范畴内已推出了多种通用的高级程序设计语言。针对某些特定应用领域与用户，也可使用某种专用语言，它们一般面向应用，如所要求解的问题。<br>大多数计算机都是先将用程序设计语言编写的程序翻译为机器语言，然后才能执行。一般是直接翻译为机器语言。但当高级语言较复杂时，也可能分级编译，即先翻译为层次低些的某种中间语言，再将中间语言进一步翻译为机器语言，如上图虚线所示。<br>所谓虚拟机，通常是指通过配置软件（如某种语言的编译器或解释器）扩充机器功能后所形成的一台计算机。实际硬件在物理功能级上并不具备这种机器功能，因而称为虚拟机。采用虚拟机概念是计算机设计中的又一重要策略，它将提供给用户的功能抽象出来，使其脱离具体的物理机器，这有利于让用户摆脱真实物理机细节的束缚，获得超越物理机的功能。<br>广泛使用的Java虚拟机（JavaVirtualMachine，JVM）的概念。为了使Java程序能在不同的计算机上运行，Sun公司定义了一种称为Java虚拟机的虚拟体系结构。它有32位字组成的内存，能执行226条指令。大多数指令都很简单，只有一些比较复杂，需要多次内存循环。</p><h3 id="软硬件逻辑上等价"><a href="#软硬件逻辑上等价" class="headerlink" title="软硬件逻辑上等价"></a>软硬件逻辑上等价</h3><p>如果说系统设计者必须关心软、硬件之间的界面，即哪些功能由硬件实现，哪些由软件实现；用户则更关心系统究竟能提供哪些功能。至于这些功能是由硬件还是软件实现，在逻辑功能上则是等价的，只是执行速度有差别而已。</p><h3 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h3><ul><li><p>基本字长</p></li><li><p>数据通路宽度</p></li><li><p>运算速度</p></li><li><p>主存储器容量</p></li><li><p>外存容量</p></li><li><p>配置的外围设备及其性能</p></li><li><p>系统软件配置</p></li></ul><h3 id="提高计算机性能的若干技术"><a href="#提高计算机性能的若干技术" class="headerlink" title="提高计算机性能的若干技术"></a>提高计算机性能的若干技术</h3><ul><li><p>提高单CPU性能的若干技术<br>（1）流水线处理技术<br>（2）RISC（精简指令系统计算机）技术<br>（3）超标量技术<br>（4）平衡不同子系统的数据吞吐率</p></li><li><p>并行计算机</p></li></ul><h3 id="精简指令集计算机（RISC）"><a href="#精简指令集计算机（RISC）" class="headerlink" title="精简指令集计算机（RISC）"></a>精简指令集计算机（RISC）</h3><ul><li>概念</li></ul><p>随着超大规模集成电路VLSI技术的迅速发展，计算机系统的硬件成本不断下降，而软件成本却在不断上升。因此，人们热衷于在指令系统中增加更多的指令和更复杂的指令，以适应不同应用领域的需要，并考虑尽量缩短指令系统与高级语言之间的语义差异，以便于实现高级语言的编译和降低软件成本。另外，为了维护系列机的软件兼容性，也使指令系统变得越来越庞大。在系列机中，为了使老用户在软件上的投资不受损失，新机型必须继承老机器指令系统中的全部指令，这种情况使同一系列计算机的指令系统越来越复杂。一般来说，人们在计算机设计方面的传统想法和做法是：字长愈长、性能愈高的计算机，其指令系统就应该愈复杂，按这种传统方法设计的计算机系统称为复杂指令系统计算机，简称CISC。指令系统很复杂、功能很强并不一定能提高机器的速度，CISC中采用很多复杂的寻址方式，为了计算有效地址需花费一定的时间；有的指令需要多次访问主存储器，所以执行速度会降低。</p><p>复杂指令系统的实现需要复杂的控制器来支持，并且系列机为实现兼容，其控制部件多用微程序控制方式来实现，以便于指令系统的扩展。但微程序控制部件执行一条机器指令通常需要几个微周期，因此严重降低了指令的执行速度。为了提高指令的执行速度，CISC中常采用流水线技术。但由于存在很多问题，例如指令系统采用变字长指令、不同指令争用共同资源以及转移指令等，使流水线的效率不高。以上情况表明，传统的CISC设计思想并不利于提高计算机的速度。而且复杂的指令系统必然增加硬件实现的复杂性，从而使计算机的研制周期长、投资大。因此人们开始研究指令系统的合理性问题。对CISC指令系统运行的统计分析表明，各种指令的使用频率相差悬殊，最常用的是一些比较简单的指令，仅占指令总数的20%，但在程序中出现的频率却占80%。1975年，IBM公司提出了精简指令系统的想法。后来美国加利福尼亚大学伯克利分校的RISCI和RISCII、斯坦福大学的MIPS机的研制成功，为精简指令系统计算机（简称RISC）的诞生与发展起了很大作用。</p><ul><li>RISC的特点</li></ul><p>精简指令系统计算机的着眼点不是简单地放在简化指令系统上，而是通过简化指令使计算机的结构更加简单合理，更易于流水线的实现，从而提高处理速度。<br>  （1）面向寄存器的结构所有运算使用的数据都来自寄存器，运算结果也都写入寄存器。寄存器的典型长度是32位或64位。通常CPU内应设置大量的通用寄存器，以减少访问主存储器。<br>  （2）采用LOAD&#x2F;STORE结构<br>  （3）较少的指令数和寻址方式<br>  选取使用频率最高的一些简单指令，以及很有用但不复杂的指令，可简化控制部件。选用简单的寻址方式，有利于减少指令的执行周期数。<br>  （4）所有指令长度相同<br>  （5）硬布线控制逻辑<br>  （6）注重编译的优化<br>  RISC指令系统的简化，必然使编译生成的代码长度增长。但通过编译优化技术，将编译初步生成的代码重新组织，调度指令的执行次序，以充分发挥内部操作的并行性，从而进一步提高流水线的执行效率。虽然编译优化技术使编译时间拉长，但这种代价的结果是使程序的执行时间缩短。而且程序的编译工作只需一次，编译后生成的优化执行代码却可以高效率地执行多次。因此这个代价是值得的。</p><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><p>在物理构成上，存储系统通常分为3层：高速缓冲存储器Cache、主存和外存。Cache与主存常由半导体存储器构成；外存常由磁盘及光盘构成，也可以看作是I&#x2F;O设备。一个高性能的计算机系统要求存储器的存储容量大，存取速度快，成本低廉，能支持复杂系统结构。这些要求往往相互矛盾，彼此形成制约。因此在一个计算机系统中，常采用几种不同的存储器，构成多级存储体系，以适应不同层次的需要。通常，对CPU直接访问的一级，其速度尽可能快些，而容量相对有限；作为后援的一级其容量尽可能大些，而速度可以相对慢些。经过合理的搭配和组织，对用户来说，整个存储系统能够提供足够大的存储容量和较快的存取速度。<br>从用户的角度看，存储器还可以形成另一种层次结构，即物理存储器与虚拟存储器。物理存储器是指系统的物理组成中实际存在的主存，主存容量决定了实存空间的大小。在高档计算机中，依靠操作系统的软件支持及部分硬件的支持，可以使用户访问的编程空间远比实际主存空间大，用户感觉自己可编程访问一个很大的存储器，这个存储器称为虚拟存储器。</p><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><ul><li><p>按存储器在计算机系统中的作用分类<br>（1）内部存储器内部存储器（简称内存或主存）是计算机主机的组成部分，用来存储当前运行所需要的程序和数据，CPU可以直接访问内存并与其交换信息。相对外部存储器而言，内存的容量小、存取速度快。由于CPU要频繁地访问内存，所以内存的性能在很大程度上影响了整个计算机系统的性能。<br>（2）外部存储器外部存储器也称辅助存储器或后援存储器，简称外存或辅存。外存用于存放当前不参加运行的程序和数据，以及一些需要永久保存的信息。外存设在设在主机外部，其容量大，但存取速度相对较慢，CPU不能直接访问它，而必须通过专门的设备才能对它进行读写（如磁盘驱动器等），这是它与内存之间的一个本质区别。<br>（3）高速缓冲存储器高速缓冲存储器（Cache）位于主存和CPU之间，用来存放正在执行的程序和数据，以便CPU能高速地访问它们。Cache的存取速度可以与CPU的速度相匹配，但其价格昂贵，存储容量较小。目前的微处理器通常将Cache或Cache的一部分制作在CPU芯片中。</p></li><li><p>按存取方式分类<br>（1）随机存取存储器RAM（RandomAccessMemory）随机存取存储器是可读可写的存储器，CPU可以对RAM单元的内容随机地读&#x2F;写访问，对任一单元的读出和写入的时间是一样的，即存取时间相同，并且与存储单元在存储器中所处的位置无关。RAM读&#x2F;写方便，使用灵活，但断电后信息会丢失。RAM主要用作主存，也可用作高速缓存。<br>（2）只读存储器ROM（ReadOnlyMemory）只读存储器可以看作RAM的一种特殊形式，其特点是：存储器的内容只能随机读出而不能写入。这类存储器用来存放那些不需要改变的信息。由于信息一旦写入存储器就固定不变了，即使断电信息也不会丢失，所以又称它为固定存储器。ROM除了存放某些系统程序外，还用来存放专门的子程序，或用作函数发生器、字符发生器及微程序控制器中的控制存储器。有些ROM在特定条件下用特殊的装置或程序可以重新写入。<br>（3）顺序存取存储器SAM（SequentialAccessMemory）顺序存取存储器的存取方式与前两种完全不同，它的内容只能按某种顺序存取，存取时间的长短与信息在存储器上的物理位置有关，所以SAM只能用平均存取时间作为衡量存取速度的指标。磁带机就是典型的顺序存取存储器。<br>（4）直接存取存储器DAM（DirectAccessMemory）直接存取存储器既不像RAM那样能随机地访问存储器<br>存储器的任何一个存储单元，也不像SAM那样完全按顺序存取，而是介于两者之间。存取信息时，第1步直接指向存储器的某个小区域（如磁盘上的磁道）；第2步在小区域内顺序检索或等待，直到找到目的地后再进行读&#x2F;写操作。这种存储器的存取时间也与信息所在的物理位置有关，但比SAM的存取时间要短。磁盘是最常见的直接存取存储器。</p></li><li><p>按存储介质分类<br>（1）磁芯存储器<br>（2）半导体存储器<br>（3）磁表面存储器<br>（4）光盘存储器</p></li><li><p>按信息的可保存性分类<br>断电后存储信息即消失的存储器，称为易失性存储器或挥发性存储器，RAM是易失性存储器。断电后信息仍然保存的存储器，称为非易失性存储器，也称为非挥发性存储器或永久性存储器，ROM、磁芯存储器、磁表面存储器和光盘存储器都是非易失性存储器。</p></li></ul><h4 id="主存的主要技术指标"><a href="#主存的主要技术指标" class="headerlink" title="主存的主要技术指标"></a>主存的主要技术指标</h4><ul><li>存储容量</li><li>存取速度</li><li>可靠性</li><li>存取宽度</li></ul><h4 id="高速缓冲存储器Cache"><a href="#高速缓冲存储器Cache" class="headerlink" title="高速缓冲存储器Cache"></a>高速缓冲存储器Cache</h4><p>计算机系统整体性能的高低与许多因素有关，如CPU的主频、存储器的存取速度、系统架构、指令结构、信息在各部件之间的传送速度等。而CPU与主存之间的存取速度是一个很重要的因素。如果只是CPU工作速度很高，而主存的存取速度较低，就会造成CPU经常处于等待状态，既降低了处理速度，又浪费了CPU能力。为了减小CPU与主存之间的速度差异，现代微机中通常在慢速的DRAM和快速的CPU之间插入一个速度较快、容量较小的SRAM，起到缓冲作用，使CPU既能以较快速度存取SRAM中的数据，又不使系统成本上升过高，这就是Cache技术。</p><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/4.jpg"></p><p>由此可以想到，如果把一段时间内在一定地址范围中被频繁访问的信息集合成批地从主存读到一个能高速存取的小容量存储器中存放起来，供程序在这段时间内随时使用，从而尽量减少访问速度较慢的主存的次数，可以加快程序的运行速度，这就是Cache的设计思想，即在CPU和主存之间设置一个小容量的高速缓冲存储器（Cache）。  Cache中存放着最近要使用的程序与数据，作为主存中当前最急需执行信息的副本。其容量约为数KB到数百KB，由于容量较小，可以选用高速半导体存储器，使CPU访存速度得到提高。在高档微处理器中，在CPU芯片内集成了1～2个高速缓存，称为片内Cache，还允许在CPU芯片外扩充Cache。<br>有了Cache，系统在工作时总是不断地将与当前指令集相关联的一个不太大的后继指令集从主存读到Cache，然后再向CPU高速传送，从而达到速度匹配。当CPU需要访存时，同时将地址送往主存与Cache。若所需访问的内容已经在Cache中，则可直接从Cache中快速读取信息，这称为访问Cache命中；若访问的内容不在Cache中，即未命中，则从主存中读取信息，并考虑更新Cache，使其成为当前最急需部分。为此需要实现访存地址与Cache物理地址间的映像变换。<br>由于局部性原理不能保证所请求的数据百分之百地在Cache中，这里便存在一个命中率问题。所谓命中率，就是在CPU访问Cache时，所需信息恰好在Cache中的概率。命中率越高，正确获取数据的可能性就越大，目前Cache的访问命中率可达到90%以上。因此只要合理组织三级存储体系，从整体上讲，CPU就能以接近Cache的速度访问存储器，而总存储容量相当于联机外存的总容量。<br>一般来说，Cache的存储容量比主存的容量小得多，但不能太小，太小会使命中率太低。但也没有必要过大，过大不仅会增加成本，而且当Cache容量超过一定值后，命中率随容量的增加将不会有明显增长。所以Cache的空间与主存空间在一定范围内应保持适当比例的映射关系，以保证Cache有较高的命中率，且系统成本不会过多地增加。Cache的命中率与Cache的映像方式、替换算法、程序特性等因素有关。</p><h4 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h4><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/5.jpg"></p><p> 要真正解决存储器的容量、速度、价格之间的矛盾，不能只是将上面的各个层次的存储器进行简单组合，必须在系统结构上采取措施，采用不同速度、不同容量和不同价格的多种存储器件，按层次组成存储系统。各个层次的存储器之间通过硬件和软件有机地结合成一个统一的整体，无需程序员的干预而由计算机自动地实现调度，向程序员提供足够大的存储空间，同时最大限度地与CPU速度相匹配。按这样的思想组成的存储层次结构，称为存储体系结构。<br>典型的三级存储体系结构，分为“高速缓存—主存—辅存”三个层次。现在的计算机系统大多具备这三级存储结构。三级存储体系又分为两个层次，高速缓存和主存之间形成Cache-主存层次，主存和辅存之间形成主存-辅存层次。 </p><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/6.jpg"></p><ul><li>Cache-主存层次　<br>通过辅助硬件将Cache和主存构成一个整体，如上图所示。从整体上看，该层次具有接近于Cache的存取速度、主存容量和平均位价格，解决了存储器高速与低成本之间的矛盾。这个层次完全由硬件实现，不受软件的干预，因此对所有程序员都是透明的。</li><li>主存-辅存层次　<br>随着操作系统和硬件技术的发展，利用附加硬件及存储管理软件，使主存和辅存构成一个整体，形成主存-辅存层次，如图上图所示。辅存只与主存交换信息，不能直接由CPU访问。从整体上看，该层次的存取速度接近于主存的存取速度，容量则接近于辅存的容量，而位价格也接近于廉价的辅存平均价格，从而解决了大容量和低成本之间的矛盾。三级存储体系结构的总的效果是：存取速度接近于Cache，存储容量接近于辅存容量，整体价格也比较合理。</li></ul><h4 id="磁盘冗余阵列"><a href="#磁盘冗余阵列" class="headerlink" title="磁盘冗余阵列"></a>磁盘冗余阵列</h4><p>廉价冗余磁盘阵列（RedundantArraysofInexpensiveDisk，RAID）是用多台磁盘存储器组成的大容量外存子系统，它是由多台磁盘机按一定规则（如分条、分块、交叉存取等）组合在一起构成的。通过阵列控制器的控制和管理，磁盘阵列系统能够将几个、几十个甚至几百个硬盘组合起来，使其容量高达几百GB甚至上千GB。其基础是数据分块技术，即在多个磁盘上交错存放数据，通过阵列控制器实现数据的并行、交叉存储或单独存储操作。由于阵列中的一部分磁盘存有冗余信息，一旦系统中某一磁盘失效，可以利用冗余信息重建用户数据。</p><ul><li>RAID0级（无冗余和无校验的数据分块）<br>数据分布在阵列中的所有磁盘上，与单个大容量磁盘相比，它的显著优点是：如果两个I&#x2F;O请求正在等待不同的数据块，则被请求的块有可能在不同的盘上。因此，两个请求能够并行发出，减少了I&#x2F;O的排队时间。RAID0级具有最高的I&#x2F;O性能和磁盘空间利用率，但无容错能力，增加了系统出故障的几率。若阵列中有一块磁盘损坏，将造成不可弥补的损失。其安全性甚至低于常规的硬盘系统，所以不适于对数据稳定性要求高的应用。</li><li>RAID1级（镜像磁盘阵列）<br>由磁盘对组成，每个工作盘都有对应的镜像盘，上面保存着与工作盘完全相同的数据。如果镜像盘组中一个物理磁盘出现故障，系统可以使用未受影响的另一个磁盘继续操作，数据不会丢失，但磁盘空间的利用率只有50%。RAID1级的安全性高，而主要缺点是价格昂贵，它需要支持2倍于逻辑磁盘的磁盘空间。因此，RAID1级的配置只限于存储系统软件、数据和其他关键文件的驱动器中。在这种情况下，RAID1级对所有的数据提供实时备份，在磁盘损坏时，所有的关键数据仍立即可用。</li><li>RAID2级（具有纠错海明码的磁盘阵列）</li><li>RAID3、4、5、6、7级</li><li>RAID10级（RAID0级+RAID1级）<br>这是一种复合的RAID模式，将RAID0的速度与RAID1的冗余特性相结合，既可提供数据分块，又能提供镜像功能，是所有RAID中性能最好的磁盘阵列，但每次写入时要写两个互为镜像的盘，价格高。这种结构特别适用于既有大量数据需要存取，同时又对数据安全性要求严格的领域，如银行、金融、商业超市、仓储库房、各种档案管理等。</li></ul><h4 id="虚拟存储系统的组织"><a href="#虚拟存储系统的组织" class="headerlink" title="虚拟存储系统的组织"></a>虚拟存储系统的组织</h4><p>虚拟存储系统建立在主存-辅存层次上，是由附加硬件装置及存储管理软件组成的存储体系，它使计算机具有接近主存的存取速度，并具有辅存的容量和位成本。<br>在采用磁盘作为后援存储器后，可以在存储管理部件和操作系统存储管理软件的支持下，将主存和辅存的地址空间统一编址，使用户获得一个很大的编程空间，其容量大大超过实际的主存储器。这个在用户界面上看到的存储器，被称为虚拟存储器（VirtualMemory，VM），这样的虚拟存储技术对用户来说，自然是极有价值的，因而已在计算机系统中广泛使用，高档微处理器芯片也为此提供了有关硬件支撑。从用户界面看，用户可使用位数较长的编程地址进行编程，这种地址面向程序的需要，不必考虑程序将来在主存储器中的实际位置，因而称为逻辑地址。它是面向虚拟存储器的，所以又称为虚地址。在用户看来，CPU可按虚地址访问一个很大的存储器，其容量甚至可达整个辅存容量，显然这是一种虚拟层次。<br>在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前急需运行的部分调入主存，供CPU操作，其余暂不运行部分留在磁盘中，随程序执行的需要，操作系统自动地按一定替换算法进行调度，将当前暂不运行部分调回磁盘，将新的模块由磁盘调入主存。这一层次上的工作，对用户是透明的。CPU执行程序时，需将程序提供的虚地址变换为主存的实际地址（实地址、物理地址）。一般是先由存储管理部件判断该地址的内容是否在主存中，若已调入主存，则通过地址变换机制将虚地址转换为实地址，然后访问主存单元；若尚未调入主存，则通过缺页中断程序，以页为单位调入或实现主存内容调换。从原理上看，虚拟存储器与Cache-主存层次有很多相似之处，如地址映像方式和替换策略。但是，Cache-主存层次的控制完全由硬件实现，它对各类程序员都是透明的；而虚拟存储器的控制是由硬件与软件结合实现，对应用程序员来说是透明的，但对于设计存储器管理软件的系统程序员来说是不透明的。</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>计算机组成基本概念入门。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>别人不说,你一定要懂的人情世故</title>
    <link href="/2022/10/28/%E5%88%AB%E4%BA%BA%E4%B8%8D%E8%AF%B4-%E4%BD%A0%E4%B8%80%E5%AE%9A%E8%A6%81%E6%87%82%E7%9A%84%E4%BA%BA%E6%83%85%E4%B8%96%E6%95%85/"/>
    <url>/2022/10/28/%E5%88%AB%E4%BA%BA%E4%B8%8D%E8%AF%B4-%E4%BD%A0%E4%B8%80%E5%AE%9A%E8%A6%81%E6%87%82%E7%9A%84%E4%BA%BA%E6%83%85%E4%B8%96%E6%95%85/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《别人不说，你一定要懂的人情世故》 墨墨 北京理工大学出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li><p>不能主动去接触他人，人脉关系必定不广，人生路程也不会走得太顺遂，唯有怀着主动之心，你才能广交天下的朋友。</p></li><li><p>在职场里，要求我们在即使没有功利、没有收益的时候也要给别人以支持、给人以帮助，更不能砸别人的场面。</p></li><li><p>批评最好能单独进行，如果在公共场合批评，那就太伤你下属的感情了，这样做的结果是让你的下属成为你的刺儿头。如果能单独进行，即使其他人知道，你的下属也会好过点儿。</p></li><li><p>自己身居要职，就注定了要被批评，与其困扰于被批评，还不如想办法习惯它。</p></li><li><p>多在背后赞美，多在第三者面前赞美，是融洽人际关系的好方法。懂得人情世故的人会选择在背后赞美，通过间接的方式让人接受赞美，不仅避免了当面说好话的尴尬，还能够放大赞美的效果，从而达到润滑彼此关系的目的。</p></li><li><p>我们要尽量避开背后议论、评价他人，若迫不得已参与评论，则应多说一些中肯的话，而要避免说坏话。如果可能的话，最好避开背后议论他人，无论你是说好话还是说坏话。</p></li><li><p>在做事情的时候，将丑话说在前头，能够让人的态度更加认真和慎重，而不会掉以轻心、马虎了事。同时，也能够避免一些纠纷。丑话虽然不受听、扎耳朵，但却是超越流俗、突破情面把本相说到底、把前景想周全，既重人情，更重信义的真话。</p></li><li><p>多聊对方关心和得意的事，是懂得人情世故的做法，但是有不少人不懂得这其中的道理，常常从自身的爱好出发，说自己喜欢的话题，聊自己得意的事，结果让对方缺乏兴趣，甚至不耐烦。所以在与人交流时，尽可能地忘掉自己，不要总是谈自己的事情，你的生活引不起别人的兴趣。</p></li><li><p>如果有人请求你的帮助，即便对方的困境纯属咎由自取，你也不要说他的不是。你可以说自己无能为力，并拒绝他的请求，但不要指责他。请求帮助，承认自己是一个弱者，这已经是丢面子的事情了，如果你还进一步指责对方，则会让对方的脸色更加难看。</p></li><li><p>与人处事就如同下一盘象棋，只有那些阅历不深的人才会一口气赢对方七八盘，让对方抬不起头。事实上人们交际，彼此之间并非比赛，对输赢不必那么认真，主要目的是交流感情，增进友谊，进而发展合作共进的关系。</p></li><li><p>做人要有胸怀，特别是与人相交，不能整日计较鸡毛蒜皮的小事，枉费了许多时间和精力。在生活中应该多理解，在工作上应该多宽容，在待人上应该多温和，在处事上应该多大度。这样的处世原则将让你的朋友如沐春风。</p></li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>内容较多，多思考，多实践，多反思。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小狗钱钱</title>
    <link href="/2022/10/28/%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1/"/>
    <url>/2022/10/28/%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《小狗钱钱》 舍费尔 四川少年儿童出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>永远不要在背后说别人的坏话</li><li>不能总是抱怨命运的不公。在我们的生活中不是所有的事情都是公平的，不公平的情况很常见。但这并不意味着你就应该放弃，因为成功并不取决于你是否受到了公平的对待</li><li>尊重他人和对人有礼貌是成功的重要因素。如果有人不喜欢你，很大程度上是因为你表现得不够友好。这会损害一个人的声誉，所以你不能那么做。另外，彬彬有礼也可以让以前并不信任你的人接纳</li><li>我们推崇一种聪明的、简朴的生活方式。也就是说，宁愿购买一件一流产品，也不要不停地买许多的二流产品。而且，不要仅仅因为一件产品的外观不再时髦而新产品正在流行，就不断追逐新鲜的东西。生活质量不是由越来越多的高科技产品堆砌而成的，而体现在一些别的方面，比如悠闲地享受一下生活，增进邻里关系，表达感情或者从事艺术性和创造性的活动。</li><li>出于分散风险的考虑，你应该把一部分钱投资在绝对安全的地方，应该始终储备一些现金。决不能把你全部的钱都投资在股票或者基金上面。</li><li>只有当你把股票实际卖出的时候，才会有损失。</li><li>没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>理财启蒙书籍，不过书中除了理财的其他的内容也具有一定的启发意义，以后可以让小朋友读一读。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法记录</title>
    <link href="/2022/10/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/10/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start , <span class="hljs-type">int</span> end)</span>&#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt;= <span class="hljs-number">1</span> || start &gt;= end)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> end;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums[i];<br>    <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>        <span class="hljs-keyword">while</span> (nums[j] &gt;= target &amp;&amp; i &lt; j)&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>            nums[i] = nums[j];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (nums[i] &lt;= target &amp;&amp; i &lt; j)&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>            nums[j] = nums[i];<br>            j--;<br>        &#125;<br>        nums[i] = target;<br>    &#125;<br>    quickSort(nums, start, i - <span class="hljs-number">1</span>);<br>    quickSort(nums, i + <span class="hljs-number">1</span>, end);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="力扣215–数组中的第K个最大元素"><a href="#力扣215–数组中的第K个最大元素" class="headerlink" title="力扣215–数组中的第K个最大元素"></a>力扣215–数组中的第K个最大元素</h2><ul><li>题目</li></ul><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><ul><li>堆排序</li></ul><p>利用优先队列来实现堆排序，时间复杂度 O(NlogK)，空间复杂度 O(K)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; k; i++)&#123;<br>            q.add(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; q.peek())&#123;<br>                q.add(nums[i]);<br>                q.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>快速选择法</li></ul><p>化用于快排，时间复杂度最差为O(N^2)，时间复杂度期望为O(N)，空间复杂度O(1)，对于不随机样本，可以人为加入随机选择的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        k = nums.length - k;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> setP(nums, l, r);<br>            <span class="hljs-keyword">if</span> (p == k)&#123;<br>                <span class="hljs-keyword">return</span> nums[p];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p &lt; k)&#123;<br>                l = p + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = p - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">setP</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-comment">//在样本不具备随机性的情况下，可以人为加入随机性，提高计算效率</span><br>        <span class="hljs-comment">//int tempI = (int)(Math.random() * (r - l)) + l;</span><br>        <span class="hljs-comment">//int tempV = nums[l];</span><br>        <span class="hljs-comment">//nums[l] = nums[tempI];</span><br>        <span class="hljs-comment">//nums[tempI] = tempV;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> r;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums[i];<br>        <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= target)&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= target)&#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>               nums[j] = nums[i];<br>               j--;<br>            &#125;<br>        &#125;<br>        nums[i] = target;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="力扣347–前-K-个高频元素"><a href="#力扣347–前-K-个高频元素" class="headerlink" title="力扣347–前 K 个高频元素"></a>力扣347–前 K 个高频元素</h2><ul><li>题目</li></ul><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。</p><ul><li>桶排序</li></ul><p>构建一个数组，将频数相同的元素放在同一个数组里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        List&lt;Integer&gt; resList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(k);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> k;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)&#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        List&lt;Integer&gt;[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123;<br>            <span class="hljs-keyword">if</span> (arr[entry.getValue()] == <span class="hljs-literal">null</span>)&#123;<br>                arr[entry.getValue()] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            &#125;<br>            arr[entry.getValue()].add(entry.getKey());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span> (arr[i] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr[i])&#123;<br>                resList.add(num);<br>                count--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>; <br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[resList.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; resList.size(); i++)&#123;<br>            res[i] = resList.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="力扣451–根据字符出现频率排序"><a href="#力扣451–根据字符出现频率排序" class="headerlink" title="力扣451–根据字符出现频率排序"></a>力扣451–根据字符出现频率排序</h2><p>类似347</p><h2 id="力扣75–颜色分类"><a href="#力扣75–颜色分类" class="headerlink" title="力扣75–颜色分类"></a>力扣75–颜色分类</h2><ul><li>题目</li></ul><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><ul><li>三向切分快速排序</li></ul><p>注意，one和zero交换后，one需要加一，以保障one始终在zero前面，否则会出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">zero</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, one = <span class="hljs-number">0</span>, two = nums.length;<br>    <span class="hljs-keyword">while</span> (one &lt; two) &#123;<br>        <span class="hljs-keyword">if</span> (nums[one] == <span class="hljs-number">0</span>) &#123;<br>            swap(nums, ++zero, one++);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[one] == <span class="hljs-number">2</span>) &#123;<br>            swap(nums, --two, one);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++one;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = t;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cyc2018.xyz/">https://www.cyc2018.xyz/</a></p><p>Leetcode</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胃靠养,肠靠清</title>
    <link href="/2022/10/09/%E8%83%83%E9%9D%A0%E5%85%BB-%E8%82%A0%E9%9D%A0%E6%B8%85/"/>
    <url>/2022/10/09/%E8%83%83%E9%9D%A0%E5%85%BB-%E8%82%A0%E9%9D%A0%E6%B8%85/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《胃靠养，肠靠清》李博 江苏凤凰科学技术出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>现代社会营养不良导致的疾病几乎消失了，取而代之的是营养过剩引起的各种疾病。所以，少吃一些，才是不浪费，才是对身体负责。</li><li>能真正起到保健作用的，就是自然天赐的食物、平和的内心，以及适度的运动。</li><li>垃圾食品中排在第一位的是油炸品，第二位是腌制品。</li><li>晚餐应该遵循“四少”，即少盐少油少脂肪少辣的基本原则。不要忽视每一餐饭，日积月累，影响深远。如果能做到这“晚餐四少”，就代表着我们离高血压、高血脂、胃食管反流和痔疮等一系列病症都远了很多。</li><li>不生气不代表憋着，而是要正确地疏导和发泄，这样才是对身体有利的，比如去旅游、参加户外活动等。</li><li>早餐的鸡蛋必不可少，可以吃烧饼，不要吃油条、油饼之类的，豆腐脑不如喝粥和豆浆。中午的肉类多吃一些牛肉，蔬菜可以考虑胡萝卜、西红柿、土豆及各种新鲜的绿叶菜。晚餐推荐豆粥，加入薏米、山药和红枣有利于慢性胃炎的恢复。</li><li>还是希望大家做个“有心人”，密切关注自己的身体情况，长时间不适时千万不要忍着，越早去医院诊断越好。</li><li>要想远离胃癌以及各种癌症，起码要做到以下3点：<br> ①保持心情舒畅，让身体的内分泌系统处于良性循环。②均衡饮食，避免胃癌的外界因素。还要特别说一句，不要乱吃补品。就算是维生素，也不是多多益善，过量进补有害无益。有研究表明，β-胡萝卜素摄入过量有引起胃癌的风险。③坚持体育锻炼，促进新陈代谢。</li><li>胆结石、胆囊炎这俩“坏小子”是怎么成长起来的？<br> 不吃早饭是“主犯”</li><li>与疾病化敌为友，或者和谐共处，是很多疾病治疗的思路。如果能够保持一个平静的心态，允许身体的不完美，完全可以生活得更好，不必纠结于每天与疾病的斗争。</li><li>推荐早晨起来先饮用一杯凉开水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。</li><li>强烈推荐有氧运动，有时运动治疗便秘的效果是您意想不到的。每周运动3次为宜，每次1小时。除以有氧运动为主外，还可以增加仰卧起坐等腹部局部锻炼。运动的强度以出汗30分钟以上为宜。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><ul><li>饮食方面的注意事项：避免油炸、腌制品；做饭少盐少油少脂肪少辣；早餐鸡蛋和豆浆配主食，中午建议牛肉和蔬菜，晚餐建议薏米、山药、红枣豆粥，吃八分饱；推荐早晨起来先饮用一杯温水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。</li><li>其他方面注意：坚持有氧锻炼；保持平和心态，适当旅游户外运动调整情绪；长期不适及时就医</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>养生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客备份</title>
    <link href="/2022/10/08/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/"/>
    <url>/2022/10/08/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>《基于GitHub和Hexo搭建博客》中总结了如何利用github和hexo搭建个人博客，但是github上上传的只是博客网站文件，像markdown笔记之类的源文件并没有备份，如果本地电脑坏了很难恢复以往的markdown笔记，所以需要连同markdown笔记在内的源文件都备份到github上。</p><h1 id="备份步骤"><a href="#备份步骤" class="headerlink" title="备份步骤"></a>备份步骤</h1><h2 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h2><p>在github上的博客所在仓库上创建一个用来备份的分支hexo，并且将其设置为默认分支。</p><h2 id="获取git信息文件"><a href="#获取git信息文件" class="headerlink" title="获取git信息文件"></a>获取git信息文件</h2><p>去桌面或者哪里随便一个地方，把刚刚的hexo分支给clone下来。然后剪切出里面的.git文件夹，复制到现在的博客文件夹中。</p><p><img src="/2022/10/08/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/git%E6%96%87%E4%BB%B6.png"></p><h2 id="添加-gitignore"><a href="#添加-gitignore" class="headerlink" title="添加 .gitignore"></a>添加 .<a href="https://so.csdn.net/so/search?q=gitignore&spm=1001.2101.3001.7020">gitignore</a></h2><p>用来在上传时候忽略一些文件，即不上传<code>.gitignore</code>中忽略的文件。如果有最好，没有的话自己手动添加。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.DS_Store</span><br>Thumbs<span class="hljs-number">.</span><span class="hljs-built_in">db</span><br><span class="hljs-built_in">db</span><span class="hljs-number">.</span>json<br>*.log<br>node_modules/<br><span class="hljs-meta">public</span>/<br><span class="hljs-meta">.deploy</span>*/<br></code></pre></td></tr></table></figure><p><strong>注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。</strong></p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>在hexo博客的根目录下执行</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git add .<br><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&quot;Backup&quot;</span><br><span class="hljs-variable">$ </span>git push origin hexo<br></code></pre></td></tr></table></figure><p>这样就备份完博客了且在Github上能看到两个分支(main和hexo)。</p><h2 id="备份习惯"><a href="#备份习惯" class="headerlink" title="备份习惯"></a>备份习惯</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hexo</span> clean<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;Backup&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span><br><span class="hljs-symbol">hexo</span> g<br><span class="hljs-symbol">hexo</span> d<br></code></pre></td></tr></table></figure><h1 id="恢复步骤"><a href="#恢复步骤" class="headerlink" title="恢复步骤"></a>恢复步骤</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>安装git 、nodejs，确保github公钥接入，参考《基于GitHub和Hexo搭建博客》</p><h2 id="克隆项目到本地"><a href="#克隆项目到本地" class="headerlink" title="克隆项目到本地"></a>克隆项目到本地</h2><p>输入下列命令克隆博客必须文件(hexo分支)：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://xxxxx(详见仓库链接)<br></code></pre></td></tr></table></figure><h2 id="博客恢复"><a href="#博客恢复" class="headerlink" title="博客恢复"></a>博客恢复</h2><p>在clone下来的那个文件夹里面执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> npm install hexo<span class="hljs-literal">-cli</span><br><span class="hljs-variable">$</span> npm install<br><span class="hljs-variable">$</span> npm install hexo<span class="hljs-literal">-deployer-git</span> –save<br><span class="hljs-variable">$</span> <span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span> .deploy_git<br></code></pre></td></tr></table></figure><p>然后再去安装原来安装的一些插件。**在此不需要执行hexo init这条指令，因为不是从零搭建起新博客。</p><p>后续正常写博客，执行以下命令即可</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">hexo <span class="hljs-built_in">n</span> xx<br>hexo <span class="hljs-built_in">clean</span><br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/NoMasp/article/details/79504699">【Hexo异常】fatal: in unpopulated submodule ‘.deploy_git’_nomasp的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_21040559/article/details/109702142"> Hexo博客的备份_fFee-ops的博客-CSDN博客_hexo备份</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习整理</title>
    <link href="/2022/09/25/git%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/"/>
    <url>/2022/09/25/git%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><p>版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add 文件名</code>，注意，可反复多次使用，添加多个文件，此时文件放到了缓存区；</li><li>使用命令<code>git commit -m &quot;提交信息&quot;</code>，完成，此时文件从缓存区被放到了head指定的当前分支中。</li></ol><h1 id="查看工作区状态与提交修改"><a href="#查看工作区状态与提交修改" class="headerlink" title="查看工作区状态与提交修改"></a>查看工作区状态与提交修改</h1><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p><p>如果git status告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p><p>提交修改与添加文件的步骤一样</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">add</span> 文件名<br>git <span class="hljs-keyword">commit</span> -m &quot;add a line&quot;<br></code></pre></td></tr></table></figure><p>将暂存区的版本提交到版本库,从而形成工作区-&gt;暂存区-&gt;版本库的基本链路,本地工作区的版本控制流程大致如此.</p><h1 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h1><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>（commit_id可以输入前几位就行）。</p><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p><h1 id="多次修改"><a href="#多次修改" class="headerlink" title="多次修改"></a>多次修改</h1><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p><h1 id="修改撤销"><a href="#修改撤销" class="headerlink" title="修改撤销"></a>修改撤销</h1><ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD</code> ，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<strong>版本切换</strong>一节，不过前提是没有推送到远程库。</li></ul><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><p>如果在本地删除了文件，可以通过以下操作在git库里删除  </p><p><code>git rm test.txt</code>  </p><p><code>git commit -m &quot;remove test.txt&quot;</code>  </p><p>可以通过以下操作恢复，相当于是让工作目录test.txt恢复到暂存区中test.txt的状态</p><p><code>git checkout -- test.txt</code></p><h1 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h1><p><strong>git连接GitHub的操作可以见《Windows环境基于GitHub和Hexo搭建个人博客》的2.2节</strong></p><p>把本地库的内容推送到远程，用git push命令，实际上是把指定分支推送到远程。  </p><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><ol><li><p>要关联一个远程库，使用命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git remote <span class="hljs-keyword">add</span> origin git@<span class="hljs-keyword">server</span>-<span class="hljs-type">name</span>:<span class="hljs-type">path</span>/repo-<span class="hljs-type">name</span>.git<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git remote <span class="hljs-keyword">add</span><span class="language-bash"> origin git@github.com:michaelliao/learngit.git</span><br></code></pre></td></tr></table></figure></li><li><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p></li><li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p></li></ol><h1 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h1><p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。以下是拉去默认分支的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> git@github.com:michaelliao/gitskills.git</span><br></code></pre></td></tr></table></figure><p>因为刚才推送到master分支，所以我们可以拉取master分支的内容</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:michaelliao/gitskills.git -b <span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。具体的<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>，加上–no-ff选项。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。  </p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="/2022/09/25/git%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/1829507-20220316234843811-601091411.png"></p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p><p>具体可以参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136">https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136</a></p><h2 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h2><p>开发一个新feature，最好新建一个分支，开发完可以合并到dev分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。</p><h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><p>多人协作的工作模式通常是这样：</p><ul><li>首先，可以试图用git push origin 推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！</li><li>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to origin&#x2F;。</li></ul><p>多人协作重点：</p><ul><li>查看远程库信息，使用git remote -v；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin&#x2F;branch-name，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin&#x2F;branch-name；</li><li>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</li></ul><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p><p>命令git tag -a -m “blablabla…”可以指定标签信息；</p><p>命令git tag可以查看所有标签。</p><p>命令git push origin 可以推送一个本地标签；</p><p>命令git push origin –tags可以推送全部未推送过的本地标签；</p><p>命令git tag -d 可以删除一个本地标签；</p><p>命令git push origin :refs&#x2F;tags&#x2F;可以删除一个远程标签。</p><h1 id="使用github"><a href="#使用github" class="headerlink" title="使用github"></a>使用github</h1><p>在GitHub上，可以任意Fork开源仓库，复制到自己的仓库；</p><p>自己拥有Fork后的仓库的读写权限；</p><p>可以推送pull request给官方仓库来贡献代码。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>vcs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win11中WSL2搭配ubuntu使用笔记</title>
    <link href="/2022/09/17/Win11%E4%B8%ADWSL2%E6%90%AD%E9%85%8Dubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/17/Win11%E4%B8%ADWSL2%E6%90%AD%E9%85%8Dubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在surface go 3上基于WSL2装了一个ubuntu玩玩，记录下相关信息</p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><p><a href="https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview">Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu</a></p><h2 id="WSL命令"><a href="#WSL命令" class="headerlink" title="WSL命令"></a>WSL命令</h2><ul><li>cmd键入以下命令以查看所有正在运行的WSL，然后按Enter：</li></ul><p><code>wsl --list --verbose</code></p><ul><li>cmd关闭所有的后台的linux虚拟机</li></ul><p><code>wsl --shutdown</code></p><ul><li>重新启动linux虚拟机</li></ul><p>如果需要重新启动Linux发行版，只需从开始菜单或使用<code>wsl --distribution DISTRO-NAME</code>命令在命令提示符下再次将其打开。请记住将DISTRO-NAME替换为发行版的实际名称。</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li>系统升级</li></ul><p><code>sudo apt update</code></p><p><code>sudo apt full-upgrade</code></p><ul><li>文件传输（图形化界面）</li></ul><p><code>explorer.exe .</code></p><ul><li>查看Linux内核版本命令</li></ul><p><code>cat /proc/version</code></p><ul><li>查看Linux系统版本</li></ul><p><code>cat /etc/issue</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview">Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu</a></p><p><a href="https://zhuanlan.zhihu.com/p/351880793">只需一条命令，快速在Windows 10上关闭Linux - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人生的智慧</title>
    <link href="/2022/09/11/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/"/>
    <url>/2022/09/11/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《人生的智慧》 阿图尔·叔本华 湖南人民出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>幸福的首要因素，甚至，一个人此生存在的主要意义，是由他的内在机制决定的；一个人内心满足与否，取决于他的情感、欲望和思想共同作用的结果，外在环境对人只起到了间接调节的作用。我们年轻时几乎意识不到的一点是，最高级最丰富且最持久的乐趣来源于思想，思想力量的强弱决定了乐趣大小。身外之物对幸福的影响太微弱，大多数无须为生计发愁的人们由于内在贫乏，跟那些生活在底层为生计奔波劳碌的人们一样的感觉不幸福。他们头脑空洞、想象力贫瘠、精神空虚，只好与跟自己相似的人为伍，正所谓“物以类聚，人以群分”——他们聚在一起追求消遣娱乐，纵情感官享受，最后以荒唐告终。</li><li>幸福的本质在于“人”，那么集中精力保持身体健康、培养能力，无疑要比一心积累财富更明智，但千万不要误以为我们就应该忽略掉对生活必需品的获取。身心健康是幸福的首要关键，最愚蠢的事就是牺牲自己的健康去追求任何其他一时的快活，不管是为了利益、升迁、学问还是名气，甚至为了转瞬即逝的感官乐趣糟蹋自己的健康，都是愚不可及的行为。</li><li>实际上，生活就像是钟摆一般，在这两端之间或激烈或温和地来回摇摆——要么痛苦，要么无聊，反正总有一项逃不掉。究其根源，痛苦和无聊是一种双重对立的存在，一是外部的或客观的，一是内在的或主观的。匮乏的环境和贫穷会导致痛苦；而一个人衣食无忧，那么他就会无聊。这样的不幸只能靠内在的力量，亦即精神财富来抵御。</li><li>人类有两大最常见的愚蠢，第一是“不是在他自身的本质中去寻求幸福，而是在别人看待‘他是什么’中求幸福”，就是说太在意别人的看法，为别人而活。第二是牺牲健康去谋求别的东西，不明白一个健康的乞丐比疾病的国王要幸福。“人是什么”比“人有什么”，要重要得多。在是否幸福这件事情上，个人的人格、气质、心态、信仰，比汽车、房子、珠宝等更为重要。也就是说，你的个性才是最宝贵的财富。你需要去追求物质、名誉，但你更需要追求的，是你独立而健康的个性。正是在这个意义上，叔本华才会说：“个性远比民族性更重要。最廉价的骄傲是民族骄傲，也就是所谓的‘民族自豪感’——如果一个人号称为他的国家或民族自豪，那只能说明他本身并没有什么可值得骄傲的，否则也不会抓着那些千百万人共有的东西引以为荣了。”</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>幸福的本质在于“人”。首先是需要保障身体健康，保持适当的锻炼，任何事情都要给健康让路，不管是利益、升迁、学问还是名气；其次需要持之以恒地提升内心精神境界并汲取知识，去观赏大自然的鬼斧神工和历史上的伟大成就，像雕琢艺术品一样构建自己的内心世界；不要过多地在意外界的看法，克制嫉妒等不良情绪，减少不必要的痛苦.</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书与做人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书与做人</title>
    <link href="/2022/09/11/%E8%AF%BB%E4%B9%A6%E4%B8%8E%E5%81%9A%E4%BA%BA/"/>
    <url>/2022/09/11/%E8%AF%BB%E4%B9%A6%E4%B8%8E%E5%81%9A%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《读书与做人》 季羡林 国际文化出版公司</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>除了马克思主义以外，古今中外一些所谓唯心主义哲学家的著作，他们的思维方式和推理方式，也要认真学习。百分之百的唯物主义哲学家和百分之百的唯心主义哲学家，都是没有的。“智者千虑，必有一失”。我们千万不要像过去那样把十分复杂的问题简单化和教条化。                                                                             </li><li>不能说假话，但也不必说真话。</li><li>遇事必须深思熟虑，先考虑可行性，考虑的方面越广越好。然后再考虑不可行性，也是考虑的方面越广越好。正反两面仔细考虑完以后，就必须加以比较，做出决定，立即行动。如果你考虑正面，又考虑反面之后，再回头来考虑正面，又再考虑反面，那么，如此循环往复，终无宁日，最终成为考虑的巨人，行动的侏儒。</li><li>最好能背诵几百首旧诗词和几十篇古文，让它们随时涵蕴于你们心中，低吟于你们口头。这对于你们的文学创作和人文素质的提高，都会有极大的好处。不管你们现在或将来是教书、研究、经商、从政，或者是专业作家，都是如此，概莫能外。</li><li>能够百分之六十为他人着想，百分之四十为自己着想，他就是一个及格的好人。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>哲学方面可以考虑以马克思主义为主，其他思想为辅，兼顾唯物主义和唯心主义；需要考虑说话的技巧，假话绝不说，真话不说全；做决定时，广泛考虑正反两面后果断做决定；考虑背一些诗词和古文。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书与做人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自控力</title>
    <link href="/2022/09/11/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    <url>/2022/09/11/%E8%87%AA%E6%8E%A7%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《自控力》 麦格尼格尔 印刷工业出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做</li><li>大多数心理学家和营养学家推荐低血糖饮食，因为它能让你的血糖稳定。低血糖食品包括瘦肉蛋白、坚果和豆类、粗纤维谷类和麦片、大多数的水果和蔬菜。</li><li>美国心理学家协会的调查发现，最有效的解压方法包括：锻炼、阅读、听音乐、与家人朋友相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。最没效果的缓解压力的方法则包括：赌博、购物、抽烟、喝酒、暴饮暴食、玩游戏、上网、花两小时以上看电视或电影。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>书籍实用性不强，参照建议展开冥想确实对身心有一定帮助。冥想时间5-15分钟都可以，关键在于每日坚持。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何有效阅读一本书</title>
    <link href="/2022/09/11/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    <url>/2022/09/11/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《如何有效阅读一本书》 奥野宣之 江西人民出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>读书笔记的作用：随想笔记、购书清单、各种报道的剪报、读书笔记</li><li>过程中基本上是用不到笔记本的，读书时只需要画出重点做好记号，日后只需要确认想要落实的内容，记在读书笔记里就好</li><li>读书的过程：选书、购书、读书、笔记、活用</li><li>读书清单包括书名、作者、出版社、备注</li><li>在某种意义上，购书清单并不只是单纯的“购物备忘录”，而是为了促进主观购书的矫正装置</li><li>为了写出精练而深刻的读书笔记，你应该在读完一本书以后认真回想需要摘抄哪一页哪一行，思考怎样撰写读书笔记，然后严格地筛选需要摘抄的内容，尽量提炼自己的感想，争取用最短的语句表达深刻的含义</li><li>写读书笔记感想的时候，不要写一些揣测的或者外来的想法，而是因该写自己的心声</li><li>可以考虑定期进行读书笔记的重读工作</li><li>多使用参考书：·地图 ·图鉴 ·统计数据 ·百科全书 ·年表 ·词典</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>本书介绍了读书的一般流程和注意事项，关键点在于要有目的的读书，以做读书笔记为导向进行读书，精简读书笔记，适当重读活学活用。经过了一段时间的实践，对读书的流程、笔记的方法再次总结。</p><ol><li>阅读前言和目录，了解书籍的结构，通读全书，阅读时标记笔记</li><li>再次查看笔记，删除不重要笔记</li><li>整理读书笔记。首先梳理书籍的基本信息，例如书名、作者、出版社；然后基于目录整理全书脉络；摘录书籍中的重要笔记并将其分类；编写读后感，包括对全书的评价，相关的读后感等。</li></ol>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书与做人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows环境基于GitHub和Hexo搭建个人博客</title>
    <link href="/2022/09/06/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/09/06/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>周末参照网上教程基于GitHub和Hexo搭建个人博客，中间踩了不少的坑花了很多时间，所以将他人教程转载过来并加上一些修订内容记录下来。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="安装Node-js和Git"><a href="#安装Node-js和Git" class="headerlink" title="安装Node.js和Git"></a>安装Node.js和Git</h2><ul><li>Node.js：<a href="https://link.zhihu.com/?target=https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li><li>Git：<a href="https://link.zhihu.com/?target=https://git-scm.com/downloads">https://git-scm.com/downloads</a></li></ul><p>基于上面两个网站下载最新的Node.js和Git安装包，基于默认配置一路点下去安装Node.js和Git。安装完成后，在cmd中依次执行 <code>node -v</code>、<code>npm -v</code> 和 <code>git --version</code>，看到类似以下版本号说明安装成功</p><p><img src="/2022/09/06/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC.png"></p><h2 id="连接-Github"><a href="#连接-Github" class="headerlink" title="连接 Github"></a>连接 Github</h2><p>使用邮箱注册 <a href="https://link.zhihu.com/?target=https://github.com/">GitHub</a> 账户，选择免费账户（Free），并完成邮件验证。</p><p>在Windows桌面右键 -&gt; Git Bash Here，设置用户名和邮箱(此处的“GitHub 用户名”和”GitHub 邮箱”分别替换成个人的GitHub用户名和邮箱，下同）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> user.name <span class="hljs-string">&quot;GitHub 用户名&quot;</span><br>git config <span class="hljs-literal">--global</span> user.email <span class="hljs-string">&quot;GitHub 邮箱&quot;</span><br></code></pre></td></tr></table></figure><p><strong>创建 SSH 密匙</strong>：</p><p>输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车。</p><p><strong>添加密匙：</strong></p><p>进入 [C:\Users\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p><p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p><p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p><p><strong>验证连接：</strong></p><p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认。显示 “Hi xxx! You’ve successfully……” 即连接成功。如果没有出现“Hi xxx! You’ve successfully……”字样，可以再次输入 <code>ssh -T git@github.com</code>尝试。</p><h2 id="创建-Github-Pages-仓库"><a href="#创建-Github-Pages-仓库" class="headerlink" title="创建 Github Pages 仓库"></a>创建 Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p><ul><li>Repository name 中输入 <code>用户名.github.io</code></li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li></ul><p>填好后点击 Create repository 创建。</p><p>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p><h2 id="本地安装-Hexo-博客程序"><a href="#本地安装-Hexo-博客程序" class="headerlink" title="本地安装 Hexo 博客程序"></a>本地安装 Hexo 博客程序</h2><p>新建一个文件夹用来存放 Hexo 的程序文件，如 hexoblog。打开该文件夹，右键 -&gt; Git Bash Here。</p><p>使用 npm 一键安装 Hexo 博客程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>初始化并安装所需组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo init      # 初始化<br>npm install    # 安装组件<br></code></pre></td></tr></table></figure><p>完成后依次输入下面命令，启动本地服务器进行预览：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo g   # 生成页面<br>hexo s   # 启动预览<br></code></pre></td></tr></table></figure><p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p><h2 id="部署-Hexo-到-GitHub-Pages"><a href="#部署-Hexo-到-GitHub-Pages" class="headerlink" title="部署 Hexo 到 GitHub Pages"></a>部署 Hexo 到 GitHub Pages</h2><p>本地博客测试成功后就是上传到 GitHub 进行部署，使其能够在网络上访问。</p><p>首先安装 hexo-deployer-git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>然后修改hexo程序文件夹中的_config.yml文件末尾的 deploy部分(建议使用notepad++打开)，修改成如下（注意替换GitHub用户名）：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:用户名/用户名.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p><h2 id="博客图片问题处理"><a href="#博客图片问题处理" class="headerlink" title="博客图片问题处理"></a>博客图片问题处理</h2><p>本人采用开源软件MarkText软件进行本地博客编辑，该软件可以在GitHub下载。需要在本地编辑博客和上传部署后的博客上都正常阅览图片，需要安装一些插件来实现该需求，具体操作如下：</p><ul><li><p>在hexo主目录安装插件，在GitBash中输入：<code>npm install hexo-asset-image-for-hexo5 --save</code>  </p></li><li><p>在主目录的<code>_config.yml</code>文件中查找并修改<code>post_asset_folder</code>值为<code>true</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul><p>这样在使用<code>hexo new &quot;article&quot;</code>创建新博客文章的时候，就会发现在文章的同级目录出现和md文件名相同的文件夹，可以在这个文件夹中放该文章的图片，例如test.png。例：</p><table><thead><tr><th>1  <br>2  <br>3</th><th>├─article  <br>├──test.png  <br>└─article.md</th></tr></thead></table><ul><li>写法：在文章里即可使用<code>![](./article/test.png)</code>在本地显示图片<code>test.png</code>，同时在静态网页中也可以正常显示。</li></ul><p><strong>注意：</strong>本文的hexo版本为6.2.0（可以通过hexo v查看），这里安装的图像插件为hexo-asset-image-for-hexo5是适用的（hexo5版本以上建议使用 hexo-asset-image-for-hexo5 ），网上绝大部分博客说的<code>npm install hexo-asset-image --save</code>经本人测试并不适配6.2.0版本的hexo。</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p><strong>发布文章</strong></p><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo new &quot;My New Post&quot;<br></code></pre></td></tr></table></figure><p>然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用MarkText在该文件中撰写文章了。</p><p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。<strong>以后每次发布文章都是这三条命令。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo clean   # 清除缓存和已生成的静态文件<br>hexo g   # 生成页面<br>hexo d   # 部署发布<br></code></pre></td></tr></table></figure><p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo clean、hexo g</code> 和 <code>hexo d</code> 发布。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: Hello World # 标题<br>date: 2019/3/26 hh:mm:ss # 时间<br>categories: # 分类<br><span class="hljs-bullet">-</span> Diary<br>tags: # 标签<br><span class="hljs-bullet">-</span> PS3<br><span class="hljs-section">- Games</span><br><span class="hljs-section">---</span><br><br>摘要<br>&lt;!--more--&gt;<br>正文<br></code></pre></td></tr></table></figure><p><strong>处理草稿</strong></p><p>输入如下命令新建一个草稿文件，其中<title>替换成草稿标题，实际运行可以知道新建的草稿文件存放在&#x2F;source&#x2F;_drafts路径下</title></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> draft &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>输入如下命令将草稿转成正式文章，该命令会把&#x2F;source&#x2F;_drafts下的文章移到&#x2F;source&#x2F;_posts下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>在 <a href="https://link.zhihu.com/?target=https://hexo.io/themes/">Themes | Hexo</a> 选择一个喜欢的主题，并参照主题的文档来安装和配置主题。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo new &quot;name&quot;       # 新建文章<br>hexo new page &quot;name&quot;  # 新建页面<br>hexo g                # 生成页面<br>hexo d                # 部署<br>hexo g -d             # 生成页面并部署<br>hexo s                # 本地预览<br>hexo clean            # 清除缓存和已生成的静态文件<br>hexo help             # 帮助<br>hexo new draft &quot;title&quot; #创建草稿布局文章的命令<br>hexo publish &quot;title&quot;  # 将草稿发布为正式文章的命令<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p><p><a href="https://www.idealx.cn/post/Hexo/hexo-asset-image/">在Hexo中使用本地图片 - 个人学习 (idealx.cn)</a></p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo (github.com)</a></p><p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93524924">Hexo博客新建草稿</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
