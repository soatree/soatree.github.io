<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机组成原理与汇编语言程序设计</title>
    <link href="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《计算机组成原理与汇编语言程序设计（第4版）(高等学校规划教材)》 徐洁 电子工业出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><p>在早期，冯·诺依曼将计算机的硬件组成分为5大部件。几十年来，计算机硬件系统已有了许多重大变化。首先，现在采用的大规模及超大规模集成电路，可将运算器和控制器集成在一块芯片上，合称为中央处理器（CPU）。它是负责执行程序，实现运算处理，控制整个系统的部件。相应地，原来的运算器现在作为CPU中的运算部件（又称为算术逻辑部件），它与控制器之间的界限已不像原来那样分明。其次，存储器分为高速缓存、主存储器、外存储器三个层次。其中高速缓存常集成在CPU内部，作为CPU的一个部分，也可以在CPU之外再设置一级高速缓存。通常将CPU与主存储器合在一起称为主机，主存储器（简称主存）就是因为位于主机之内而得名，有的书中又称它为内存储器（内存）。位于主机之外的磁盘、光盘、磁带等，则作为外存储器（外存）。还有，输入设备的任务是将外部信息输入主机，输出设备则是将主机的运算处理结果或其他信息从主机输出。但从信息传送控制的角度看，它们并无多大区别，不过是传送方向不同而已。有些设备还兼有输入与输出两种功能，所以在描述系统结构时常将它们合称为输入&#x2F;输出设备，简称I&#x2F;O设备。 </p><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/1.jpg"></p><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>CPU（CentralProcessingUnit）即中央处理器，是硬件系统的核心部件，负责读取并执行指令，也就是执行程序。<br>在CPU中有一个程序计数器PC（ProgramCounter），它存放着当前指令所在存储单元的地址。如果程序是顺序执行，在读取一个或连续几个存储单元的指令代码后，PC的内容就加1或加几，以指出下一条指令的地址；如果程序需要转移，则将转移地址送入PC。因此，PC就像一个指针，指引着程序的执行顺序。虽然指令与数据都采用二进制代码表示，在外形上没有区别，但可按照PC中的中的地址信息去读取指令，再按照指令给出的操作数地址去读取数据。<br>CPU内有一个或多个算术逻辑部件ALU（ArithmeticLogicUnit）。通常按照指令的要求将有关数据送入ALU，进行指定的算术或逻辑运算，然后将运算结果送到主存单元，或暂存在CPU内的寄存器中。CPU内的主要部分是控制器（又称为控制部件），它的任务是控制整个系统的工作，决定在什么时候，根据什么，发出什么命令，做什么操作。例如它控制着从主存中读取指令，根据指令代码分时地发出一些最基本的控制信号即微命令，控制存储器的读写、ALU的运算处理、数据的输入&#x2F;输出等。按照产生微命令的方式不同，控制器可分为两大类：组合逻辑控制器及微程序控制器。<br>组合逻辑控制器完全靠若干组合逻辑电路（即硬件）产生微命令序列，将指令代码、状态信息、时序信号等输入到这些组合逻辑电路，电路将分时产生相应的微操作命令。这种控制器又称硬连逻辑控制器，其优点是形成微命令的速度快，常用于精简指令系统计算机（RISC）中。<br>微程序控制器是将微命令序列以代码形式编制成微程序，存入一个控制存储器中；当CPU执行指令时，通过读取并执行对应的一段微程序，产生微命令序列，控制完成指定的操作。微程序控制方式比较规整，硬件代价较小，易于扩充功能，但速度较慢。</p><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p>我们总是希望计算机系统中的存储器容量大，存取速度快，但这往往是有矛盾的，所以常将存储器分为几级。其中主存储器用半导体存储器构成，工作速度较高，也有一定的存储容量。外存储器为主存提供后援，由磁盘、光盘、磁带等构成，其存储容量很大，但速度较主存储器低。高速缓冲存储器、主存储器和外存储器，组合成一个完整的多级存储系统，使得整个系统既有很大的存储容量，而CPU又可以高速地访问存储器。主存储器用来存放需要执行的程序及需要处理的数据，能由CPU直接读出或写入。<br>主存储器的一项重要特性是：能按地址（单元编号）存放或读取内容，也就是允许CPU直接编址访问，通常以字节为编址单位。对主存储器来说，寻找存储单元（寻址）的依据是地址码，所存取的内容是指令或数据。</p><h3 id="外存储器"><a href="#外存储器" class="headerlink" title="外存储器"></a>外存储器</h3><p>外存储器用来存放那些需要联机存放，但暂不执行的程序和数据，当需要运行它们时再由外存调入主存。例如在光盘中存放着几个备用的软件，但当前暂时只用得着用得着其中的一个，我们先将它调入主存，其余软件仍存放在光盘上。又如一个信息管理系统所保存的数据很多，可将它们存放在磁盘之中，只将当前需要查询的部分调入主存，以后再调换。这样，主存的容量就不需要很大，可以做到速度比较快。而由磁盘、光盘等构成的外存储器容量很大，可为整个系统提供后援支持，其速度要求可以比主存低一些。<br>由于外存储器不由CPU直接编址访问，也就是说不需要按字节地从外存储器读取或写入，因此外存储器中的内容一般都按文件的形式进行组织，一个文件常分解为若干数据块，可以包含许多字节的信息。用户按文件名进行调用，CPU找到该文件在外存中的存放位置，以数据块为单位进行读写。</p><h3 id="输入-x2F-输出设备"><a href="#输入-x2F-输出设备" class="headerlink" title="输入&#x2F;输出设备"></a>输入&#x2F;输出设备</h3><p>计算机系统大多配备了键盘、鼠标、显示器、打印机等常规输入&#x2F;输出设备，简称I&#x2F;O设备。</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>怎样将CPU、主存、多台I&#x2F;O设备连接成整机系统呢？现在普遍采用总线结构。所谓总线是指一组能为多个部件分时共享的信息传输线。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>一台计算机系统需连接哪些I&#x2F;O设备，这要根据该系统的应用场合而定，因此通过系统总线连接的设备，其类型与数量都应当可以扩充。某种型号的计算机系统，其系统总线往往是标准的，也就是说，有多少根地址线、数据线，有哪些控制信号线，每个信号的名称及作用等，都是规定好的。</p><p>概括地说，计算机硬件系统是由三大子系统：CPU、存储系统（包括高速缓存、主存和外存）、输入&#x2F;输出系统（包括输入&#x2F;输出设备和接口），以及连接它们的总线构成。</p><h2 id="计算机软件系统"><a href="#计算机软件系统" class="headerlink" title="计算机软件系统"></a>计算机软件系统</h2><h3 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h3><ul><li><p>操作系统</p></li><li><p>编译程序与解释程序</p></li></ul><p>计算机硬件能够直接识别的是数字代码，所以让计算机硬件执行的基本命令，如传送、加、减等，必须用0、1这样的数字编码来表示。由硬件执行的程序的最终形态是由若干指令组成的序列，即指令是程序（可执行形态）的基本单位。一般地，一条指令规定了一种基本操作（如传送、加、减），并提供操作数地址或直接提供操作数，这些信息都由数字代码表示。一台计算机可以执行的各种指令的集合，称为这种计算机的指令系统。显然，不同的机型往往具有不同的指令系统，以及相应的指令格式约定，所以机器指令代码又称为机器语言，即面向特定机器结构的一种内部语言。<br>如果直接用机器语言（0、1代码）编制程序，将非常不便，于是人们想到用一些约定的符号，如英文缩写的字符串，去表示操作含义、操作数、地址等，这就产生了汇编语言。汇编语言是一种用符号表示的与机器指令基本对应的程序设计语言，它专属于某种机型或某种系列机，其他计算机不能直接使用，所以是一种面向机器结构的程序设计语言，不是通用语言。<br>为了便于编制程序，现在所使用的绝大多数编程语言是高级程序设计语言，这是一些面向用户，与特定机器属性相分离的语言。高级程序设计语言与机器指令之间没有直接的对应关系，所以它可以在各种机型中通用，编程者使用高级语言也不必了解具体的机器指令系统及其他硬件属性。高级程序设计语言需要遵循一定的严格语法规定与格式，才能为语言处理程序（编译、解释）所识别。<br>机器语言是机器内部使用的、用数字代码表示的指令代码，面向某一特定机型，可由硬件直接识别并执行。汇编语言是一种用符号表示的，面向某一特定机型的程序设计语言，它的指令语句与机器指令一一对应。高级程序设计语言则是面向用户，与特定机器属性相分离的程序设计语言，具有通用性。<br>大多数情况下，用户采用高级程序设计语言编写程序，个别情况采用汇编语言编写程序。用这些程序设计语言编写出的程序叫做源程序，它们由一些语句组成。将源程序输入计算机后，计算机先执行一种语言处理程序，将源程序转换为机器语言代码序列，即机器语言程序，然后由计算机硬件执行这些用机器语言代码表示的指令序列，从而完成用户程序的执行过程。这种语言处理程序也是一种必需的系统软件。<br>语言处理方式有两种类型：解释与编译。解释方式是边解释边执行，为此需要一种针对某种程序设计语言的解释程序（又称解释器）作为系统软件的组成部分之一。将源程序输入计算机后，启动并执行相应的解释程序，它的作用是逐步分析源程序中的语句，按照源程序描述的过程，执行一个与此等价的机器语言指令序列，直到整个源程序都被扫描一遍，并被解释执行完毕为止。这有点像口译外语的情形，边说边翻译。解释方式适用于比较简单的程序设计语言，如BASIC。它的优点是支持人机对话方式的程序设计，可以边执行边修改；所需要的主存空间较小。但是这种方式的执行速度较慢，不能解释那些前后关联较多、较难理解的程序设计语言。大多数程序设计语言采用编译方式。将源程序输入计算机后，先启动并执行相应的编译程序（又称编译器），将源程序全部翻译成目标程序（目标代码）的机器语言指令序列。执行时，计算机将直接执行目标程序，不再需要源程序与翻译程序。因此，这种编译方式有点像笔译，得到完整的译文后就可以不要原文与译者了。在编译过程中，它所需的主存空间比解释方式多些，既要容纳源程序又要容纳一个比较大的编译程序；需花费的时间也要长些。但运行用户程序时，所需的主存空间比较小，执行速度也较快。<br>将汇编语言源程序转换为机器代码的目标程序的过程也是一种编译，人们将它专门称为“汇编”，相应的翻译程序称为汇编程序（又称汇编器）。它的逆过程叫做“反汇编”，即将用机器代码表示的目标程序（指令序列）反汇编成用汇编语言描述的程序。为利于二次开发，在剖析一些已有的重要软件时，常常需要进行反汇编。</p><ul><li>各种软件平台</li></ul><h3 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h3><p>应用软件不胜枚举，它一般包括：①科学计算类；②数据处理类；③自动控制类；④计算机辅助设计类；⑤人工智能类；等等。</p><h2 id="计算机系统层次"><a href="#计算机系统层次" class="headerlink" title="计算机系统层次"></a>计算机系统层次</h2><h3 id="从计算机系统组成角度划分层次结构"><a href="#从计算机系统组成角度划分层次结构" class="headerlink" title="从计算机系统组成角度划分层次结构"></a>从计算机系统组成角度划分层次结构</h3><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/2.jpg"></p><ol><li><p>微体系结构层<br>微体系结构层是具体存在的硬件层次，在这一层我们看到的不是由大部件（即CPU、存储系统、输入&#x2F;输出系统及互连机构）构成的计算机，而是更细微的机器结构。微体系结构层执行机器指令，它可看作是指令系统层指令的解释器。在由微程序控制数据通路的计算机上，微程序就是上一层指令的解释器。它通过数据通路逐条对指令进行取指、译码和执行。例如，对加法ADD指令，将首先取出指令进行译码分析，然后找到操作数送入寄存器，由ALU求和，最后存结果。结果到指定地方，如某个存储器单元。而在硬件直接控制数据通路的计算机上，执行的步骤与此类似，但是由硬件直接解释执行指令，并不存在一个真正的程序来解释上一层的指令。</p></li><li><p>指令系统层<br>原则上，指令系统层是机器语言程序员眼中所看到的计算机，当然现在人们并不使用机器语言编程。指令系统层位于微体系结构层之上，是一个抽象的层次，其主要特征就是指令系统。指令系统（又称指令集）是指一台计算机所能执行的全部指令的集合。其指令是由微体系结构层的微程序解释执行或硬件电路直接执行的。<br>指令系统是计算机软件与硬件之间的一种接口。硬件系统的基本任务是实现指令系统所规定的各种指令功能，而各种程序只有最终转化为用机器语言（即代码表示的指令序列）才能被硬件执行。尽管现在已广泛应用各种高级语言编程，但需通过编译器或解释器将高级语言程序转换为硬件可以识别与执行的机器指令序列。<br>指令系统层定义了硬件和编译器之间的接口，它是一种硬件和编译器都能理解的语言。一方面，指令系统表明了一台计算机具有哪些硬件功能，是硬件逻辑设计的基础。因此，在指令系统层，应该定义一套在当前和将来的技术条件下能够高效率实现的指令集，从而使高效率的设计可用于今后的若干代计算机中。另一方面，指令系统层应该为编译器提供明确的编译目标，使编译结果具有规律性和完整性。</p></li><li><p>操作系统层<br>从程序员的观点来看，操作系统是一个在指令系统层提供的指令和特性之上又增加了新指令和特性的程序。这一层有新的指令集，有不同的存储器结构，有同时运行两个或多个程序的能力，以及其他一些特性。<br>尽管操作系统层和指令系统层都是抽象层次，但它们之间具有重要的区别。操作系统层指令集是系统程序员完全可用的指令集。它包括几乎所有的指令系统层的指令和操作系统层增加的新指令。这些新指令称为系统调用（SystemCall），如DOS操作系统的系统功能调用“INT21H”用于设备、文件和目录等管理，Linux操作系统的系统调用“fork()”用来创建一个进程。一个系统调用使用一条新指令调用一个预先定义好的操作系统服务，这样效率很高。一个典型的系统调用是从一个文件中读取数据。这一层增加的系统调用是由运行在指令系统层上的操作系统解释执行的。当一个用户程序执行一个系统调用时，比如从一个文件中读取数据，操作系统将一步步地执行这个调用。但是，那些和第2层指令相同的本层指令将直接交给微体系结构层执行，而不是由操作系统执行。换句话说，本层的新增指令由操作系统解释，而其他指令由微体系结构层直接执行，因此又将本层称为“混合层”。<br>这一层并不是为普通程序员的使用而设计的，主要是为支持高层所需的解释器或翻译器运行而设计的。</p></li><li><p>汇编语言层<br>微体系结构层可看作指令系统层指令的解释器，使指令系统的功能得以实现。但是，直接用机器指令代码编程是非常困难的，而让微体系结构层直接执行高级语言也不是好办法。因此，人们为所有的计算机都设计了一个汇编语言层，它位于指令系统层、操作系统层与面向问题语言层之间。从这一层看去，每一种计算机都有一套自己的汇编语言、解释它的汇编器，以及相应的程序设计与开发方法。汇编语言层以及上层是提供给解决应用问题的应用程序员使用的。第1、2、3层提供的机器语言都是二进制代码，适合机器执行，但不容易被人理解。从第4层开始，其提供的语言是人们能理解的单词和缩略语。汇编语言实际就是“符号化”的机器语言，每一条汇编指令语句都对应一条机器语言指令，它是它是面向机器结构的语言。用汇编语言编写的程序先由汇编器翻译成机器语言程序，然后由微体系结构层解释执行。这一层支持上层的方法与低层不同。第2层和第3层主要用的是解释；而第4层和第5层通常用的是编译。</p></li><li><p>面向问题语言层<br>BASIC、C、C++、Java、LISP等</p></li></ol><h3 id="从语言功能角度划分层次结构"><a href="#从语言功能角度划分层次结构" class="headerlink" title="从语言功能角度划分层次结构"></a>从语言功能角度划分层次结构</h3><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/3.jpg"></p><p>如果将计算机功能描述为“能执行用某些程序设计语言编写的程序”，那么用户看到的就是上图的语言功能层次模型。计算机硬件的物理功能是执行机器语言，称为机器语言物理机，从这一级看到的是一台实际的机器。而用户看到的是能执行某种语言程序的虚拟机，即通过配置某种语言处理程序后所形成的一台计算机。<br>与机器语言最接近的是汇编语言，它的基本成分是与指令系统一一对应的用助记符描述的汇编语句。与算法、数学模型甚至自然语言接近的，称为高级语言，它具有较强的通用性，在这一范畴内已推出了多种通用的高级程序设计语言。针对某些特定应用领域与用户，也可使用某种专用语言，它们一般面向应用，如所要求解的问题。<br>大多数计算机都是先将用程序设计语言编写的程序翻译为机器语言，然后才能执行。一般是直接翻译为机器语言。但当高级语言较复杂时，也可能分级编译，即先翻译为层次低些的某种中间语言，再将中间语言进一步翻译为机器语言，如上图虚线所示。<br>所谓虚拟机，通常是指通过配置软件（如某种语言的编译器或解释器）扩充机器功能后所形成的一台计算机。实际硬件在物理功能级上并不具备这种机器功能，因而称为虚拟机。采用虚拟机概念是计算机设计中的又一重要策略，它将提供给用户的功能抽象出来，使其脱离具体的物理机器，这有利于让用户摆脱真实物理机细节的束缚，获得超越物理机的功能。<br>广泛使用的Java虚拟机（JavaVirtualMachine，JVM）的概念。为了使Java程序能在不同的计算机上运行，Sun公司定义了一种称为Java虚拟机的虚拟体系结构。它有32位字组成的内存，能执行226条指令。大多数指令都很简单，只有一些比较复杂，需要多次内存循环。</p><h3 id="软硬件逻辑上等价"><a href="#软硬件逻辑上等价" class="headerlink" title="软硬件逻辑上等价"></a>软硬件逻辑上等价</h3><p>如果说系统设计者必须关心软、硬件之间的界面，即哪些功能由硬件实现，哪些由软件实现；用户则更关心系统究竟能提供哪些功能。至于这些功能是由硬件还是软件实现，在逻辑功能上则是等价的，只是执行速度有差别而已。</p><h3 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h3><ul><li><p>基本字长</p></li><li><p>数据通路宽度</p></li><li><p>运算速度</p></li><li><p>主存储器容量</p></li><li><p>外存容量</p></li><li><p>配置的外围设备及其性能</p></li><li><p>系统软件配置</p></li></ul><h3 id="提高计算机性能的若干技术"><a href="#提高计算机性能的若干技术" class="headerlink" title="提高计算机性能的若干技术"></a>提高计算机性能的若干技术</h3><ul><li><p>提高单CPU性能的若干技术<br>（1）流水线处理技术<br>（2）RISC（精简指令系统计算机）技术<br>（3）超标量技术<br>（4）平衡不同子系统的数据吞吐率</p></li><li><p>并行计算机</p></li></ul><h3 id="精简指令集计算机（RISC）"><a href="#精简指令集计算机（RISC）" class="headerlink" title="精简指令集计算机（RISC）"></a>精简指令集计算机（RISC）</h3><ul><li>概念</li></ul><p>随着超大规模集成电路VLSI技术的迅速发展，计算机系统的硬件成本不断下降，而软件成本却在不断上升。因此，人们热衷于在指令系统中增加更多的指令和更复杂的指令，以适应不同应用领域的需要，并考虑尽量缩短指令系统与高级语言之间的语义差异，以便于实现高级语言的编译和降低软件成本。另外，为了维护系列机的软件兼容性，也使指令系统变得越来越庞大。在系列机中，为了使老用户在软件上的投资不受损失，新机型必须继承老机器指令系统中的全部指令，这种情况使同一系列计算机的指令系统越来越复杂。一般来说，人们在计算机设计方面的传统想法和做法是：字长愈长、性能愈高的计算机，其指令系统就应该愈复杂，按这种传统方法设计的计算机系统称为复杂指令系统计算机，简称CISC。指令系统很复杂、功能很强并不一定能提高机器的速度，CISC中采用很多复杂的寻址方式，为了计算有效地址需花费一定的时间；有的指令需要多次访问主存储器，所以执行速度会降低。</p><p>复杂指令系统的实现需要复杂的控制器来支持，并且系列机为实现兼容，其控制部件多用微程序控制方式来实现，以便于指令系统的扩展。但微程序控制部件执行一条机器指令通常需要几个微周期，因此严重降低了指令的执行速度。为了提高指令的执行速度，CISC中常采用流水线技术。但由于存在很多问题，例如指令系统采用变字长指令、不同指令争用共同资源以及转移指令等，使流水线的效率不高。以上情况表明，传统的CISC设计思想并不利于提高计算机的速度。而且复杂的指令系统必然增加硬件实现的复杂性，从而使计算机的研制周期长、投资大。因此人们开始研究指令系统的合理性问题。对CISC指令系统运行的统计分析表明，各种指令的使用频率相差悬殊，最常用的是一些比较简单的指令，仅占指令总数的20%，但在程序中出现的频率却占80%。1975年，IBM公司提出了精简指令系统的想法。后来美国加利福尼亚大学伯克利分校的RISCI和RISCII、斯坦福大学的MIPS机的研制成功，为精简指令系统计算机（简称RISC）的诞生与发展起了很大作用。</p><ul><li>RISC的特点</li></ul><p>精简指令系统计算机的着眼点不是简单地放在简化指令系统上，而是通过简化指令使计算机的结构更加简单合理，更易于流水线的实现，从而提高处理速度。<br>  （1）面向寄存器的结构所有运算使用的数据都来自寄存器，运算结果也都写入寄存器。寄存器的典型长度是32位或64位。通常CPU内应设置大量的通用寄存器，以减少访问主存储器。<br>  （2）采用LOAD&#x2F;STORE结构<br>  （3）较少的指令数和寻址方式<br>  选取使用频率最高的一些简单指令，以及很有用但不复杂的指令，可简化控制部件。选用简单的寻址方式，有利于减少指令的执行周期数。<br>  （4）所有指令长度相同<br>  （5）硬布线控制逻辑<br>  （6）注重编译的优化<br>  RISC指令系统的简化，必然使编译生成的代码长度增长。但通过编译优化技术，将编译初步生成的代码重新组织，调度指令的执行次序，以充分发挥内部操作的并行性，从而进一步提高流水线的执行效率。虽然编译优化技术使编译时间拉长，但这种代价的结果是使程序的执行时间缩短。而且程序的编译工作只需一次，编译后生成的优化执行代码却可以高效率地执行多次。因此这个代价是值得的。</p><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><p>在物理构成上，存储系统通常分为3层：高速缓冲存储器Cache、主存和外存。Cache与主存常由半导体存储器构成；外存常由磁盘及光盘构成，也可以看作是I&#x2F;O设备。一个高性能的计算机系统要求存储器的存储容量大，存取速度快，成本低廉，能支持复杂系统结构。这些要求往往相互矛盾，彼此形成制约。因此在一个计算机系统中，常采用几种不同的存储器，构成多级存储体系，以适应不同层次的需要。通常，对CPU直接访问的一级，其速度尽可能快些，而容量相对有限；作为后援的一级其容量尽可能大些，而速度可以相对慢些。经过合理的搭配和组织，对用户来说，整个存储系统能够提供足够大的存储容量和较快的存取速度。<br>从用户的角度看，存储器还可以形成另一种层次结构，即物理存储器与虚拟存储器。物理存储器是指系统的物理组成中实际存在的主存，主存容量决定了实存空间的大小。在高档计算机中，依靠操作系统的软件支持及部分硬件的支持，可以使用户访问的编程空间远比实际主存空间大，用户感觉自己可编程访问一个很大的存储器，这个存储器称为虚拟存储器。</p><h4 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h4><ul><li><p>按存储器在计算机系统中的作用分类<br>（1）内部存储器内部存储器（简称内存或主存）是计算机主机的组成部分，用来存储当前运行所需要的程序和数据，CPU可以直接访问内存并与其交换信息。相对外部存储器而言，内存的容量小、存取速度快。由于CPU要频繁地访问内存，所以内存的性能在很大程度上影响了整个计算机系统的性能。<br>（2）外部存储器外部存储器也称辅助存储器或后援存储器，简称外存或辅存。外存用于存放当前不参加运行的程序和数据，以及一些需要永久保存的信息。外存设在设在主机外部，其容量大，但存取速度相对较慢，CPU不能直接访问它，而必须通过专门的设备才能对它进行读写（如磁盘驱动器等），这是它与内存之间的一个本质区别。<br>（3）高速缓冲存储器高速缓冲存储器（Cache）位于主存和CPU之间，用来存放正在执行的程序和数据，以便CPU能高速地访问它们。Cache的存取速度可以与CPU的速度相匹配，但其价格昂贵，存储容量较小。目前的微处理器通常将Cache或Cache的一部分制作在CPU芯片中。</p></li><li><p>按存取方式分类<br>（1）随机存取存储器RAM（RandomAccessMemory）随机存取存储器是可读可写的存储器，CPU可以对RAM单元的内容随机地读&#x2F;写访问，对任一单元的读出和写入的时间是一样的，即存取时间相同，并且与存储单元在存储器中所处的位置无关。RAM读&#x2F;写方便，使用灵活，但断电后信息会丢失。RAM主要用作主存，也可用作高速缓存。<br>（2）只读存储器ROM（ReadOnlyMemory）只读存储器可以看作RAM的一种特殊形式，其特点是：存储器的内容只能随机读出而不能写入。这类存储器用来存放那些不需要改变的信息。由于信息一旦写入存储器就固定不变了，即使断电信息也不会丢失，所以又称它为固定存储器。ROM除了存放某些系统程序外，还用来存放专门的子程序，或用作函数发生器、字符发生器及微程序控制器中的控制存储器。有些ROM在特定条件下用特殊的装置或程序可以重新写入。<br>（3）顺序存取存储器SAM（SequentialAccessMemory）顺序存取存储器的存取方式与前两种完全不同，它的内容只能按某种顺序存取，存取时间的长短与信息在存储器上的物理位置有关，所以SAM只能用平均存取时间作为衡量存取速度的指标。磁带机就是典型的顺序存取存储器。<br>（4）直接存取存储器DAM（DirectAccessMemory）直接存取存储器既不像RAM那样能随机地访问存储器<br>存储器的任何一个存储单元，也不像SAM那样完全按顺序存取，而是介于两者之间。存取信息时，第1步直接指向存储器的某个小区域（如磁盘上的磁道）；第2步在小区域内顺序检索或等待，直到找到目的地后再进行读&#x2F;写操作。这种存储器的存取时间也与信息所在的物理位置有关，但比SAM的存取时间要短。磁盘是最常见的直接存取存储器。</p></li><li><p>按存储介质分类<br>（1）磁芯存储器<br>（2）半导体存储器<br>（3）磁表面存储器<br>（4）光盘存储器</p></li><li><p>按信息的可保存性分类<br>断电后存储信息即消失的存储器，称为易失性存储器或挥发性存储器，RAM是易失性存储器。断电后信息仍然保存的存储器，称为非易失性存储器，也称为非挥发性存储器或永久性存储器，ROM、磁芯存储器、磁表面存储器和光盘存储器都是非易失性存储器。</p></li></ul><h4 id="主存的主要技术指标"><a href="#主存的主要技术指标" class="headerlink" title="主存的主要技术指标"></a>主存的主要技术指标</h4><ul><li>存储容量</li><li>存取速度</li><li>可靠性</li><li>存取宽度</li></ul><h4 id="高速缓冲存储器Cache"><a href="#高速缓冲存储器Cache" class="headerlink" title="高速缓冲存储器Cache"></a>高速缓冲存储器Cache</h4><p>计算机系统整体性能的高低与许多因素有关，如CPU的主频、存储器的存取速度、系统架构、指令结构、信息在各部件之间的传送速度等。而CPU与主存之间的存取速度是一个很重要的因素。如果只是CPU工作速度很高，而主存的存取速度较低，就会造成CPU经常处于等待状态，既降低了处理速度，又浪费了CPU能力。为了减小CPU与主存之间的速度差异，现代微机中通常在慢速的DRAM和快速的CPU之间插入一个速度较快、容量较小的SRAM，起到缓冲作用，使CPU既能以较快速度存取SRAM中的数据，又不使系统成本上升过高，这就是Cache技术。</p><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/4.jpg"></p><p>由此可以想到，如果把一段时间内在一定地址范围中被频繁访问的信息集合成批地从主存读到一个能高速存取的小容量存储器中存放起来，供程序在这段时间内随时使用，从而尽量减少访问速度较慢的主存的次数，可以加快程序的运行速度，这就是Cache的设计思想，即在CPU和主存之间设置一个小容量的高速缓冲存储器（Cache）。  Cache中存放着最近要使用的程序与数据，作为主存中当前最急需执行信息的副本。其容量约为数KB到数百KB，由于容量较小，可以选用高速半导体存储器，使CPU访存速度得到提高。在高档微处理器中，在CPU芯片内集成了1～2个高速缓存，称为片内Cache，还允许在CPU芯片外扩充Cache。<br>有了Cache，系统在工作时总是不断地将与当前指令集相关联的一个不太大的后继指令集从主存读到Cache，然后再向CPU高速传送，从而达到速度匹配。当CPU需要访存时，同时将地址送往主存与Cache。若所需访问的内容已经在Cache中，则可直接从Cache中快速读取信息，这称为访问Cache命中；若访问的内容不在Cache中，即未命中，则从主存中读取信息，并考虑更新Cache，使其成为当前最急需部分。为此需要实现访存地址与Cache物理地址间的映像变换。<br>由于局部性原理不能保证所请求的数据百分之百地在Cache中，这里便存在一个命中率问题。所谓命中率，就是在CPU访问Cache时，所需信息恰好在Cache中的概率。命中率越高，正确获取数据的可能性就越大，目前Cache的访问命中率可达到90%以上。因此只要合理组织三级存储体系，从整体上讲，CPU就能以接近Cache的速度访问存储器，而总存储容量相当于联机外存的总容量。<br>一般来说，Cache的存储容量比主存的容量小得多，但不能太小，太小会使命中率太低。但也没有必要过大，过大不仅会增加成本，而且当Cache容量超过一定值后，命中率随容量的增加将不会有明显增长。所以Cache的空间与主存空间在一定范围内应保持适当比例的映射关系，以保证Cache有较高的命中率，且系统成本不会过多地增加。Cache的命中率与Cache的映像方式、替换算法、程序特性等因素有关。</p><h4 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h4><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/5.jpg"></p><p> 要真正解决存储器的容量、速度、价格之间的矛盾，不能只是将上面的各个层次的存储器进行简单组合，必须在系统结构上采取措施，采用不同速度、不同容量和不同价格的多种存储器件，按层次组成存储系统。各个层次的存储器之间通过硬件和软件有机地结合成一个统一的整体，无需程序员的干预而由计算机自动地实现调度，向程序员提供足够大的存储空间，同时最大限度地与CPU速度相匹配。按这样的思想组成的存储层次结构，称为存储体系结构。<br>典型的三级存储体系结构，分为“高速缓存—主存—辅存”三个层次。现在的计算机系统大多具备这三级存储结构。三级存储体系又分为两个层次，高速缓存和主存之间形成Cache-主存层次，主存和辅存之间形成主存-辅存层次。 </p><p><img src="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/6.jpg"></p><ul><li>Cache-主存层次　<br>通过辅助硬件将Cache和主存构成一个整体，如上图所示。从整体上看，该层次具有接近于Cache的存取速度、主存容量和平均位价格，解决了存储器高速与低成本之间的矛盾。这个层次完全由硬件实现，不受软件的干预，因此对所有程序员都是透明的。</li><li>主存-辅存层次　<br>随着操作系统和硬件技术的发展，利用附加硬件及存储管理软件，使主存和辅存构成一个整体，形成主存-辅存层次，如图上图所示。辅存只与主存交换信息，不能直接由CPU访问。从整体上看，该层次的存取速度接近于主存的存取速度，容量则接近于辅存的容量，而位价格也接近于廉价的辅存平均价格，从而解决了大容量和低成本之间的矛盾。三级存储体系结构的总的效果是：存取速度接近于Cache，存储容量接近于辅存容量，整体价格也比较合理。</li></ul><h4 id="磁盘冗余阵列"><a href="#磁盘冗余阵列" class="headerlink" title="磁盘冗余阵列"></a>磁盘冗余阵列</h4><p>廉价冗余磁盘阵列（RedundantArraysofInexpensiveDisk，RAID）是用多台磁盘存储器组成的大容量外存子系统，它是由多台磁盘机按一定规则（如分条、分块、交叉存取等）组合在一起构成的。通过阵列控制器的控制和管理，磁盘阵列系统能够将几个、几十个甚至几百个硬盘组合起来，使其容量高达几百GB甚至上千GB。其基础是数据分块技术，即在多个磁盘上交错存放数据，通过阵列控制器实现数据的并行、交叉存储或单独存储操作。由于阵列中的一部分磁盘存有冗余信息，一旦系统中某一磁盘失效，可以利用冗余信息重建用户数据。</p><ul><li>RAID0级（无冗余和无校验的数据分块）<br>数据分布在阵列中的所有磁盘上，与单个大容量磁盘相比，它的显著优点是：如果两个I&#x2F;O请求正在等待不同的数据块，则被请求的块有可能在不同的盘上。因此，两个请求能够并行发出，减少了I&#x2F;O的排队时间。RAID0级具有最高的I&#x2F;O性能和磁盘空间利用率，但无容错能力，增加了系统出故障的几率。若阵列中有一块磁盘损坏，将造成不可弥补的损失。其安全性甚至低于常规的硬盘系统，所以不适于对数据稳定性要求高的应用。</li><li>RAID1级（镜像磁盘阵列）<br>由磁盘对组成，每个工作盘都有对应的镜像盘，上面保存着与工作盘完全相同的数据。如果镜像盘组中一个物理磁盘出现故障，系统可以使用未受影响的另一个磁盘继续操作，数据不会丢失，但磁盘空间的利用率只有50%。RAID1级的安全性高，而主要缺点是价格昂贵，它需要支持2倍于逻辑磁盘的磁盘空间。因此，RAID1级的配置只限于存储系统软件、数据和其他关键文件的驱动器中。在这种情况下，RAID1级对所有的数据提供实时备份，在磁盘损坏时，所有的关键数据仍立即可用。</li><li>RAID2级（具有纠错海明码的磁盘阵列）</li><li>RAID3、4、5、6、7级</li><li>RAID10级（RAID0级+RAID1级）<br>这是一种复合的RAID模式，将RAID0的速度与RAID1的冗余特性相结合，既可提供数据分块，又能提供镜像功能，是所有RAID中性能最好的磁盘阵列，但每次写入时要写两个互为镜像的盘，价格高。这种结构特别适用于既有大量数据需要存取，同时又对数据安全性要求严格的领域，如银行、金融、商业超市、仓储库房、各种档案管理等。</li></ul><h4 id="虚拟存储系统的组织"><a href="#虚拟存储系统的组织" class="headerlink" title="虚拟存储系统的组织"></a>虚拟存储系统的组织</h4><p>虚拟存储系统建立在主存-辅存层次上，是由附加硬件装置及存储管理软件组成的存储体系，它使计算机具有接近主存的存取速度，并具有辅存的容量和位成本。<br>在采用磁盘作为后援存储器后，可以在存储管理部件和操作系统存储管理软件的支持下，将主存和辅存的地址空间统一编址，使用户获得一个很大的编程空间，其容量大大超过实际的主存储器。这个在用户界面上看到的存储器，被称为虚拟存储器（VirtualMemory，VM），这样的虚拟存储技术对用户来说，自然是极有价值的，因而已在计算机系统中广泛使用，高档微处理器芯片也为此提供了有关硬件支撑。从用户界面看，用户可使用位数较长的编程地址进行编程，这种地址面向程序的需要，不必考虑程序将来在主存储器中的实际位置，因而称为逻辑地址。它是面向虚拟存储器的，所以又称为虚地址。在用户看来，CPU可按虚地址访问一个很大的存储器，其容量甚至可达整个辅存容量，显然这是一种虚拟层次。<br>在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前急需运行的部分调入主存，供CPU操作，其余暂不运行部分留在磁盘中，随程序执行的需要，操作系统自动地按一定替换算法进行调度，将当前暂不运行部分调回磁盘，将新的模块由磁盘调入主存。这一层次上的工作，对用户是透明的。CPU执行程序时，需将程序提供的虚地址变换为主存的实际地址（实地址、物理地址）。一般是先由存储管理部件判断该地址的内容是否在主存中，若已调入主存，则通过地址变换机制将虚地址转换为实地址，然后访问主存单元；若尚未调入主存，则通过缺页中断程序，以页为单位调入或实现主存内容调换。从原理上看，虚拟存储器与Cache-主存层次有很多相似之处，如地址映像方式和替换策略。但是，Cache-主存层次的控制完全由硬件实现，它对各类程序员都是透明的；而虚拟存储器的控制是由硬件与软件结合实现，对应用程序员来说是透明的，但对于设计存储器管理软件的系统程序员来说是不透明的。</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>无</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>别人不说,你一定要懂的人情世故</title>
    <link href="/2022/10/28/%E5%88%AB%E4%BA%BA%E4%B8%8D%E8%AF%B4-%E4%BD%A0%E4%B8%80%E5%AE%9A%E8%A6%81%E6%87%82%E7%9A%84%E4%BA%BA%E6%83%85%E4%B8%96%E6%95%85/"/>
    <url>/2022/10/28/%E5%88%AB%E4%BA%BA%E4%B8%8D%E8%AF%B4-%E4%BD%A0%E4%B8%80%E5%AE%9A%E8%A6%81%E6%87%82%E7%9A%84%E4%BA%BA%E6%83%85%E4%B8%96%E6%95%85/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《别人不说，你一定要懂的人情世故》 墨墨 北京理工大学出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li><p>不能主动去接触他人，人脉关系必定不广，人生路程也不会走得太顺遂，唯有怀着主动之心，你才能广交天下的朋友。</p></li><li><p>在职场里，要求我们在即使没有功利、没有收益的时候也要给别人以支持、给人以帮助，更不能砸别人的场面。</p></li><li><p>批评最好能单独进行，如果在公共场合批评，那就太伤你下属的感情了，这样做的结果是让你的下属成为你的刺儿头。如果能单独进行，即使其他人知道，你的下属也会好过点儿。</p></li><li><p>自己身居要职，就注定了要被批评，与其困扰于被批评，还不如想办法习惯它。</p></li><li><p>多在背后赞美，多在第三者面前赞美，是融洽人际关系的好方法。懂得人情世故的人会选择在背后赞美，通过间接的方式让人接受赞美，不仅避免了当面说好话的尴尬，还能够放大赞美的效果，从而达到润滑彼此关系的目的。</p></li><li><p>我们要尽量避开背后议论、评价他人，若迫不得已参与评论，则应多说一些中肯的话，而要避免说坏话。如果可能的话，最好避开背后议论他人，无论你是说好话还是说坏话。</p></li><li><p>在做事情的时候，将丑话说在前头，能够让人的态度更加认真和慎重，而不会掉以轻心、马虎了事。同时，也能够避免一些纠纷。丑话虽然不受听、扎耳朵，但却是超越流俗、突破情面把本相说到底、把前景想周全，既重人情，更重信义的真话。</p></li><li><p>多聊对方关心和得意的事，是懂得人情世故的做法，但是有不少人不懂得这其中的道理，常常从自身的爱好出发，说自己喜欢的话题，聊自己得意的事，结果让对方缺乏兴趣，甚至不耐烦。所以在与人交流时，尽可能地忘掉自己，不要总是谈自己的事情，你的生活引不起别人的兴趣。</p></li><li><p>如果有人请求你的帮助，即便对方的困境纯属咎由自取，你也不要说他的不是。你可以说自己无能为力，并拒绝他的请求，但不要指责他。请求帮助，承认自己是一个弱者，这已经是丢面子的事情了，如果你还进一步指责对方，则会让对方的脸色更加难看。</p></li><li><p>与人处事就如同下一盘象棋，只有那些阅历不深的人才会一口气赢对方七八盘，让对方抬不起头。事实上人们交际，彼此之间并非比赛，对输赢不必那么认真，主要目的是交流感情，增进友谊，进而发展合作共进的关系。</p></li><li><p>做人要有胸怀，特别是与人相交，不能整日计较鸡毛蒜皮的小事，枉费了许多时间和精力。在生活中应该多理解，在工作上应该多宽容，在待人上应该多温和，在处事上应该多大度。这样的处世原则将让你的朋友如沐春风。</p></li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>内容较多，多思考，多实践，多反思。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小狗钱钱</title>
    <link href="/2022/10/28/%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1/"/>
    <url>/2022/10/28/%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《小狗钱钱》 舍费尔 四川少年儿童出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>永远不要在背后说别人的坏话</li><li>不能总是抱怨命运的不公。在我们的生活中不是所有的事情都是公平的，不公平的情况很常见。但这并不意味着你就应该放弃，因为成功并不取决于你是否受到了公平的对待</li><li>尊重他人和对人有礼貌是成功的重要因素。如果有人不喜欢你，很大程度上是因为你表现得不够友好。这会损害一个人的声誉，所以你不能那么做。另外，彬彬有礼也可以让以前并不信任你的人接纳</li><li>我们推崇一种聪明的、简朴的生活方式。也就是说，宁愿购买一件一流产品，也不要不停地买许多的二流产品。而且，不要仅仅因为一件产品的外观不再时髦而新产品正在流行，就不断追逐新鲜的东西。生活质量不是由越来越多的高科技产品堆砌而成的，而体现在一些别的方面，比如悠闲地享受一下生活，增进邻里关系，表达感情或者从事艺术性和创造性的活动。</li><li>出于分散风险的考虑，你应该把一部分钱投资在绝对安全的地方，应该始终储备一些现金。决不能把你全部的钱都投资在股票或者基金上面。</li><li>只有当你把股票实际卖出的时候，才会有损失。</li><li>没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>理财启蒙书籍，不过书中除了理财的其他的内容也具有一定的启发意义，以后可以让小朋友读一读。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法记录</title>
    <link href="/2022/10/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/10/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start , <span class="hljs-type">int</span> end)</span>&#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt;= <span class="hljs-number">1</span> || start &gt;= end)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> end;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums[i];<br>    <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>        <span class="hljs-keyword">while</span> (nums[j] &gt;= target &amp;&amp; i &lt; j)&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>            nums[i] = nums[j];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (nums[i] &lt;= target &amp;&amp; i &lt; j)&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>            nums[j] = nums[i];<br>            j--;<br>        &#125;<br>        nums[i] = target;<br>    &#125;<br>    quickSort(nums, start, i - <span class="hljs-number">1</span>);<br>    quickSort(nums, i + <span class="hljs-number">1</span>, end);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="力扣215–数组中的第K个最大元素"><a href="#力扣215–数组中的第K个最大元素" class="headerlink" title="力扣215–数组中的第K个最大元素"></a>力扣215–数组中的第K个最大元素</h2><ul><li>题目</li></ul><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><ul><li>堆排序</li></ul><p>利用优先队列来实现堆排序，时间复杂度 O(NlogK)，空间复杂度 O(K)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        PriorityQueue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; k; i++)&#123;<br>            q.add(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; q.peek())&#123;<br>                q.add(nums[i]);<br>                q.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>快速选择法</li></ul><p>化用于快排，时间复杂度最差为O(N^2)，时间复杂度期望为O(N)，空间复杂度O(1)，对于不随机样本，可以人为加入随机选择的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>        k = nums.length - k;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> setP(nums, l, r);<br>            <span class="hljs-keyword">if</span> (p == k)&#123;<br>                <span class="hljs-keyword">return</span> nums[p];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p &lt; k)&#123;<br>                l = p + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = p - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">setP</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-comment">//在样本不具备随机性的情况下，可以人为加入随机性，提高计算效率</span><br>        <span class="hljs-comment">//int tempI = (int)(Math.random() * (r - l)) + l;</span><br>        <span class="hljs-comment">//int tempV = nums[l];</span><br>        <span class="hljs-comment">//nums[l] = nums[tempI];</span><br>        <span class="hljs-comment">//nums[tempI] = tempV;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> r;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> nums[i];<br>        <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= target)&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>                nums[i] = nums[j];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= target)&#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; j)&#123;<br>               nums[j] = nums[i];<br>               j--;<br>            &#125;<br>        &#125;<br>        nums[i] = target;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="力扣347–前-K-个高频元素"><a href="#力扣347–前-K-个高频元素" class="headerlink" title="力扣347–前 K 个高频元素"></a>力扣347–前 K 个高频元素</h2><ul><li>题目</li></ul><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。</p><ul><li>桶排序</li></ul><p>构建一个数组，将频数相同的元素放在同一个数组里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        List&lt;Integer&gt; resList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(k);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> k;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)&#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        List&lt;Integer&gt;[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123;<br>            <span class="hljs-keyword">if</span> (arr[entry.getValue()] == <span class="hljs-literal">null</span>)&#123;<br>                arr[entry.getValue()] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            &#125;<br>            arr[entry.getValue()].add(entry.getKey());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span> (arr[i] == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr[i])&#123;<br>                resList.add(num);<br>                count--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>; <br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[resList.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; resList.size(); i++)&#123;<br>            res[i] = resList.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="力扣451–根据字符出现频率排序"><a href="#力扣451–根据字符出现频率排序" class="headerlink" title="力扣451–根据字符出现频率排序"></a>力扣451–根据字符出现频率排序</h2><p>类似347</p><h2 id="力扣75–颜色分类"><a href="#力扣75–颜色分类" class="headerlink" title="力扣75–颜色分类"></a>力扣75–颜色分类</h2><ul><li>题目</li></ul><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><ul><li>三向切分快速排序</li></ul><p>注意，one和zero交换后，one需要加一，以保障one始终在zero前面，否则会出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">zero</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, one = <span class="hljs-number">0</span>, two = nums.length;<br>    <span class="hljs-keyword">while</span> (one &lt; two) &#123;<br>        <span class="hljs-keyword">if</span> (nums[one] == <span class="hljs-number">0</span>) &#123;<br>            swap(nums, ++zero, one++);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[one] == <span class="hljs-number">2</span>) &#123;<br>            swap(nums, --two, one);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++one;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = t;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cyc2018.xyz/">https://www.cyc2018.xyz/</a></p><p>Leetcode</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>胃靠养,肠靠清</title>
    <link href="/2022/10/09/%E8%83%83%E9%9D%A0%E5%85%BB-%E8%82%A0%E9%9D%A0%E6%B8%85/"/>
    <url>/2022/10/09/%E8%83%83%E9%9D%A0%E5%85%BB-%E8%82%A0%E9%9D%A0%E6%B8%85/</url>
    
    <content type="html"><![CDATA[<h1 id="1-信息"><a href="#1-信息" class="headerlink" title="1 信息"></a>1 信息</h1><p>《胃靠养，肠靠清》李博 江苏凤凰科学技术出版社</p><h1 id="2-摘录"><a href="#2-摘录" class="headerlink" title="2 摘录"></a>2 摘录</h1><ul><li>现代社会营养不良导致的疾病几乎消失了，取而代之的是营养过剩引起的各种疾病。所以，少吃一些，才是不浪费，才是对身体负责。</li><li>能真正起到保健作用的，就是自然天赐的食物、平和的内心，以及适度的运动。</li><li>垃圾食品中排在第一位的是油炸品，第二位是腌制品。</li><li>晚餐应该遵循“四少”，即少盐少油少脂肪少辣的基本原则。不要忽视每一餐饭，日积月累，影响深远。如果能做到这“晚餐四少”，就代表着我们离高血压、高血脂、胃食管反流和痔疮等一系列病症都远了很多。</li><li>不生气不代表憋着，而是要正确地疏导和发泄，这样才是对身体有利的，比如去旅游、参加户外活动等。</li><li>早餐的鸡蛋必不可少，可以吃烧饼，不要吃油条、油饼之类的，豆腐脑不如喝粥和豆浆。中午的肉类多吃一些牛肉，蔬菜可以考虑胡萝卜、西红柿、土豆及各种新鲜的绿叶菜。晚餐推荐豆粥，加入薏米、山药和红枣有利于慢性胃炎的恢复。</li><li>还是希望大家做个“有心人”，密切关注自己的身体情况，长时间不适时千万不要忍着，越早去医院诊断越好。</li><li>要想远离胃癌以及各种癌症，起码要做到以下3点：<br> ①保持心情舒畅，让身体的内分泌系统处于良性循环。②均衡饮食，避免胃癌的外界因素。还要特别说一句，不要乱吃补品。就算是维生素，也不是多多益善，过量进补有害无益。有研究表明，β-胡萝卜素摄入过量有引起胃癌的风险。③坚持体育锻炼，促进新陈代谢。</li><li>胆结石、胆囊炎这俩“坏小子”是怎么成长起来的？<br> 不吃早饭是“主犯”</li><li>与疾病化敌为友，或者和谐共处，是很多疾病治疗的思路。如果能够保持一个平静的心态，允许身体的不完美，完全可以生活得更好，不必纠结于每天与疾病的斗争。</li><li>推荐早晨起来先饮用一杯凉开水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。</li><li>强烈推荐有氧运动，有时运动治疗便秘的效果是您意想不到的。每周运动3次为宜，每次1小时。除以有氧运动为主外，还可以增加仰卧起坐等腹部局部锻炼。运动的强度以出汗30分钟以上为宜。</li></ul><h1 id="3-感想"><a href="#3-感想" class="headerlink" title="3 感想"></a>3 感想</h1><ul><li>饮食方面的注意事项：避免油炸、腌制品；做饭少盐少油少脂肪少辣；早餐鸡蛋和豆浆配主食，中午建议牛肉和蔬菜，晚餐建议薏米、山药、红枣豆粥，吃八分饱；推荐早晨起来先饮用一杯温水（蜂蜜水更佳），喝完后立即如厕，即使没有便意，也应该在厕所坐5分钟，逐渐养成定时排便的习惯。</li><li>其他方面注意：坚持有氧锻炼；保持平和心态，适当旅游户外运动调整情绪；长期不适及时就医</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>养生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客备份</title>
    <link href="/2022/10/08/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/"/>
    <url>/2022/10/08/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>《基于GitHub和Hexo搭建博客》中总结了如何利用github和hexo搭建个人博客，但是github上上传的只是博客网站文件，像markdown笔记之类的源文件并没有备份，如果本地电脑坏了很难恢复以往的markdown笔记，所以需要连同markdown笔记在内的源文件都备份到github上。</p><h1 id="2-备份步骤"><a href="#2-备份步骤" class="headerlink" title="2 备份步骤"></a>2 备份步骤</h1><h2 id="2-1-创建新分支"><a href="#2-1-创建新分支" class="headerlink" title="2.1 创建新分支"></a>2.1 创建新分支</h2><p>在github上的博客所在仓库上创建一个用来备份的分支hexo，并且将其设置为默认分支。</p><h2 id="2-2-获取git信息文件"><a href="#2-2-获取git信息文件" class="headerlink" title="2.2 获取git信息文件"></a>2.2 获取git信息文件</h2><p>去桌面或者哪里随便一个地方，把刚刚的hexo分支给clone下来。然后剪切出里面的.git文件夹，复制到现在的博客文件夹中。</p><p><img src="/2022/10/08/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/git%E6%96%87%E4%BB%B6.png"></p><h2 id="2-3-添加-gitignore"><a href="#2-3-添加-gitignore" class="headerlink" title="2.3 添加 .gitignore"></a>2.3 添加 .<a href="https://so.csdn.net/so/search?q=gitignore&spm=1001.2101.3001.7020">gitignore</a></h2><p>用来在上传时候忽略一些文件，即不上传<code>.gitignore</code>中忽略的文件。如果有最好，没有的话自己手动添加。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.DS_Store</span><br>Thumbs<span class="hljs-number">.</span><span class="hljs-built_in">db</span><br><span class="hljs-built_in">db</span><span class="hljs-number">.</span>json<br>*.log<br>node_modules/<br><span class="hljs-meta">public</span>/<br><span class="hljs-meta">.deploy</span>*/<br></code></pre></td></tr></table></figure><p><strong>注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。</strong></p><h2 id="2-4-备份"><a href="#2-4-备份" class="headerlink" title="2.4 备份"></a>2.4 备份</h2><p>在hexo博客的根目录下执行</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git add .<br><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&quot;Backup&quot;</span><br><span class="hljs-variable">$ </span>git push origin hexo<br></code></pre></td></tr></table></figure><p>这样就备份完博客了且在Github上能看到两个分支(main和hexo)。</p><h2 id="2-5-备份习惯"><a href="#2-5-备份习惯" class="headerlink" title="2.5 备份习惯"></a>2.5 备份习惯</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">hexo</span> clean<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;Backup&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span><br><span class="hljs-symbol">hexo</span> g<br><span class="hljs-symbol">hexo</span> d<br></code></pre></td></tr></table></figure><h1 id="3-恢复步骤"><a href="#3-恢复步骤" class="headerlink" title="3 恢复步骤"></a>3 恢复步骤</h1><h2 id="3-1-环境准备"><a href="#3-1-环境准备" class="headerlink" title="3.1 环境准备"></a>3.1 环境准备</h2><p>安装git 、nodejs，确保github公钥接入，参考《基于GitHub和Hexo搭建博客》</p><h2 id="3-2-克隆项目到本地"><a href="#3-2-克隆项目到本地" class="headerlink" title="3.2 克隆项目到本地"></a>3.2 克隆项目到本地</h2><p>输入下列命令克隆博客必须文件(hexo分支)：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://xxxxx(详见仓库链接)<br></code></pre></td></tr></table></figure><h2 id="3-3-博客恢复"><a href="#3-3-博客恢复" class="headerlink" title="3.3 博客恢复"></a>3.3 博客恢复</h2><p>在clone下来的那个文件夹里面执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> npm install hexo<span class="hljs-literal">-cli</span><br><span class="hljs-variable">$</span> npm install<br><span class="hljs-variable">$</span> npm install hexo<span class="hljs-literal">-deployer-git</span> –save<br><span class="hljs-variable">$</span> <span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span> .deploy_git<br></code></pre></td></tr></table></figure><p>然后再去安装原来安装的一些插件。**在此不需要执行hexo init这条指令，因为不是从零搭建起新博客。</p><p>后续正常写博客，执行以下命令即可</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">hexo <span class="hljs-built_in">n</span> xx<br>hexo <span class="hljs-built_in">clean</span><br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h1><p><a href="https://blog.csdn.net/NoMasp/article/details/79504699">【Hexo异常】fatal: in unpopulated submodule ‘.deploy_git’_nomasp的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_21040559/article/details/109702142"> Hexo博客的备份_fFee-ops的博客-CSDN博客_hexo备份</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习整理</title>
    <link href="/2022/09/25/git%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/"/>
    <url>/2022/09/25/git%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><p>版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add 文件名</code>，注意，可反复多次使用，添加多个文件，此时文件放到了缓存区；</li><li>使用命令<code>git commit -m &quot;提交信息&quot;</code>，完成，此时文件从缓存区被放到了head指定的当前分支中。</li></ol><h1 id="查看工作区状态与提交修改"><a href="#查看工作区状态与提交修改" class="headerlink" title="查看工作区状态与提交修改"></a>查看工作区状态与提交修改</h1><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p><p>如果git status告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p><p>提交修改与添加文件的步骤一样</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">add</span> 文件名<br>git <span class="hljs-keyword">commit</span> -m &quot;add a line&quot;<br></code></pre></td></tr></table></figure><p>将暂存区的版本提交到版本库,从而形成工作区-&gt;暂存区-&gt;版本库的基本链路,本地工作区的版本控制流程大致如此.</p><h1 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h1><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>（commit_id可以输入前几位就行）。</p><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p><h1 id="多次修改"><a href="#多次修改" class="headerlink" title="多次修改"></a>多次修改</h1><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p><h1 id="修改撤销"><a href="#修改撤销" class="headerlink" title="修改撤销"></a>修改撤销</h1><ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD</code> ，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<strong>版本切换</strong>一节，不过前提是没有推送到远程库。</li></ul><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><p>如果在本地删除了文件，可以通过以下操作在git库里删除  </p><p><code>git rm test.txt</code>  </p><p><code>git commit -m &quot;remove test.txt&quot;</code>  </p><p>可以通过以下操作恢复，相当于是让工作目录test.txt恢复到暂存区中test.txt的状态</p><p><code>git checkout -- test.txt</code></p><h1 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h1><p><strong>git连接GitHub的操作可以见《Windows环境基于GitHub和Hexo搭建个人博客》的2.2节</strong></p><p>把本地库的内容推送到远程，用git push命令，实际上是把指定分支推送到远程。  </p><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><ol><li><p>要关联一个远程库，使用命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git remote <span class="hljs-keyword">add</span> origin git@<span class="hljs-keyword">server</span>-<span class="hljs-type">name</span>:<span class="hljs-type">path</span>/repo-<span class="hljs-type">name</span>.git<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git remote <span class="hljs-keyword">add</span><span class="language-bash"> origin git@github.com:michaelliao/learngit.git</span><br></code></pre></td></tr></table></figure></li><li><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p></li><li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p></li></ol><h1 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h1><p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。以下是拉去默认分支的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> git@github.com:michaelliao/gitskills.git</span><br></code></pre></td></tr></table></figure><p>因为刚才推送到master分支，所以我们可以拉取master分支的内容</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:michaelliao/gitskills.git -b <span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。具体的<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>，加上–no-ff选项。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。  </p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="/2022/09/25/git%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/1829507-20220316234843811-601091411.png"></p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p><p>具体可以参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136">https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136</a></p><h2 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h2><p>开发一个新feature，最好新建一个分支，开发完可以合并到dev分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。</p><h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><p>多人协作的工作模式通常是这样：</p><ul><li>首先，可以试图用git push origin 推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！</li><li>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to origin&#x2F;。</li></ul><p>多人协作重点：</p><ul><li>查看远程库信息，使用git remote -v；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin&#x2F;branch-name，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin&#x2F;branch-name；</li><li>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</li></ul><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p><p>命令git tag -a -m “blablabla…”可以指定标签信息；</p><p>命令git tag可以查看所有标签。</p><p>命令git push origin 可以推送一个本地标签；</p><p>命令git push origin –tags可以推送全部未推送过的本地标签；</p><p>命令git tag -d 可以删除一个本地标签；</p><p>命令git push origin :refs&#x2F;tags&#x2F;可以删除一个远程标签。</p><h1 id="使用github"><a href="#使用github" class="headerlink" title="使用github"></a>使用github</h1><p>在GitHub上，可以任意Fork开源仓库，复制到自己的仓库；</p><p>自己拥有Fork后的仓库的读写权限；</p><p>可以推送pull request给官方仓库来贡献代码。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>vcs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win11中WSL2搭配ubuntu使用笔记</title>
    <link href="/2022/09/17/Win11%E4%B8%ADWSL2%E6%90%AD%E9%85%8Dubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/17/Win11%E4%B8%ADWSL2%E6%90%AD%E9%85%8Dubuntu%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在surface go 3上基于WSL2装了一个ubuntu玩玩，记录下相关信息</p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><p><a href="https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview">Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu</a></p><h2 id="WSL命令"><a href="#WSL命令" class="headerlink" title="WSL命令"></a>WSL命令</h2><ul><li>cmd键入以下命令以查看所有正在运行的WSL，然后按Enter：</li></ul><p><code>wsl --list --verbose</code></p><ul><li>cmd关闭所有的后台的linux虚拟机</li></ul><p><code>wsl --shutdown</code></p><ul><li>重新启动linux虚拟机</li></ul><p>如果需要重新启动Linux发行版，只需从开始菜单或使用<code>wsl --distribution DISTRO-NAME</code>命令在命令提示符下再次将其打开。请记住将DISTRO-NAME替换为发行版的实际名称。</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li>系统升级</li></ul><p><code>sudo apt update</code></p><p><code>sudo apt full-upgrade</code></p><ul><li>文件传输（图形化界面）</li></ul><p><code>explorer.exe .</code></p><ul><li>查看Linux内核版本命令</li></ul><p><code>cat /proc/version</code></p><ul><li>查看Linux系统版本</li></ul><p><code>cat /etc/issue</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-11-with-gui-support#1-overview">Install Ubuntu on WSL2 on Windows 11 with GUI support | Ubuntu</a></p><p><a href="https://zhuanlan.zhihu.com/p/351880793">只需一条命令，快速在Windows 10上关闭Linux - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人生的智慧</title>
    <link href="/2022/09/11/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/"/>
    <url>/2022/09/11/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《人生的智慧》 阿图尔·叔本华 湖南人民出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>幸福的首要因素，甚至，一个人此生存在的主要意义，是由他的内在机制决定的；一个人内心满足与否，取决于他的情感、欲望和思想共同作用的结果，外在环境对人只起到了间接调节的作用。我们年轻时几乎意识不到的一点是，最高级最丰富且最持久的乐趣来源于思想，思想力量的强弱决定了乐趣大小。身外之物对幸福的影响太微弱，大多数无须为生计发愁的人们由于内在贫乏，跟那些生活在底层为生计奔波劳碌的人们一样的感觉不幸福。他们头脑空洞、想象力贫瘠、精神空虚，只好与跟自己相似的人为伍，正所谓“物以类聚，人以群分”——他们聚在一起追求消遣娱乐，纵情感官享受，最后以荒唐告终。</li><li>幸福的本质在于“人”，那么集中精力保持身体健康、培养能力，无疑要比一心积累财富更明智，但千万不要误以为我们就应该忽略掉对生活必需品的获取。身心健康是幸福的首要关键，最愚蠢的事就是牺牲自己的健康去追求任何其他一时的快活，不管是为了利益、升迁、学问还是名气，甚至为了转瞬即逝的感官乐趣糟蹋自己的健康，都是愚不可及的行为。</li><li>实际上，生活就像是钟摆一般，在这两端之间或激烈或温和地来回摇摆——要么痛苦，要么无聊，反正总有一项逃不掉。究其根源，痛苦和无聊是一种双重对立的存在，一是外部的或客观的，一是内在的或主观的。匮乏的环境和贫穷会导致痛苦；而一个人衣食无忧，那么他就会无聊。这样的不幸只能靠内在的力量，亦即精神财富来抵御。</li><li>人类有两大最常见的愚蠢，第一是“不是在他自身的本质中去寻求幸福，而是在别人看待‘他是什么’中求幸福”，就是说太在意别人的看法，为别人而活。第二是牺牲健康去谋求别的东西，不明白一个健康的乞丐比疾病的国王要幸福。“人是什么”比“人有什么”，要重要得多。在是否幸福这件事情上，个人的人格、气质、心态、信仰，比汽车、房子、珠宝等更为重要。也就是说，你的个性才是最宝贵的财富。你需要去追求物质、名誉，但你更需要追求的，是你独立而健康的个性。正是在这个意义上，叔本华才会说：“个性远比民族性更重要。最廉价的骄傲是民族骄傲，也就是所谓的‘民族自豪感’——如果一个人号称为他的国家或民族自豪，那只能说明他本身并没有什么可值得骄傲的，否则也不会抓着那些千百万人共有的东西引以为荣了。”</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>幸福的本质在于“人”。首先是需要保障身体健康，保持适当的锻炼，任何事情都要给健康让路，不管是利益、升迁、学问还是名气；其次需要持之以恒地提升内心精神境界并汲取知识，去观赏大自然的鬼斧神工和历史上的伟大成就，像雕琢艺术品一样构建自己的内心世界；不要过多地在意外界的看法，克制嫉妒等不良情绪，减少不必要的痛苦.</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书与做人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书与做人</title>
    <link href="/2022/09/11/%E8%AF%BB%E4%B9%A6%E4%B8%8E%E5%81%9A%E4%BA%BA/"/>
    <url>/2022/09/11/%E8%AF%BB%E4%B9%A6%E4%B8%8E%E5%81%9A%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《读书与做人》 季羡林 国际文化出版公司</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>除了马克思主义以外，古今中外一些所谓唯心主义哲学家的著作，他们的思维方式和推理方式，也要认真学习。百分之百的唯物主义哲学家和百分之百的唯心主义哲学家，都是没有的。“智者千虑，必有一失”。我们千万不要像过去那样把十分复杂的问题简单化和教条化。                                                                             </li><li>不能说假话，但也不必说真话。</li><li>遇事必须深思熟虑，先考虑可行性，考虑的方面越广越好。然后再考虑不可行性，也是考虑的方面越广越好。正反两面仔细考虑完以后，就必须加以比较，做出决定，立即行动。如果你考虑正面，又考虑反面之后，再回头来考虑正面，又再考虑反面，那么，如此循环往复，终无宁日，最终成为考虑的巨人，行动的侏儒。</li><li>最好能背诵几百首旧诗词和几十篇古文，让它们随时涵蕴于你们心中，低吟于你们口头。这对于你们的文学创作和人文素质的提高，都会有极大的好处。不管你们现在或将来是教书、研究、经商、从政，或者是专业作家，都是如此，概莫能外。</li><li>能够百分之六十为他人着想，百分之四十为自己着想，他就是一个及格的好人。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>哲学方面可以考虑以马克思主义为主，其他思想为辅，兼顾唯物主义和唯心主义；需要考虑说话的技巧，假话绝不说，真话不说全；做决定时，广泛考虑正反两面后果断做决定；考虑背一些诗词和古文。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书与做人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自控力</title>
    <link href="/2022/09/11/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    <url>/2022/09/11/%E8%87%AA%E6%8E%A7%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《自控力》 麦格尼格尔 印刷工业出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>如果你觉得自己没有时间和精力去处理“我想要”做的事，那就把它安排在你意志力最强的时候做</li><li>大多数心理学家和营养学家推荐低血糖饮食，因为它能让你的血糖稳定。低血糖食品包括瘦肉蛋白、坚果和豆类、粗纤维谷类和麦片、大多数的水果和蔬菜。</li><li>美国心理学家协会的调查发现，最有效的解压方法包括：锻炼、阅读、听音乐、与家人朋友相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。最没效果的缓解压力的方法则包括：赌博、购物、抽烟、喝酒、暴饮暴食、玩游戏、上网、花两小时以上看电视或电影。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>书籍实用性不强，参照建议展开冥想确实对身心有一定帮助。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何有效阅读一本书</title>
    <link href="/2022/09/11/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    <url>/2022/09/11/%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《如何有效阅读一本书》 奥野宣之 江西人民出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>读书笔记的作用：随想笔记、购书清单、各种报道的剪报、读书笔记</li><li>过程中基本上是用不到笔记本的，读书时只需要画出重点做好记号，日后只需要确认想要落实的内容，记在读书笔记里就好</li><li>读书的过程：选书、购书、读书、笔记、活用</li><li>读书清单包括书名、作者、出版社、备注</li><li>在某种意义上，购书清单并不只是单纯的“购物备忘录”，而是为了促进主观购书的矫正装置</li><li>为了写出精练而深刻的读书笔记，你应该在读完一本书以后认真回想需要摘抄哪一<br> 页哪一 行，思考怎样撰写读书笔记，然后严格地筛选需要摘抄的内容，尽量提炼自己的感想，争取用最短的语句表达深刻的含义</li><li>写读书笔记感想的时候，不要写一些揣测的或者外来的想法，而是因该写自己的心声</li><li>可以考虑定期进行读书笔记的重读工作</li><li>多使用参考书：·地图 ·图鉴 ·统计数据 ·百科全书 ·年表 ·词典</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>本书介绍了读书的一般流程和注意事项，关键点在于要有目的的读书，以做读书笔记为导向进行读书，精简读书笔记，适当重读活学活用</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书与做人</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows环境基于GitHub和Hexo搭建个人博客</title>
    <link href="/2022/09/06/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/09/06/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>周末参照网上教程基于GitHub和Hexo搭建个人博客，中间踩了不少的坑花了很多时间，所以将他人教程转载过来并加上一些修订内容记录下来。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="安装Node-js和Git"><a href="#安装Node-js和Git" class="headerlink" title="安装Node.js和Git"></a>安装Node.js和Git</h2><ul><li>Node.js：<a href="https://link.zhihu.com/?target=https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a></li><li>Git：<a href="https://link.zhihu.com/?target=https://git-scm.com/downloads">https://git-scm.com/downloads</a></li></ul><p>基于上面两个网站下载最新的Node.js和Git安装包，基于默认配置一路点下去安装Node.js和Git。安装完成后，在cmd中依次执行 <code>node -v</code>、<code>npm -v</code> 和 <code>git --version</code>，看到类似以下版本号说明安装成功</p><p><img src="/2022/09/06/%E5%9F%BA%E4%BA%8EGitHub%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC.png"></p><h2 id="连接-Github"><a href="#连接-Github" class="headerlink" title="连接 Github"></a>连接 Github</h2><p>使用邮箱注册 <a href="https://link.zhihu.com/?target=https://github.com/">GitHub</a> 账户，选择免费账户（Free），并完成邮件验证。</p><p>在Windows桌面右键 -&gt; Git Bash Here，设置用户名和邮箱(此处的“GitHub 用户名”和”GitHub 邮箱”分别替换成个人的GitHub用户名和邮箱，下同）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> user.name <span class="hljs-string">&quot;GitHub 用户名&quot;</span><br>git config <span class="hljs-literal">--global</span> user.email <span class="hljs-string">&quot;GitHub 邮箱&quot;</span><br></code></pre></td></tr></table></figure><p><strong>创建 SSH 密匙</strong>：</p><p>输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车。</p><p><strong>添加密匙：</strong></p><p>进入 [C:\Users\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p><p>登陆 GitHub ，进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p><p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p><p><strong>验证连接：</strong></p><p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认。显示 “Hi xxx! You’ve successfully……” 即连接成功。如果没有出现“Hi xxx! You’ve successfully……”字样，可以再次输入 <code>ssh -T git@github.com</code>尝试。</p><h2 id="创建-Github-Pages-仓库"><a href="#创建-Github-Pages-仓库" class="headerlink" title="创建 Github Pages 仓库"></a>创建 Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p><ul><li>Repository name 中输入 <code>用户名.github.io</code></li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li></ul><p>填好后点击 Create repository 创建。</p><p>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p><h2 id="本地安装-Hexo-博客程序"><a href="#本地安装-Hexo-博客程序" class="headerlink" title="本地安装 Hexo 博客程序"></a>本地安装 Hexo 博客程序</h2><p>新建一个文件夹用来存放 Hexo 的程序文件，如 hexoblog。打开该文件夹，右键 -&gt; Git Bash Here。</p><p>使用 npm 一键安装 Hexo 博客程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>初始化并安装所需组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo init      # 初始化<br>npm install    # 安装组件<br></code></pre></td></tr></table></figure><p>完成后依次输入下面命令，启动本地服务器进行预览：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo g   # 生成页面<br>hexo s   # 启动预览<br></code></pre></td></tr></table></figure><p><strong>访问</strong> <code>http://localhost:4000</code><strong>，出现 Hexo 默认页面，本地博客安装成功！</strong></p><h2 id="部署-Hexo-到-GitHub-Pages"><a href="#部署-Hexo-到-GitHub-Pages" class="headerlink" title="部署 Hexo 到 GitHub Pages"></a>部署 Hexo 到 GitHub Pages</h2><p>本地博客测试成功后就是上传到 GitHub 进行部署，使其能够在网络上访问。</p><p>首先安装 hexo-deployer-git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>然后修改hexo程序文件夹中的_config.yml文件末尾的 deploy部分(建议使用notepad++打开)，修改成如下（注意替换GitHub用户名）：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:用户名/用户名.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p><h2 id="博客图片问题处理"><a href="#博客图片问题处理" class="headerlink" title="博客图片问题处理"></a>博客图片问题处理</h2><p>本人采用开源软件MarkText软件进行本地博客编辑，该软件可以在GitHub下载。需要在本地编辑博客和上传部署后的博客上都正常阅览图片，需要安装一些插件来实现该需求，具体操作如下：</p><ul><li><p>在hexo主目录安装插件，在GitBash中输入：<code>npm install hexo-asset-image-for-hexo5 --save</code>  </p></li><li><p>在主目录的<code>_config.yml</code>文件中查找并修改<code>post_asset_folder</code>值为<code>true</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul><p>这样在使用<code>hexo new &quot;article&quot;</code>创建新博客文章的时候，就会发现在文章的同级目录出现和md文件名相同的文件夹，可以在这个文件夹中放该文章的图片，例如test.png。例：</p><table><thead><tr><th>1  <br>2  <br>3</th><th>├─article  <br>├──test.png  <br>└─article.md</th></tr></thead></table><ul><li>写法：在文章里即可使用<code>![](./article/test.png)</code>在本地显示图片<code>test.png</code>，同时在静态网页中也可以正常显示。</li></ul><p><strong>注意：</strong>本文的hexo版本为6.2.0（可以通过hexo v查看），这里安装的图像插件为hexo-asset-image-for-hexo5是适用的（hexo5版本以上建议使用 hexo-asset-image-for-hexo5 ），网上绝大部分博客说的<code>npm install hexo-asset-image --save</code>经本人测试并不适配6.2.0版本的hexo。</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p><strong>发布文章</strong></p><p>进入博客所在目录，右键打开 Git Bash Here，创建博文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo new &quot;My New Post&quot;<br></code></pre></td></tr></table></figure><p>然后 source 文件夹中会出现一个 My New Post.md 文件，就可以使用MarkText在该文件中撰写文章了。</p><p>写完后运行下面代码将文章渲染并部署到 GitHub Pages 上完成发布。<strong>以后每次发布文章都是这三条命令。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo clean   # 清除缓存和已生成的静态文件<br>hexo g   # 生成页面<br>hexo d   # 部署发布<br></code></pre></td></tr></table></figure><p>也可以不使用命令自己创建 .md 文件，只需在文件开头手动加入如下格式 Front-matter 即可，写完后运行 <code>hexo clean、hexo g</code> 和 <code>hexo d</code> 发布。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: Hello World # 标题<br>date: 2019/3/26 hh:mm:ss # 时间<br>categories: # 分类<br><span class="hljs-bullet">-</span> Diary<br>tags: # 标签<br><span class="hljs-bullet">-</span> PS3<br><span class="hljs-section">- Games</span><br><span class="hljs-section">---</span><br><br>摘要<br>&lt;!--more--&gt;<br>正文<br></code></pre></td></tr></table></figure><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>在 <a href="https://link.zhihu.com/?target=https://hexo.io/themes/">Themes | Hexo</a> 选择一个喜欢的主题，并参照主题的文档来安装和配置主题。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo new &quot;name&quot;       # 新建文章<br>hexo new page &quot;name&quot;  # 新建页面<br>hexo g                # 生成页面<br>hexo d                # 部署<br>hexo g -d             # 生成页面并部署<br>hexo s                # 本地预览<br>hexo clean            # 清除缓存和已生成的静态文件<br>hexo help             # 帮助<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a></p><p><a href="https://www.idealx.cn/post/Hexo/hexo-asset-image/">在Hexo中使用本地图片 - 个人学习 (idealx.cn)</a></p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
