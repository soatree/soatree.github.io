<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FatTree</title>
  
  
  <link href="http://soatree.github.io/atom.xml" rel="self"/>
  
  <link href="http://soatree.github.io/"/>
  <updated>2023-08-03T13:48:23.019Z</updated>
  <id>http://soatree.github.io/</id>
  
  <author>
    <name>胖树</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>瓦尔登湖</title>
    <link href="http://soatree.github.io/2023/07/28/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96/"/>
    <id>http://soatree.github.io/2023/07/28/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96/</id>
    <published>2023-07-28T14:44:44.000Z</published>
    <updated>2023-08-03T13:48:23.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《瓦尔登湖》 亨利·戴维·梭罗　上海译文出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>无论如何古老的思想与行为，除非有确证，便不可以轻信。</li><li>大部分的奢侈品，大部分的所谓生活的舒适，非但没有必要，而且对人类进步大有妨碍。所以关于奢侈与舒适，最明智的人生活得甚至比穷人更加简单和朴素。</li><li>我们的发明常常是漂亮的玩具，只是吸引我们的注意力，使我们离开了严肃的事物。它们只是对毫无改进的目标提供一些改进过的方法，其实这目标早就可以很容易地到达的；就像直达波士顿或直达纽约的铁路那样。</li><li>因为我对某些事物有所偏爱，而又特别的重视我的自由，因为我能吃苦，而又能获得些成功，我并不希望花掉我的时间来购买富丽的地毡，或别的讲究的家具，或美味的食物，或希腊式的或哥特式的房屋。如果有人能毫无困难地得到这一些，得到之后，更懂得如何利用它们，我还是让他们去追求。有些人的“勤恳”，爱劳动好像是生就的，或者因为劳动可以使他们免得干更坏的事；对于这种人，暂时我没有什么话说。至于那些人，如果有了比现在更多的闲暇，而不知如何处理，那我要劝他们加倍勤恳地劳动，——劳动到他们能养活自己，取得他们的自由证明书。我自己是觉得，任何职业中，打短工最为独立不羁，何况一年之内只要三四十天就可以养活自己。短工的一天结束于太阳落山的时候，之后他可以自由地专心于他自己选定的跟他的劳动全不相干的某种活动；而他的雇主要投机取巧，从这个月到下一个月，一年到头得不到休息。</li><li>我认识一个继承了几英亩地的年轻人，他告诉我他愿意像我一样生活，如果他有办法的话。我却不愿意任何人由于任何原因，而采用我的生活方式；因为，也许他还没有学会我的这一种，说不定我已经找到了另一种方式，我希望世界上的人，越不相同越好；但是我愿意每一个人都能谨慎地找出并坚持他自己的合适方式，而不要采用他父亲的，或母亲的，或邻居的方式。年轻人可以建筑，也可以耕种，也可以航海，只要不阻挠他去做他告诉我他愿意做的事，就好了。人是聪明的，因为他能计算；水手和逃亡的奴隶都知道眼睛盯住北极星；这些观点是管保用上一辈子的了。</li><li>一个人越是有许多事情能够放得下，他越是富有。</li><li>你们要尽可能长久地生活得自由，生活得并不执著才好。执迷于一座田园，和关在县政府的监狱中，简直没有分别</li><li>我到林中去，因为我希望谨慎地生活，只面对生活的基本事实，看看我是否学得到生活要教育我的东西，免得到了临死的时候，才发现我根本就没有生活过。我不希望度过非生活的生活，生活是这样的可爱；我却也不愿意去修行过隐逸的生活，除非是万不得已。我要生活得深深地把生命的精髓都吸到，要生活得稳稳当当，生活得斯巴达式的，以便根除一切非生活的东西，划出一块刈割的面积来，细细地刈割或修剪，把生活压缩到一个角隅里去，把它缩小到最低的条件中，如果它被证明是卑微的，那末就把那真正的卑微全部认识到，并把它的卑微之处公布于世界；或者，如果它是崇高的，就用切身的经历来体会它，在我下一次远游时，也可以作出一个真实的报道。</li><li>什么新闻！要知道永不衰老的事件，那才是更重要得多！</li><li>如果我们不慌不忙而且聪明，我们会认识唯有伟大而优美的事物才有永久的绝对的存在，——琐琐的恐惧与碎碎的欢喜不过是现实的阴影。现实常常是活泼而崇高的。由于闭上了眼睛，神魂颠倒，任凭自己受影子的欺骗，人类才建立了他们日常生活的轨道和习惯，到处遵守它们，其实它们是建筑在纯粹幻想的基础之上的。</li><li>生也好，死也好，我们仅仅追求现实。如果我们真要死了，让我们听到我们喉咙中的咯咯声，感到四肢上的寒冷好了；如果我们活着，让我们干我们的事务。</li><li>我爱给我的生命留有更多余地。有时候，在一个夏天的早晨里，照常洗过澡之后，我坐在阳光下的门前，从日出坐到正午，坐在松树，山核桃树和黄栌树中间，在没有打扰的寂寞与宁静之中，凝神沉思，那时鸟雀在四周唱歌，或默不作声地疾飞而过我的屋子，直到太阳照上我的西窗，或者远处公路上传来一些旅行者的车辆的辚辚声，提醒我时间的流逝。我在这样的季节中生长，好像玉米生长在夜间一样，这比任何手上的劳动好得不知多少了。这样做不是从我的生命中减去了时间，而是在我通常的时间里增添了许多，还超产了许多。我明白了东方人的所谓沉思以及抛开工作的意思了。大体上，虚度岁月，我不在乎。</li><li>我欢喜经常保持清醒，而陶醉的程度是无穷的。我相信一个聪明人的唯一饮料是白开水，酒并不是怎样高贵的液体，试想一杯热咖啡足以捣毁一个早晨的希望，一杯热茶又可以把晚上的美梦破坏掉！啊，受到它们的诱惑之后，我曾经如何地堕落过！甚至音乐也可以使人醉倒。就是这一些微小的原因竟毁灭过希腊和罗马，将来还要毁灭英国和美国。一切醉人的事物之中，谁不愿意因为呼吸了新鲜空气而陶醉呢？我反对长时间的拼命做苦工的理由是它强迫我也拼命地吃和喝。可是说实话，在这些方面，近来我似乎也不那么挑剔了。我很少把宗教带上食桌，我也不寻求祝福，这却不是因为我更加聪明了，我不能不从实供认，而是因为，不管多么遗憾，我也一年年地更加粗俗了，更加冷漠了。</li><li>“心不在焉，”曾子说过，“视而不见，听而不闻，食而不知其味。”能知道食物的真味的人决不可能成为饕餮；不这样的人才是饕餮。一个清教徒可能狂吞他的面包皮屑，正如一个议员大嚼甲鱼。食物入口并不足以玷辱一个人，但他吃这种食物的胃口却足以玷辱他。问题不在量，不在质，而在口腹的贪嗜上；如果吃东西不是为了养活我们的生命，也不是为了激励我们的精神生活，而是为了在肚皮里缠住我们的蛔虫。一个猎者爱吃乌龟、麝鼠或其他野蛮的食物，一个漂亮太太爱吃小牛蹄做的冻肉，或海外的沙丁鱼，他们是一样的。</li><li>智慧和纯洁来之于力行；从懒惰中却出现了无知和淫欲。对一个学生来说，淫欲是他心智懒惰的结果，一个不洁的人往往是一个懒惰的人：他坐在炉边烤火，他在阳光照耀下躺着，他没有疲倦，就要休息。如果要避免不洁和一切罪恶，你就热忱地工作吧，即使是打扫马厩也行。天性难于克制，但必须克制</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>正如序言所说，这是一本极其安静的书，只有在极其安静的情况下才能读的进去。我还不够安静，所以也就读进去了三四成，后面大部分草草翻过。作者部分的心境我是体会到了一些，不过关于瓦尔登湖的景色，实在了解有限。<br>梭罗向我们展示了彻底自由的生活，不为物质和别人而活，只是听从自己的内心为自己而活，按照自己的内心的意愿去活就是活着的意义。每个人都是自由的，不要被物质所束缚，不要被心中的杂念所束缚，你也是自由的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h1&gt;&lt;p&gt;《瓦尔登湖》 亨利·戴维·梭罗　上海译文出版社&lt;/p&gt;
&lt;h1 id=&quot;摘录&quot;&gt;&lt;a href=&quot;#摘录&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="读书" scheme="http://soatree.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://soatree.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>八股文-redis</title>
    <link href="http://soatree.github.io/2023/07/26/%E5%85%AB%E8%82%A1%E6%96%87-redis/"/>
    <id>http://soatree.github.io/2023/07/26/%E5%85%AB%E8%82%A1%E6%96%87-redis/</id>
    <published>2023-07-26T00:48:28.000Z</published>
    <updated>2023-08-03T13:01:56.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整理redis的相关面试题，题目来源微信公众号。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Redis的高性能体现在哪些方面？"><a href="#Redis的高性能体现在哪些方面？" class="headerlink" title="Redis的高性能体现在哪些方面？"></a>Redis的高性能体现在哪些方面？</h2><ol><li>纯内存访问</li><li>非阻塞I&#x2F;O，Redis使用epoll作为I&#x2F;O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I&#x2F;O上浪费过多的时间</li><li>单线程避免了线程切换和竞态产生的消耗</li></ol><p>参考：<br>《Redis开发与运维》 付磊　张益军 机械工业出版社</p><h2 id="Redis的常见数据类型？底层是怎么实现的？"><a href="#Redis的常见数据类型？底层是怎么实现的？" class="headerlink" title="Redis的常见数据类型？底层是怎么实现的？"></a>Redis的常见数据类型？底层是怎么实现的？</h2><p><img src="/2023/07/26/%E5%85%AB%E8%82%A1%E6%96%87-redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="redis数据结构"><br><img src="/2023/07/26/%E5%85%AB%E8%82%A1%E6%96%87-redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81.png" alt="redis数据结构内部编码"></p><p>type命令实际返回的就是当前键的数据结构类型，它们分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合），但这些只是Redis对外的数据结构。</p><p>实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码。</p><p>参考：<br>《Redis开发与运维》 付磊　张益军 机械工业出版社</p><h2 id="Redis的pipeline机制有了解过？"><a href="#Redis的pipeline机制有了解过？" class="headerlink" title="Redis的pipeline机制有了解过？"></a>Redis的pipeline机制有了解过？</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Pipeline（流水线）能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端。</p><p><img src="/2023/07/26/%E5%85%AB%E8%82%A1%E6%96%87-redis/pipeline.png" alt="pipeline"></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mdel</span>(List&lt;<span class="hljs-built_in">String</span>&gt; keys) &#123;<br>    Jedis jedis = <span class="hljs-keyword">new </span><span class="hljs-class title_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    <span class="hljs-comment">// 1)生成pipeline对象</span><br>    Pipeline pipeline = jedis.<span class="hljs-property">pipelined</span>();<br>    <span class="hljs-comment">// 2)pipeline执行命令，注意此时命令并未真正执行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span> : keys) &#123;<br>        pipeline.<span class="hljs-property">del</span>(<span class="hljs-built_in">key</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3)执行命令</span><br>    pipeline.<span class="hljs-property">sync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原生批量命令与Pipeline对比"><a href="#原生批量命令与Pipeline对比" class="headerlink" title="原生批量命令与Pipeline对比"></a>原生批量命令与Pipeline对比</h3><p>可以使用Pipeline模拟出批量操作的效果，但是在使用时要注意它与原生批量命令的区别，具体包含以下几点：</p><ul><li><p>原生批量命令是原子的，Pipeline是非原子的。</p></li><li><p>原生批量命令是一个命令对应多个key，Pipeline支持多个命令。</p></li><li><p>原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。</p></li></ul><h3 id="集群pipeline"><a href="#集群pipeline" class="headerlink" title="集群pipeline"></a>集群pipeline</h3><ul><li>串行IO</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Map&lt;String, String&gt; serial<span class="hljs-constructor">IOMget(List&lt;String&gt; <span class="hljs-params">keys</span>)</span> &#123;<br>    <span class="hljs-comment">// 结果集</span><br>    Map&lt;String, String&gt; keyValueMap = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">// 属于各个节点的key列表,JedisPool要提供基于ip和port的hashcode方法</span><br>    Map&lt;JedisPool, List&lt;String&gt;&gt; nodeKeyListMap = <span class="hljs-keyword">new</span> HashMap&lt;JedisPool, List&lt;String&gt;&gt;<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">// 遍历所有的key</span><br>    <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>        <span class="hljs-comment">// 使用CRC16本地计算每个key的slot</span><br>        <span class="hljs-built_in">int</span> slot = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JedisClusterCRC16</span>.</span></span>get<span class="hljs-constructor">Slot(<span class="hljs-params">key</span>)</span>;<br>        <span class="hljs-comment">// 通过jedisCluster本地slot-&gt;node映射获取slot对应的node</span><br>        JedisPool jedisPool = jedisCluster.get<span class="hljs-constructor">ConnectionHandler()</span>.getJedisPoolFrom<br>            <span class="hljs-constructor">Slot(<span class="hljs-params">slot</span>)</span>;<br>        <span class="hljs-comment">// 归档</span><br>        <span class="hljs-keyword">if</span> (nodeKeyListMap.contains<span class="hljs-constructor">Key(<span class="hljs-params">jedisPool</span>)</span>) &#123;<br>            nodeKeyListMap.get(jedisPool).add(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            List&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;<span class="hljs-literal">()</span>;<br>            <span class="hljs-built_in">list</span>.add(key);<br>            nodeKeyListMap.put(jedisPool, <span class="hljs-built_in">list</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 从每个节点上批量获取，这里使用mget也可以使用pipeline</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;JedisPool, List&lt;String&gt;&gt; entry : nodeKeyListMap.entry<span class="hljs-constructor">Set()</span>) &#123;<br>        JedisPool jedisPool = entry.get<span class="hljs-constructor">Key()</span>;<br>       List&lt;String&gt; nodeKeyList = entry.get<span class="hljs-constructor">Value()</span>;<br>        <span class="hljs-comment">// 列表变为数组</span><br>        String<span class="hljs-literal">[]</span> nodeKeyArray = nodeKeyList.<span class="hljs-keyword">to</span><span class="hljs-constructor">Array(<span class="hljs-params">new</span> String[<span class="hljs-params">nodeKeyList</span>.<span class="hljs-params">size</span>()</span>]);<br>        <span class="hljs-comment">// 批量获取，可以使用mget或者Pipeline</span><br>        List&lt;String&gt; nodeValueList = jedisPool.get<span class="hljs-constructor">Resource()</span>.mget(nodeKeyArray);<br>        <span class="hljs-comment">// 归档</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nodeKeyList.size<span class="hljs-literal">()</span>; i++) &#123;<br>            keyValueMap.put(nodeKeyList.get(i), nodeValueList.get(i));<br>        &#125;<br>    &#125;<br>    return keyValueMap;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>并行IO</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">parallelIOMget</span>(<span class="hljs-params">List&lt;<span class="hljs-built_in">String</span>&gt; keys</span>) &#123;<br>    <span class="hljs-comment">// 结果集</span><br>    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>&gt; keyValueMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>&gt;();<br>    <span class="hljs-comment">// 属于各个节点的key列表</span><br>    <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">JedisPool</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;&gt; nodeKeyListMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">JedisPool</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;&gt;();<br>    ...和前面一样<br>    <span class="hljs-comment">// 多线程mget，最终汇总结果，也可pipeline</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">Entry</span>&lt;<span class="hljs-title class_">JedisPool</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;&gt; entry : nodeKeyListMap.<span class="hljs-title function_">entrySet</span>()) &#123;<br>        <span class="hljs-comment">// 多线程实现</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> keyValueMap;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>hash_tag</li></ul><p>将多个key强制分配到一个节点上，它的操作时间&#x3D;1次网络时间+n次命令时间，这里换成pipeline即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">hashTagMget</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] hashTagKeys</span>) &#123;<br>    <span class="hljs-keyword">return</span> jedisCluster.<span class="hljs-title function_">mget</span>(hashTagKeys);<br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<br>《Redis开发与运维》 付磊　张益军 机械工业出版社</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>为了保证多条命令组合的原子性，Redis提供了简单的事务功能以及集成Lua脚本来解决这个问题。</p><h3 id="Redis的事务怎么实现？有什么缺点？"><a href="#Redis的事务怎么实现？有什么缺点？" class="headerlink" title="Redis的事务怎么实现？有什么缺点？"></a>Redis的事务怎么实现？有什么缺点？</h3><ul><li>事务实现</li></ul><p>Redis提供了简单的事务功能，将一组需要一起执行的命令放到multi和exec两个命令之间。multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子顺序执行的</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; multi<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd user:a:follow user:b<br>QUEUED<br><span class="hljs-number">127.0.0.1:6379</span>&gt; sadd user:b:fans user:a<br>QUEUED<br></code></pre></td></tr></table></figure><p>可以看到sadd命令此时的返回结果是QUEUED，代表命令并没有真正执行，而是暂时保存在Redis中。如果此时另一个客户端执行sismember user：a：follow user：b返回结果应该为0。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; sismember user:a:follow user:b<br>(integer) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>只有当exec执行后，用户A关注用户B的行为才算完成，如下所示返回的两个结果对应sadd命令。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; exec<br><span class="hljs-number">1</span>) (integer) <span class="hljs-number">1</span><br><span class="hljs-number">2</span>) (integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; sismember user:a:follow user:b<br>(integer) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>如果要停止事务的执行，可以使用discard命令代替exec命令即可。</p><p>命令语法错误将导致事务无法执行；非语法错误将正常执行</p><p>watch命令可以提供类似乐观锁的功能，会在exec执行前观察watch 的 key是否发生变化，如果变化则不会执行事务</p><ul><li>缺点</li></ul><p>不支持事务中的回滚特性，同时无法实现命令之间的逻辑关系计算</p><h3 id="Redis结合lua有什么作用？Eval和evalsha的区别？"><a href="#Redis结合lua有什么作用？Eval和evalsha的区别？" class="headerlink" title="Redis结合lua有什么作用？Eval和evalsha的区别？"></a>Redis结合lua有什么作用？Eval和evalsha的区别？</h3><h4 id="Redis结合lua有什么作用"><a href="#Redis结合lua有什么作用" class="headerlink" title="Redis结合lua有什么作用"></a>Redis结合lua有什么作用</h4><p>Lua脚本在Redis中是原子执行的，执行过程中间不会插入其他命令，实现事务功能。</p><p>Lua脚本可以帮助开发和运维人员创造出自己定制的命令，并可以将这些命令常驻在Redis内存中，实现复用的效果。</p><p>Lua脚本可以将多条命令一次性打包，有效地减少网络开销。</p><h4 id="Eval和evalsha的区别"><a href="#Eval和evalsha的区别" class="headerlink" title="Eval和evalsha的区别"></a>Eval和evalsha的区别</h4><ul><li>eval</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">eval</span> 脚本内容 <span class="hljs-built_in">key</span>个数 <span class="hljs-built_in">key</span>列表 参数列表<br></code></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; eval &#x27;return <span class="hljs-string">&quot;hello &quot;</span> .. KEYS<span class="hljs-string">[1]</span> .. ARGV<span class="hljs-string">[1]</span>&#x27; <span class="hljs-number">1</span> redis world<br><span class="hljs-string">&quot;hello redisworld&quot;</span><br></code></pre></td></tr></table></figure><p>如果Lua脚本较长，还可以使用redis-cli–eval直接执行文件。eval命令和–eval参数本质是一样的，客户端如果想执行Lua脚本，首先在客户端编写好Lua脚本代码，然后把脚本作为字符串发送给服务端，服务端会将执行结果返回给客户端</p><p><img src="/2023/07/26/%E5%85%AB%E8%82%A1%E6%96%87-redis/eval.png" alt="eval"></p><ul><li>evalsha</li></ul><p>除了使用eval，Redis还提供了evalsha命令来执行Lua脚本。首先要将Lua脚本加载到Redis服务端，得到该脚本的SHA1校验和，evalsha命令使用SHA1作为参数可以直接执行对应Lua脚本，避免每次发送Lua脚本的开销。这样客户端就不需要每次执行脚本内容，而脚本也会常驻在服务端，脚本功能得到了复用</p><p>加载脚本：script load命令可以将脚本内容加载到Redis内存中，例如下面将lua_get.lua加载到Redis中，得到SHA1为：”7413dc2440db1fea7c0a0bde841fa68eefaf149c”</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># redis-cli script load <span class="hljs-string">&quot;$(cat lua_get.lua)&quot;</span></span><br><span class="hljs-string">&quot;7413dc2440db1fea7c0a0bde841fa68eefaf149c&quot;</span><br></code></pre></td></tr></table></figure><p>执行脚本：evalsha的使用方法如下，参数使用SHA1值，执行逻辑和eval一致。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">evalsha 脚本SHA1值 <span class="hljs-built_in">key</span>个数 <span class="hljs-built_in">key</span>列表 参数列表<br></code></pre></td></tr></table></figure><p>所以只需要执行如下操作，就可以调用lua_get.lua脚本：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; evalsha 7413dc2440db1fea7c0a0bde841fa68eefaf149c <span class="hljs-number">1</span> redis world<br><span class="hljs-string">&quot;hello redisworld&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/07/26/%E5%85%AB%E8%82%A1%E6%96%87-redis/evalsha.png" alt="evalsha"></p><p>参考：<br>《Redis开发与运维》 付磊　张益军 机械工业出版社</p><h2 id="hyperloglog"><a href="#hyperloglog" class="headerlink" title="hyperloglog"></a>hyperloglog</h2><p>HyperLogLog并不是一种新的数据结构（实际类型为字符串类型），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。</p><p>HyperLogLog提供了3个命令：pfadd、pfcount、pfmerge</p><ul><li>添加</li></ul><p>pfadd key element [element …]</p><ul><li>计算独立用户数</li></ul><p>pfcount key [key …]</p><ul><li>合并</li></ul><p>pfmerge destkey sourcekey [sourcekey …]</p><p>HyperLogLog内存占用量非常小，但是存在错误率，开发者在进行数据结构选型时只需要确认如下两条即可：</p><ul><li><p>只为了计算独立总数，不需要获取单条数据。</p></li><li><p>可以容忍一定误差率，毕竟HyperLogLog在内存的占用量上有很大的优势。</p></li></ul><p>参考：<br>《Redis开发与运维》 付磊　张益军 机械工业出版社</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p><p>手动触发分别对应save和bgsave命令。save命令已经废弃。bgsave命令使Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束，阻塞只发生在fork阶段，一般时间很短。</p><p>除了执行命令手动触发之外，Redis内部还存在自动触发RDB的持久化机制，例如以下场景：</p><ul><li>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</li><li>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点，更多细节见6.3节介绍的复制原理。</li><li>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。</li></ul><h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><p>RDB的优点：</p><ul><li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。</li><li>Redis加载RDB恢复数据远远快于AOF的方式。</li></ul><p>RDB的缺点：</p><ul><li>RDB方式数据没办法做到实时持久化&#x2F;秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li><li>Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。</li></ul><p>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。开启AOF功能需要设置配置：appendonly yes，默认不开启。</p><h4 id="AOF的工作流程如下"><a href="#AOF的工作流程如下" class="headerlink" title="AOF的工作流程如下"></a>AOF的工作流程如下</h4><p><img src="/2023/07/26/%E5%85%AB%E8%82%A1%E6%96%87-redis/AOF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="AOF工作流程"></p><ol><li>所有的写入命令会追加到aof_buf（缓冲区）中。</li><li>AOF缓冲区根据对应的策略向硬盘做同步操作。</li><li>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</li><li>当Redis服务器重启时，可以加载AOF文件进行数据恢复。</li></ol><h4 id="AOF为什么把命令追加到aof-buf中？"><a href="#AOF为什么把命令追加到aof-buf中？" class="headerlink" title="AOF为什么把命令追加到aof_buf中？"></a>AOF为什么把命令追加到aof_buf中？</h4><p>Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。</p><h4 id="Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制"><a href="#Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制" class="headerlink" title="Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制"></a>Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制</h4><p>配置为always时，每次写入都要同步AOF文件，在一般的SATA硬盘上，Redis只能支持大约几百TPS写入，显然跟Redis高性能特性背道而驰，不建议配置。</p><p>配置为no，由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。</p><p>配置为everysec，是建议的同步策略，也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据。</p><h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。</p><p>重写后的AOF文件为什么可以变小？有如下原因：</p><ul><li>进程内已经超时的数据不再写入文件。</li><li>旧的AOF文件含有无效命令，如del key1、hdel key2、srem keys、set a111、set a222等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。</li><li>多条写命令可以合并为一个，如：lpush list a、lpush list b、lpush list c可以转化为：lpush list a b c。为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。</li></ul><p>AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快地被Redis加载。</p><p>AOF重写过程可以手动触发和自动触发：</p><ul><li>手动触发：直接调用bgrewriteaof命令。</li><li>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。auto-aof-rewrite-percentage：代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。自动触发时机&#x3D;aof_current_size&gt;auto-aof-rewrite-min-size&amp;&amp;（aof_current_size-aof_base_size）&#x2F;aof_base_size&gt;&#x3D;auto-aof-rewrite-percentage。其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。</li></ul><h4 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h4><p>总体看来优先加载AOF文件，其次加载RDB文件。</p><p><img src="/2023/07/26/%E5%85%AB%E8%82%A1%E6%96%87-redis/%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD.png" alt="持久化文件加载"></p><p>参考：<br>《Redis开发与运维》 付磊　张益军 机械工业出版社</p><ol start="2"><li>Redis的主备同步流程？</li></ol><p>书 6.3</p><ol start="4"><li>Redis有几种部署模式？重点讲下集群和哨兵机制的实现？</li></ol><p>集群放key流程</p><ol start="14"><li>如果Redis主备切换回发生什么问题？</li></ol><p>网络<br>17. Redis的reactor模型能否介绍下？</p><p>实践<br>8. 常见的Redis的优化方案？<br>9. 常见的Redis问题？缓存击穿，缓存雪崩，热点key问题解决方案？<br>10. Redis在集群下做分布式锁有什么优缺点？<br>12. Redis的过期策略怎么实现的？Redis的淘汰策略是怎么实现的？<br>16. Redis如果cpu过高，怎么解决？在使用中有出现什么问题？是怎么解决的？<br>20. 如果有海量的数据，怎么查询某个key是否存在？<br>21. 如果要统计某一天的页面访问量怎么实现？</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ">微信公众号:我的IT技术路</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;整理redis的相关面试题，题目来源微信公众号。&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="中间件" scheme="http://soatree.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="面试" scheme="http://soatree.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>TCP连接的TIME_WAIT和CLOSE_WAIT状态解说(转载)</title>
    <link href="http://soatree.github.io/2023/06/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84TIME-WAIT%E5%92%8CCLOSE-WAIT%E7%8A%B6%E6%80%81%E8%A7%A3%E8%AF%B4-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://soatree.github.io/2023/06/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84TIME-WAIT%E5%92%8CCLOSE-WAIT%E7%8A%B6%E6%80%81%E8%A7%A3%E8%AF%B4-%E8%BD%AC%E8%BD%BD/</id>
    <published>2023-06-24T07:10:11.000Z</published>
    <updated>2023-07-15T01:41:50.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近阅读到一篇关于TCP连接的TIME_WAIT和CLOSE_WAIT状态的博客，感觉博主讲的十分通透，怕后续博文失联，特别整理转载一下，博客的原链接是<a href="https://www.cnblogs.com/kevingrace/p/9988354.html">TCP连接的TIME_WAIT和CLOSE_WAIT 状态解说</a>，以下为正文</p><hr><p>相信很多运维工程师遇到过这样一个情形: 用户反馈网站访问巨慢, 网络延迟等问题, 然后就迫切地登录服务器,终端输入命令”netstat -anp | grep TIME_WAIT | wc -l “ 查看一下, 接着发现有几百几千甚至几万个TIME_WAIT 连接数. 顿时慌了~</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs makefile">通过 <span class="hljs-string">&quot;netstat  -anp | grep TIME_WAIT | wc -l&quot;</span>  命令查看数量,发现TIME_WAIT的连接数量很多! 可能是因为服务器主动关闭连接导致TIME_WAIT产生了很多.<br>发现系统存在大量TIME_WAIT状态的连接, 可以通过调整系统内核参数来解决:<br>   <br>打开 sysctl.conf 文件，修改以下几个参数：<br>[root@web01 ~]<span class="hljs-comment"># vim  /etc/sysctl.conf</span><br>net.ipv4.tcp_tw_reuse = 1<br>net.ipv4.tcp_tw_recycle = 1<br>net.ipv4.tcp_timestamps = 1<br> <br>net.ipv4.tcp_syncookies = 1<br>net.ipv4.tcp_fin_timeout = 30<br>   <br>[root@web01 ~]<span class="hljs-comment"># sysctl -p</span><br>   <br><span class="hljs-section">接着被告知: 开启tw_recylce和tw_reuse功能, 一定需要timestamps的支持，而且这些配置一般不建议开启，但是对解决TIME_WAIT很多的问题，有很好的用处。</span><br>果然, 经过如上配置后, 过了几分钟，再查看TIME_WAIT的数量快速下降了不少，并且后面也没发现哪个用户说有问题了. 做到这里, 相信大多数运维人员想当然地以<br>为问题已经解决了,但是，要彻底理解并解决这个问题，可能就没这么简单，或者说，要想彻底搞清楚并解决这个问题, 还是有很长的路要走滴!<br>   <br><span class="hljs-section">相关查看命令:</span><br>[root@web01 ~]<span class="hljs-comment"># netstat -n | awk &#x27;/^tcp/ &#123;++state[$NF]&#125; END &#123;for(key in state) print key,&quot;\t&quot;,state[key]&#125;&#x27;</span><br><span class="hljs-section">会得到类似下面的结果,具体数字会有所不同:</span><br>LAST_ACK 1<br>SYN_RECV 14<br>ESTABLISHED 79<br>FIN_WAIT1 28<br>FIN_WAIT2 3<br>CLOSING 5<br>TIME_WAIT 1669<br>   <br>[root@web01 ~]<span class="hljs-comment"># sysctl -a | grep time | grep wait</span><br>net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120<br>net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60<br>net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120<br>   <br>执行命令<span class="hljs-string">&quot;netstat -na&quot;</span>查看到的相关TCP状态解释:<br><span class="hljs-section">LISTEN:       侦听来自远方的TCP端口的连接请求;</span><br><span class="hljs-section">SYN-SENT:     在发送连接请求后等待匹配的连接请求;</span><br><span class="hljs-section">SYN-RECEIVED: 在收到和发送一个连接请求后等待对方对连接请求的确认;</span><br><span class="hljs-section">ESTABLISHED:  代表一个打开的连接;</span><br><span class="hljs-section">FIN-WAIT-1:   等待远程TCP连接中断请求, 或先前的连接中断请求的确认;</span><br><span class="hljs-section">FIN-WAIT-2:   从远程TCP等待连接中断请求;</span><br><span class="hljs-section">CLOSE-WAIT:   等待从本地用户发来的连接中断请求;</span><br><span class="hljs-section">CLOSING:      等待远程TCP对连接中断的确认;</span><br><span class="hljs-section">LAST-ACK:     等待原来的发向远程TCP的连接中断请求的确认;</span><br><span class="hljs-section">TIME-WAIT:    等待足够的时间以确保远程TCP接收到连接中断请求的确认;</span><br><span class="hljs-section">CLOSE:        没有任何连接状态;</span><br></code></pre></td></tr></table></figure><h1 id="什么是TIME-WAIT和CLOSE-WAIT"><a href="#什么是TIME-WAIT和CLOSE-WAIT" class="headerlink" title="什么是TIME-WAIT和CLOSE-WAIT ?"></a>什么是TIME-WAIT和CLOSE-WAIT ?</h1><p>通常来说要想解决问题，就要先理解问题。有时遇到问题,上网百度个解决方案,临时修复了问题,就以为问题已经不在了, 其实问题不是真的不存在了，而是可能隐藏在更深的地方，只是我们没有发现，或者以现有自己的的知识水平无法发现而已。总所周知，由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的:</p><ol><li>主动关闭连接的一方，调用close()；协议层发送FIN包 ;</li><li>被动关闭的一方收到FIN包后，协议层回复ACK；然后被动关闭的一方，进入CLOSE_WAIT状态，主动关闭的一方等待对方关闭，则进入FIN_WAIT_2状态；此时，主动关闭的一方等待被动关闭一方的应用程序，调用close操作 ;</li><li>被动关闭的一方在完成所有数据发送后，调用close()操作；此时，协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入LAST_ACK状态；</li><li>主动关闭的一方收到FIN包，协议层回复ACK；此时，主动关闭连接的一方，进入TIME_WAIT状态；而被动关闭的一方，进入CLOSED状态 ;</li><li>等待2MSL时间，主动关闭的一方，结束TIME_WAIT，进入CLOSED状态 ;</li></ol><p>通过上面的一次socket关闭操作，可以得出以下几点：</p><ol><li>主动关闭连接的一方 – 也就是主动调用socket的close操作的一方，最终会进入TIME_WAIT状态 ;</li><li>被动关闭连接的一方，有一个中间状态，即CLOSE_WAIT，因为协议层在等待上层的应用程序，主动调用close操作后才主动关闭这条连接 ;</li><li>TIME_WAIT会默认等待2MSL时间后，才最终进入CLOSED状态；</li><li>在一个连接没有进入CLOSED状态之前，这个连接是不能被重用的！</li></ol><p><strong>所以说这里凭直觉看，TIME_WAIT并不可怕，CLOSE_WAIT才可怕，因为CLOSE_WAIT很多，表示说要么是你的应用程序写的有问题，没有合适的关闭socket；要么是说，你的服务器CPU处理不过来（CPU太忙）或者你的应用程序一直睡眠到其它地方(锁，或者文件I&#x2F;O等等)，你的应用程序获得不到合适的调度时间，造成你的程序没法真正的执行close操作。</strong></p><p>那么这里又出现两个问题：</p><ol><li>上面提到的连接重用，那连接到底是个什么概念？</li><li>协议层为什么要设计一个TIME_WAIT状态？这个状态为什么默认等待2MSL时间才会进入CLOSED</li></ol><p>先解释清楚这两个问题后, 接着再来看开头提到的&#x2F;etc&#x2F;sysctl.conf文件中那几个网络配置参数究竟有什么用，以及TIME_WAIT的后遗症问题。</p><h2 id="Socket连接到底是个什么概念？"><a href="#Socket连接到底是个什么概念？" class="headerlink" title="Socket连接到底是个什么概念？"></a>Socket连接到底是个什么概念？</h2><p>socket 其实就是一个五元组，包括：源IP, 源端口, 目的IP, 目的端口, 类型(TCP or UDP) . 这个五元组，即标识了一条可用的连接。 需要注意是是，经常有很多人把一个socket定义成四元组，也就是源IP:源端口+目的IP:目的端口，这个定义是不正确的。</p><p>比如说，如果本地出口IP是110.122.144.166，那么你的浏览器在连接某一个Web服务器，例如百度的时候，这条socket连接的四元组可能就是：[110.122.144.166:45678, tcp, 110.88.92.104:80] , 源IP为你的出口IP地址 110.122.144.166，源端口为随机端口 45678，目的IP为百度的某一个负载均衡服务器IP 110.88.92.104，端口为HTTP标准的80端口。</p><p>如果这个时候，你再开一个浏览器，访问百度，将会产生一条新的连接：[110.122.144.166:43678, tcp, 110.88.92.104:80] , 这条新的连接的源端口为一个新的随机端口 43678。如此来看，如果你的本机需要压测百度，那么你最多可以创建多少个连接呢？</p><h2 id="TIME-WAIT有什么用？"><a href="#TIME-WAIT有什么用？" class="headerlink" title="TIME_WAIT有什么用？"></a>TIME_WAIT有什么用？</h2><p>如果来做个类比的话，TIME_WAIT的出现，对应的是你的程序里的异常处理，它的出现，就是为了解决网络的丢包和网络不稳定所带来的其他问题：</p><ol><li>防止前一个连接【五元组，这里继续以 110.122.144.166:45678, tcp, 110.88.92.104:80 为例】上延迟的数据包或者丢失重传的数据包，被后面复用的连接【前一个连接关闭后，此时你再次访问百度，新的连接可能还是由110.122.144.166:45678, tcp, 110.88.92.104:80 这个五元组来表示，也就是源端口凑巧还是45678】错误的接收（异常：数据丢了，或者传输太慢了），参见下图：</li></ol><p><img src="/2023/06/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84TIME-WAIT%E5%92%8CCLOSE-WAIT%E7%8A%B6%E6%80%81%E8%A7%A3%E8%AF%B4-%E8%BD%AC%E8%BD%BD/time-wiat%E7%BC%BA%E5%A4%B1%E5%AF%BC%E8%87%B4%E9%94%99%E8%AF%AF%E6%8E%A5%E5%8F%97.png" alt="time-wiat缺失导致错误接受"></p><ul><li>SEQ&#x3D;3的数据包丢失，重传第一次，没有得到ACK确认</li><li>如果没有TIME_WAIT，或者TIME_WAIT时间非常端，那么关闭的连接【110.122.144.166:45678, tcp, 110.88.92.104:80 的状态变为了CLOSED，源端口可被再次利用】，马上被重用【对110.88.92.104:80新建的连接，复用了之前的随机端口45678】，并连续发送SEQ&#x3D;1,2 的数据包; </li><li>此时，前面的连接上的SEQ&#x3D;3的数据包再次重传，同时，seq的序号刚好也是3（这个很重要，不然，SEQ的序号对不上，就会RST掉），此时，前面一个连接上的数据被后面的一个连接错误的接收;</li></ul><ol start="2"><li>确保连接方能在时间范围内，关闭自己的连接。其实，也是因为丢包造成的，参见下图：</li></ol><p><img src="/2023/06/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84TIME-WAIT%E5%92%8CCLOSE-WAIT%E7%8A%B6%E6%80%81%E8%A7%A3%E8%AF%B4-%E8%BD%AC%E8%BD%BD/time-wait%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD.png" alt="time-wait未正确关闭"></p><ul><li>主动关闭方关闭了连接，发送了FIN；</li><li>被动关闭方回复ACK同时也执行关闭动作，发送FIN包；此时，被动关闭的一方进入LAST_ACK状态; </li><li>主动关闭的一方回去了ACK，主动关闭一方进入TIME_WAIT状态；</li><li>但是最后的ACK丢失，被动关闭的一方还继续停留在LAST_ACK状态; </li><li>此时，如果没有TIME_WAIT的存在，或者说，停留在TIME_WAIT上的时间很短，则主动关闭的一方很快就进入了CLOSED状态，也即是说，如果此时新建一个连接，源随机端口如果被复用，在connect发送SYN包后，由于被动方仍认为这条连接【五元组】还在等待ACK，但是却收到了SYN，则被动方会回复RST; </li><li>造成主动创建连接的一方，由于收到了RST，则连接无法成功;</li></ul><p>所以，这里看到了，TIME_WAIT的存在是很重要的，如果强制忽略TIME_WAIT，还是有很高的机率，造成数据粗乱，或者短暂性的连接失败。那么，为什么说TIME_WAIT状态会是持续2MSL（2倍的max segment lifetime）呢？这个时间可以通过修改内核参数调整吗？第一，这个2MSL，是RFC 793里定义的，参见RFC的截图标红的部分：</p><p><img src="/2023/06/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84TIME-WAIT%E5%92%8CCLOSE-WAIT%E7%8A%B6%E6%80%81%E8%A7%A3%E8%AF%B4-%E8%BD%AC%E8%BD%BD/RFC793.png" alt="RFC793"></p><p>这个定义，更多的是一种保障（IP数据包里的TTL，即数据最多存活的跳数，真正反应的才是数据在网络上的存活时间），确保最后丢失了ACK，被动关闭的一方再次重发FIN并等待回复的ACK，一来一去两个来回。内核里，写死了这个MSL的时间为：30秒（有读者提醒，RFC里建议的MSL其实是2分钟，但是很多实现都是30秒），所以TIME_WAIT的即为1分钟.  所以，再次回想一下前面的问题，如果一条连接，即使在四次握手关闭了，由于TIME_WAIT的存在，这个连接，在1分钟之内，也无法再次被复用，那么，如果你用一台机器做压测的客户端，你一分钟能发送多少并发连接请求？如果这台是一个负载均衡服务器，一台负载均衡服务器，一分钟可以有多少个连接同时访问后端的服务器呢？</p><h2 id="TIME-WAIT很多，可怕吗？"><a href="#TIME-WAIT很多，可怕吗？" class="headerlink" title="TIME_WAIT很多，可怕吗？"></a>TIME_WAIT很多，可怕吗？</h2><p>如果你通过 “ss -tan state time-wait | wc -l” 发现，系统中有很多TIME_WAIT，看到时相信很多人都会紧张。多少算多呢？<strong>几百几千？如果是这个量级，其实真的没必要紧张。因为: 这个量级，因为TIME_WAIT所占用的内存很少很少；因为记录和寻找可用的local port所消耗的CPU也基本可以忽略</strong>。会占用内存吗？当然！任何你可以看到的数据，内核里都需要有相关的数据结构来保存这个数据啊。一条Socket处于TIME_WAIT状态，它也是一条“存在“的socket，内核里也需要有保持它的数据：</p><ol><li>内核里有保存所有连接的一个hash table，这个hash table里面既包含TIME_WAIT状态的连接，也包含其他状态的连接。主要用于有新的数据到来的时候，从这个hash table里快速找到这条连接。不同的内核对这个hash table的大小设置不同，你可以通过dmesg命令去找到你的内核设置的大小：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">[root<span class="hljs-variable">@web01</span> <span class="hljs-operator">~</span>]# dmesg <span class="hljs-operator">|</span>grep <span class="hljs-comment">--color &quot;TCP established hash table&quot;</span><br>TCP established hash <span class="hljs-keyword">table</span> entries: <span class="hljs-number">524288</span> (<span class="hljs-keyword">order</span>: <span class="hljs-number">11</span>, <span class="hljs-number">8388608</span> bytes)<br></code></pre></td></tr></table></figure></li><li>还有一个hash table用来保存所有的bound ports，主要用于可以快速的找到一个可用的端口或者随机端口：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">[root<span class="hljs-variable">@web01</span> <span class="hljs-operator">~</span>]# dmesg <span class="hljs-operator">|</span>grep <span class="hljs-comment">--color &quot;TCP bind hash table&quot;</span><br>TCP bind hash <span class="hljs-keyword">table</span> entries: <span class="hljs-number">65536</span> (<span class="hljs-keyword">order</span>: <span class="hljs-number">8</span>, <span class="hljs-number">1048576</span> bytes)<br></code></pre></td></tr></table></figure>由于内核需要保存这些数据，必然，会占用一定的内存。</li></ol><p>那么会消耗CPU吗？当然！每次找到一个随机端口，还是需要遍历一遍bound ports的吧，这必然需要一些CPU时间。TIME_WAIT很多，既占内存又消耗CPU，这也是为什么很多人，看到TIME_WAIT很多，就蠢蠢欲动的想去干掉他们。其实，如果你再进一步去研究，1万条TIME_WAIT的连接，也就多消耗1M左右的内存，对现代的很多服务器，已经不算什么了。至于CPU，能减少它当然更好，但是不至于因为1万多个hash item就担忧。如果要真的想去调优，还是需要搞清楚调优方案以及调优参数背后的意义！</p><h2 id="TIME-WAIT调优，则必须理解的几个调优参数"><a href="#TIME-WAIT调优，则必须理解的几个调优参数" class="headerlink" title="TIME_WAIT调优，则必须理解的几个调优参数"></a>TIME_WAIT调优，则必须理解的几个调优参数</h2><ul><li>net.ipv4.tcp_timestamps</li></ul><p>RFC 1323 在 TCP Reliability一节里，引入了timestamp的TCP option，两个4字节的时间戳字段，其中第一个4字节字段用来保存发送该数据包的时间，第二个4字节字段用来保存最近一次接收对方发送到数据的时间。有了这两个时间字段，也就有了后续优化的余地。tcp_tw_reuse 和 tcp_tw_recycle就依赖这些时间字段。</p><ul><li>net.ipv4.tcp_tw_reuse</li></ul><p>从字面意思来看，这个参数是reuse TIME_WAIT状态的连接。时刻记住一条socket连接，就是那个五元组，出现TIME_WAIT状态的连接，一定出现在主动关闭连接的一方。所以，当主动关闭连接的一方，再次向对方发起连接请求的时候（例如，客户端关闭连接，客户端再次连接服务端，此时可以复用了；负载均衡服务器，主动关闭后端的连接，当有新的HTTP请求，负载均衡服务器再次连接后端服务器，此时也可以复用），可以复用TIME_WAIT状态的连接。</p><p>通过字面解释以及例子说明，可以看到，tcp_tw_reuse应用的场景：某一方，需要不断的通过“短连接“连接其他服务器，总是自己先关闭连接(TIME_WAIT在自己这方)，关闭后又不断的重新连接对方。</p><p>那么，当连接被复用了之后，延迟或者重发的数据包到达，新的连接怎么判断，到达的数据是属于复用后的连接，还是复用前的连接呢？那就需要依赖前面提到的两个时间字段了。复用连接后，这条连接的时间被更新为当前的时间，当延迟的数据达到，延迟数据的时间是小于新连接的时间，所以，内核可以通过时间判断出，延迟的数据可以安全的丢弃掉了。</p><p>这个配置，依赖于连接双方，同时对timestamps的支持。同时，这个配置，仅仅影响outbound连接，即做为客户端的角色，连接服务端[connect(dest_ip, dest_port)]时复用TIME_WAIT的socket。</p><ul><li>net.ipv4.tcp_tw_recycle</li></ul><p>从字面意思来看，这个参数是销毁掉 TIME_WAIT。当开启了这个配置后，内核会快速的回收处于TIME_WAIT状态的socket连接。多快？不再是2MSL，而是一个RTO（retransmission timeout，数据包重传的timeout时间）的时间，这个时间根据RTT动态计算出来，但是远小于2MSL。</p><p>有了这个配置，还是需要保障丢失重传或者延迟的数据包，不会被新的连接(注意，这里不再是复用了，而是之前处于TIME_WAIT状态的连接已经被destroy掉了，新的连接，刚好是和某一个被destroy掉的连接使用了相同的五元组而已)所错误的接收。在启用该配置，当一个socket连接进入TIME_WAIT状态后，内核里会记录包括该socket连接对应的五元组中的对方IP等在内的一些统计数据，当然也包括从该对方IP所接收到的最近的一次数据包时间。当有新的数据包到达，只要时间晚于内核记录的这个时间，数据包都会被统统的丢掉。</p><p>这个配置，依赖于连接双方对timestamps的支持。同时，这个配置，主要影响到了inbound的连接（对outbound的连接也有影响，但是不是复用），即做为服务端角色，客户端连进来，服务端主动关闭了连接，TIME_WAIT状态的socket处于服务端，服务端快速的回收该状态的连接。</p><p>由此，如果客户端处于NAT的网络(多个客户端，同一个IP出口的网络环境)，如果配置了tw_recycle，就可能在一个RTO的时间内，只能有一个客户端和自己连接成功(不同的客户端发包的时间不一致，造成服务端直接把数据包丢弃掉)。</p><p>下面通过案例和图示，来加深下理解:</p><p><img src="/2023/06/24/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84TIME-WAIT%E5%92%8CCLOSE-WAIT%E7%8A%B6%E6%80%81%E8%A7%A3%E8%AF%B4-%E8%BD%AC%E8%BD%BD/time-wait%E8%B0%83%E4%BC%98%E7%A4%BA%E4%BE%8B.png" alt="time-wait调优示例"></p><ul><li>客户端IP地址为：180.172.35.150，我们可以认为是浏览器; </li><li>负载均衡有两个IP，外网IP地址为 115.29.253.156，内网地址为10.162.74.10；外网地址监听80端口; </li><li>负载均衡背后有两台Web服务器，一台IP地址为 10.162.74.43，监听80端口；另一台为 10.162.74.44，监听 80 端口; </li><li>Web服务器会连接数据服务器，IP地址为 10.162.74.45，监听 3306 端口;</li></ul><p>这种简单的架构下，我们来看看，在不同的情况下，上面谈论的tw_reuse&#x2F;tw_recycle对网络连接的影响。</p><p>先做个假定：</p><ul><li>客户端通过HTTP&#x2F;1.1连接负载均衡，也就是说，HTTP协议投Connection为keep-alive，所以假定，客户端对负载均衡服务器的socket连接，客户端会断开连接，所以TIME_WAIT出现在客户端; </li><li>Web服务器和MySQL服务器的连接，我们假定，Web服务器上的程序在连接结束的时候，调用close操作关闭socket资源连接，所以，TIME_WAIT出现在 Web 服务器端。</li></ul><p>那么，在这种假定下：</p><ul><li>Web服务器上，肯定可以配置开启的配置：tcp_tw_reuse；如果Web服务器有很多连向DB服务器的连接，可以保证socket连接的复用。</li><li>那么，负载均衡服务器和Web服务器，谁先关闭连接，则决定了我们怎么配置tcp_tw_reuse&#x2F;tcp_tw_recycle了。</li></ul><p><strong>方案一：负载均衡服务器</strong></p><p>首先关闭连接, 在这种情况下，因为负载均衡服务器对Web服务器的连接，TIME_WAIT大都出现在负载均衡服务器上，所以:</p><p>在负载均衡服务器上的配置：<br>net.ipv4.tcp_tw_reuse &#x3D; 1            &#x2F;&#x2F;尽量复用连接<br>net.ipv4.tcp_tw_recycle &#x3D; 0         &#x2F;&#x2F;不能保证客户端不在NAT的网络啊</p><p>在Web服务器上的配置为：<br>net.ipv4.tcp_tw_reuse &#x3D; 1         &#x2F;&#x2F;这个配置主要影响的是Web服务器到DB服务器的连接复用<br>net.ipv4.tcp_tw_recycle：  设置成1和0都没有任何意义。想一想，在负载均衡和它的连接中，它是服务端，但是TIME_WAIT出现在负载均衡服务器上；它和DB的连接，它是客户端，recycle对它并没有什么影响，关键是reuse</p><p><strong>方案二：Web服务器首先关闭来自负载均衡服务器的连接</strong></p><p>在这种情况下，Web服务器变成TIME_WAIT的重灾区。负载均衡对Web服务器的连接，由Web服务器首先关闭连接，TIME_WAIT出现在Web服务器上；Web服务器对DB服务器的连接，由Web服务器关闭连接，TIME_WAIT也出现在它身上，此时:</p><p>负载均衡服务器上的配置：<br>net.ipv4.tcp_tw_reuse：0 或者 1 都行，都没有实际意义<br>net.ipv4.tcp_tw_recycle&#x3D;0           &#x2F;&#x2F;一定是关闭recycle</p><p>在Web服务器上的配置：<br>net.ipv4.tcp_tw_reuse &#x3D; 1       &#x2F;&#x2F;这个配置主要影响的是Web服务器到DB服务器的连接复用<br>net.ipv4.tcp_tw_recycle&#x3D;1      &#x2F;&#x2F;由于在负载均衡和Web服务器之间并没有NAT的网络，可以考虑开启recycle，加速由于负载均衡和Web服务器之间的连接造成的大量TIME_WAIT</p><p>问题1: 通常说的连接池可以复用连接，是不是意味着，需要等到上个连接time wait结束后才能再次使用?</p><p>所谓连接池复用，复用的一定是活跃的连接，所谓活跃，第一表明连接池里的连接都是ESTABLISHED的，第二，连接池做为上层应用，会有定时的心跳去保持连接的活跃性。既然连接都是活跃的，那就不存在有TIME_WAIT的概念了，在上篇里也有提到，TIME_WAIT是在主动关闭连接的一方，在关闭连接后才进入的状态。既然已经关闭了，那么这条连接肯定已经不在连接池里面了，即被连接池释放了。</p><p>问题2: 作为负载均衡的机器随机端口使用完的情况下大量time_wait，不调整上面文中说的那三个参数，有其他的更好的方案吗？</p><p>第一，随机端口使用完，你可以通过调整&#x2F;etc&#x2F;sysctl.conf下的net.ipv4.ip_local_port_range配置，至少修改成 net.ipv4.ip_local_port_range&#x3D;1024 65535，保证你的负载均衡服务器至少可以使用6万个随机端口，也即可以有6万的反向代理到后端的连接，可以支持每秒1000的并发（想一想，因为TIME_WAIT状态会持续1分钟后消失，所以一分钟最多有6万，每秒1000）；如果这么多端口都使用完了，也证明你应该加服务器了，或者，你的负载均衡服务器需要配置多个IP地址，或者，你的后端服务器需要监听更多的端口和配置更多的IP（想一下socket的五元组）</p><p>第二，大量的TIME_WAIT，多大量？如果是几千个，其实不用担心，因为这个内存和CPU的消耗有一些，但是是可以忽略的。</p><p>第三，如果真的量很大，上万上万的那种，可以考虑，让后端的服务器主动关闭连接，如果后端服务器没有外网的连接只有负载均衡服务器的连接（主要是没有NAT网络的连接），可以在后端服务器上配置tw_recycle，然后同时，在负载均衡服务器上，配置tw_reuse。</p><h2 id="简单解释下TCP状态转移"><a href="#简单解释下TCP状态转移" class="headerlink" title="简单解释下TCP状态转移"></a>简单解释下TCP状态转移</h2><p>简单来说：<br>一端忘记close,将造成另一端大量的close_wait的状态。<br>主动执行close的一端,在量特别大的情况下,对so_linger没有做设置,将造成大量的time_wait状态的连接。</p><p>TCP状态转移要点：<br>TCP协议规定,对于已经建立的连接,网络双方要进行四次握手才能成功断开连接,如果缺少了其中某个步骤,将会使连接处于假死状态,连接本身占用的资源不会被释放。网络服务器程序要同时管理大量连接,所以很有必要保证无用连接完全断开,否则大量僵死的连接会浪费许多服务器资源</p><p>客户端TCP状态迁移：<br>CLOSED -&gt; SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT -&gt; CLOSED<br>服务器TCP状态迁移：<br>CLOSED -&gt; LISTEN -&gt; SYN收到 -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED<br>当客户端开始连接时,服务器还处于LISTENING,客户端发一个SYN包后,他就处于SYN_SENT状态,服务器就处于SYS收到状态,然后互相确认进入连接状态ESTABLISHED.</p><p>相关状态解释</p><ol><li><p>LISTENING状态<br>服务启动后首先处于侦听(LISTENING)状态。</p></li><li><p>ESTABLISHED状态<br>ESTABLISHED的意思是建立连接。表示两台机器正在通信。</p></li><li><p>CLOSE_WAIT<br>对方主动关闭连接或者网络异常导致连接中断,这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭</p></li><li><p>TIME_WAIT<br>我方主动调用close()断开连接,收到对方确认后状态变为TIME_WAIT,缺省为240秒。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分段最大生存期),以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放,所以作为服务器,在可能的情况下,尽量不要主动断开连接,以减少TIME_WAIT状态造成的资源浪费。</p></li></ol><p>目前有一种避免TIME_WAIT资源浪费的方法,就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的,在某些情况下这个操作可能会带来错误.</p><p>断开连接的时候, 当发起主动关闭的左边这方发送一个FIN过去后,右边被动关闭的这方要回应一个ACK,这个ACK是TCP回应的,而不是应用程序发送的,此时,被动关闭的一方就处于CLOSE_WAIT状态了。如果此时被动关闭的这一方不再继续调用closesocket,那么他就不会发送接下来的FIN,导致自己老是处于CLOSE_WAIT。只有被动关闭的这一方调用了closesocket,才会发送一个FIN给主动关闭的这一 方,同时也使得自己的状态变迁为LAST_ACK。</p><p>出现大量CLOSE_WAIT的原因很简单,就是某一方在网络连接断开后,没有检测到这个错误,没有执行closesocket,导致了这个状态的实现,这在TCP&#x2F;IP协议的状态变迁图上可以清楚看到。同时和这个相对应的还有一种叫TIME_WAIT的。一端的Socket调用close后,另一端的Socket没有调用close</p><p>另外,把SOCKET的SO_LINGER设置为0秒拖延(也就是立即关闭)在很多时候是有害处的。 还有,把端口设置为可复用是一种不安全的网络编程方法</p><p>当主动关闭的一方发送FIN到被动关闭这边后,被动关闭这边的TCP马上回应一个ACK过去,同时向上面应用程序提交一个ERROR,导 致上面的SOCKET的send或者recv返回SOCKET_ERROR,正常情况下,如果上面在返回SOCKET_ERROR后调用了closesocket,那么被动关闭的者一方的TCP就会发送一个FIN过去,自己的状态就变迁到LAST_ACK. </p><p>使用netstat -na命令即可知道到当前的TCP连接状态。一般LISTEN、ESTABLISHED、TIME_WAIT是比较常见。</p><p>分析:<br>time_wait过多这个问题主要因为TCP的结束流程未走完,造成连接未释放。现设客户端主动断开连接,流程如下:</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">Client 消息 Server</span><br><span class="hljs-comment">close()</span><br><span class="hljs-literal">------</span> <span class="hljs-comment">FIN</span> <span class="hljs-literal">-------</span>&gt;<br><span class="hljs-comment">FIN_WAIT1 CLOSE_WAIT</span><br>&lt;<span class="hljs-literal">-----</span> <span class="hljs-comment">ACK</span> <span class="hljs-literal">-------</span><br><span class="hljs-comment">FIN_WAIT2</span><br><span class="hljs-comment">close()</span><br>&lt;<span class="hljs-literal">------</span> <span class="hljs-comment">FIN</span> <span class="hljs-literal">------</span><br><span class="hljs-comment">TIME_WAIT LAST_ACK</span><br><br><span class="hljs-literal">------</span> <span class="hljs-comment">ACK</span> <span class="hljs-literal">-------</span>&gt;<br><span class="hljs-comment">CLOSED</span><br><span class="hljs-comment">CLOSED</span><br></code></pre></td></tr></table></figure><p>如上图所示,由于Server的Socket在客户端已经关闭时而没有调用关闭,造成服务器端的连接处在“挂起”状态,而客户端则处在等待应答的状态上。此问题的典型特征是:一端处于FIN_WAIT2 ,而另一端处于CLOSE_WAIT .</p><p>对于基于TCP的HTTP协议,关闭TCP连接的是Server端,这样,Server端会进入TIME_WAIT状态,可 想而知,对于访问量大的Web Server,会存在大量的TIME_WAIT状态,假如server一秒钟接收1000个请求,那么就会积压240*1000&#x3D;240,000个TIME_WAIT的记录,维护这些状态给Server带来负担。当然现代操作系统都会用快速的查找算法来管理这些TIME_WAIT,所以对于新的TCP连接请求,判断是否hit中一个TIME_WAIT不会太费时间,但是有这么多状态要维护总是不好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近阅读到一篇关于TCP连接的TIME_WAIT和CLOSE_WAIT状态的博客，感觉博主讲的十分通透，怕后续博文失联，特别整理转载一下，博</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://soatree.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://soatree.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>苏菲的世界</title>
    <link href="http://soatree.github.io/2023/06/22/%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://soatree.github.io/2023/06/22/%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C/</id>
    <published>2023-06-22T14:14:43.000Z</published>
    <updated>2023-08-03T14:13:36.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《苏菲的世界》 贾德　作家出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li><p>这里坚决相信人的理智的态度被称为理性主义。所谓理性主义者就是百分之百相信人类的理智是世间所有知识泉源的人。</p></li><li><p>赫拉克里特斯说：“所有事物都是流动的。”每一件事物都在不停变化、移动，没有任何事物是静止不变的，因此我们不可能“在同一条河流中涉水两次”。当我第二次涉水时，无论是我还是河流都已经与从前不同了。</p></li><li><p>根据希波克拉底派的医学传统，要预防疾病，最重要的就是饮食起居要节制，同时要有健康的生活方式。他们认为健康是人的自然状态。人之所以生病，是因为身体或心灵不平衡，因而使大自然“出轨”所致。保持健康的方法就是节制饮食、保持和谐，并拥有“健康的身体与健康的心灵”。</p></li><li><p>生小孩的能力是与生俱来的。同样的，每一个人只要运用本身的常识，就可以领悟哲学的真理。所谓运用本身的常识就是搜寻自己的内心，运用内心的智慧。</p></li><li><p>最具颠覆性的人就是那些提出问题的人，而回答问题则比较不危险。</p></li><li><p>苏格拉底声称他受到内心一个神圣声音的指引，同时他的“良心”也告诉他什么是对的。他说：“知善者必能行善。”他的意思是人只要有正确的见解，就会采取正确的行动。也唯有行所当行的人才能成为一个“有德之人”。我们之所以犯错，是因为我们不知道何者是对的。这是人何以必须不断学习的原因。苏格拉底想为是非对错找出一个清楚明白，而且放诸四海皆准的定义。他与那些诡辩家不同的是，他相信辨别是非的能力就存在于人的理性中，而不存在于社会中。</p></li><li><p>苏格拉底认为，人如果违反自己的理性就不会快乐。而那些知道如何找到快乐的人就会遵照自己的理性行事。</p></li><li><p>犬儒派学者强调，真正的幸福不是建立在外在环境的优势——如丰裕的物质、强大的政治力量与健壮的身体——之上。真正幸福的人不依赖这些稍纵即逝的东西。同时，由于幸福不是由这类福祉构成的，因此每一个人都可以获致幸福，更重要的是，一旦获得了这种幸福，就不可能失去它。犬儒学派相信，人们无需担心自己的健康，不应该因生老病死而苦恼，也不必担心别人的痛苦而让自己活受罪。于是，到了今天，“犬儒主义”这些名词的意思变成是对人类真诚的轻蔑不信，暗含对别人的痛苦无动于衷的态度与行为。</p></li><li><p>斯多葛学派强调，所有的自然现象，如生病与死亡，都只是遵守大自然不变的法则罢了，因此人必须学习接受自己的命运。没有任何事物是偶然发生的，每一件事物发生都有其必要性，因此当命运来敲你家大门时，抱怨也没有用。他们认为，我们也不能为生活中一些欢乐的事物所动。在这方面，他们的观点与犬儒学派相似，因为后者也宣称所有外在事物都不重要。到了今天，我们仍用“斯多葛式的冷静”（stoiccalm）来形容那些不会感情用事的人。</p></li><li><p>伊壁鸠鲁学派强调在我们考量一个行动是否有乐趣时，必须同时斟酌它可能带来的副作用。伊壁鸠鲁强调，所谓“乐趣”并不一定指感官上的快乐，如吃巧克力等。交朋友与欣赏艺术等也是一种乐趣。此外，我们若要活得快乐，必须遵守古希腊人自我规范、节制与平和等原则。自我的欲望必须加以克制，而平和的心境则可以帮助我们忍受痛苦。“死亡和我们没有关系，”伊壁鸠鲁扼要地说，“因为只要我们存在一天，死亡就不会来临。而当死亡来临时，我们也不再存在了。”（说到这点，我们好像从没听说过有谁得了死亡这种病。）</p></li><li><p>所谓印欧民族指的是所有使用印欧语言的民族与文化，包括所有的欧洲国家，除了那些讲菲诺攸格里克语族语言（包括斯堪的纳维亚半岛最北端的拉普兰语、芬兰语、爱沙尼亚语和匈牙利语）或巴斯克语的民族之外。除此之外，印度和伊朗地区的大多数语言也属于印欧语系。印度教与佛教这两大东方宗教都源自印欧文化，希腊哲学亦然。</p></li><li><p>闪族文化。这是一个完全不同的文化，他们的语言也和印欧语系完全不同。闪族人源自阿拉伯半岛，不过他们后来同样也迁徙到世界各地。两千多年来，这些犹太人一直过着离乡背井的生活。通过基督教与回教，闪族文化（历史与宗教）的影响遍及各地。西方三大宗教——犹太教、基督教（编按：Christianity，系包括所有信奉基督的教派，最重要的有四种：天主教、基督教、东正教、英国圣公会，其中基督教又称新教，是十六世纪宗教革命后才分出来的）与伊斯兰教——都源出闪族。</p></li><li><p>生命本来就是悲伤而严肃的。我们来到这个美好的世界里，彼此相逢，彼此问候，并结伴同游一段短暂的时间。然后我们就失去了对方，并且莫名其妙就消失了，就像我们突然莫名其妙地来到世上一般。</p></li><li><p>笛卡尔怀疑每一件事，而这正是他唯一能够确定的事情。此时他悟出一个道理：有一件事情必定是真实的，那就是他怀疑。当他怀疑时，他必然是在思考，而由于他在思考，那么他必定是个会思考的存在者。用他自己的话来说，就是：我思故我在。</p></li><li><p>斯宾诺莎强调世间只有一种存在是完全自主，且可以充分自由行动的，那就是上帝（或自然）。唯有上帝或自然可以表现这种自由、‘非偶然’的过程。人可以争取自由，以便去除外在的束缚，但他永远不可能获得‘自由意志’。我们不能控制发生在我们体内的每一件事，这是扩延属性的一个模态。我们也不能‘选择’自己的思想。因此，人并没有自由的灵魂，他的灵魂或多或少都被囚禁在一个类似机器的身体内。斯宾诺莎指出，使我们无法获得真正的幸福与和谐的是我们内心的各种冲动。例如我们的野心和欲望。但如果我们体认到每一件事的发生都有其必然性，我们就可以凭直觉理解整个大自然。我们会很清楚地领悟到每一件事都有关联，每一件事情都是一体的。最后的目标是以一种全然接纳的观点来理解世间的事物。只有这样，我们才能获得真正的幸福与满足。这是斯宾诺莎所说的SubSpecieaeternitatis。</p></li><li><p>你对自我的认知实际上是一长串你同时体验过的单一印象造成的结果。正如休谟说的，这个自我‘只不过是一束不同的知觉以无法想象的速度接连而来，不断改变并移动’的过程。</p></li><li><p>佛陀认为人生就是一连串心灵与肉身的变化，使人处于一种不断改变的状态：婴儿与成人不同，今日的我已非昨日的我。佛陀说，没有什么东西是‘属于我’的，也没有什么东西是我。因此，并没有‘我’或不变的自我。”</p></li><li><p>一件事情跟着另外一件事情发生，并不一定表示两者之间必有关联。哲学的目的之一就是教人们不要妄下定论。因为，妄下定论可能会导致许多迷信。</p></li><li><p>黑格尔指出我们的理性事实上是动态的，是一种过程。而‘真理’就是这个过程，因为在这个历史的过程之外，没有外在的标准可以判定什么是最真、最合理的。</p></li><li><p>马克思将这些物质、经济和社会方面的条件称为社会的基础，并将社会思想、政治制度、法律规章、宗教、道德、艺术、哲学和科学等称为社会的上层构造。</p></li><li><p>所有生命都赖以组成的复合分子要能够形成，至少要有两个条件：一、大气层里不能有氧气，二、要受到宇宙辐射线的照射。</p></li><li><p>萨特所描述的乃是二十世纪的城市人。你也许还记得文艺复兴时期的人文主义者曾经兴高采烈地强调人的自由与独立。萨特则觉得人的自由是一种诅咒。他说，‘人是注定要受自由之苦的。因为他并没有创造自己，但却是自由的。因为一旦被扔进这个世界里来，他就必须为他所做的每一件事负责。’。可是我们仍然是自由的个体，而这种自由使我们注定一生中要不断地做选择。世上没有我们必须遵守的永恒价值或规范，这使得我们的选择更加有意义。因为我们要为自己所做的事负全责。萨特强调，人绝对不能放弃他对自己行动的责任，也不能以我们‘必须’上班、‘必须’符合中产阶级对我们生活方式的期望为理由，逃避为自己做选择的责任。如果我们逃避这项责任，就会沦为无名大众的一分子，将永远只是一个没有个性的群体之一，逃避自我并自我欺骗。从另外一方面来说，我们的自由迫使我们要成为某种人物，要‘真实’地活着。萨特认为生命应该有意义，这是一个命令。但我们生命中的意义必须由我们自己来创造，存在的意义就是要创造自己的生命。</p></li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>《苏菲的世界》通过一个奇妙的故事介绍了从古希腊到近代的西方哲学史，故事本身十分有趣，同时也能科普一些哲学知识。令我惊奇的是，东西方的哲学在一些地方是有相同之处，例如苏格拉底相信“他相信辨别是非的能力就存在于人的理性中，而不存在于社会中”，这与王阳明的“致良知”学问是多么的相似，大道至简。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h1&gt;&lt;p&gt;《苏菲的世界》 贾德　作家出版社&lt;/p&gt;
&lt;h1 id=&quot;摘录&quot;&gt;&lt;a href=&quot;#摘录&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="读书" scheme="http://soatree.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="哲学" scheme="http://soatree.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>八股文-计算机网络</title>
    <link href="http://soatree.github.io/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://soatree.github.io/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2023-06-06T14:15:48.000Z</published>
    <updated>2023-07-25T14:36:59.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整理计算机网络的相关面试题，计算机网络在我看来挺复杂的，想要完全精通应该是不可能的，毕竟后端开发的知识点那么多，不过掌握面试的常考知识点是由必要的。建议系统学习计算机网络课本再进行知识点的整理记忆。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="IOS七层协议有了解么？Ip协议是哪层协议？"><a href="#IOS七层协议有了解么？Ip协议是哪层协议？" class="headerlink" title="IOS七层协议有了解么？Ip协议是哪层协议？"></a>IOS七层协议有了解么？Ip协议是哪层协议？</h2><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p>目前的计算机网络分层结构主流分为三种：OSI协议体系结构、TCP&#x2F;IP协议体系结构、原理体系结构。OSI协议体系结构是国际标准化组织（ISO）制定的协议体系，但实际较为复杂，缺少商业驱动；TCP&#x2F;IP是推广最广的标准，是事实国际标准；原理体系结合了OSI和TCP&#x2F;IP的优势，将网络分成了5层。</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计网体系结构"></p><h3 id="原理体系分层"><a href="#原理体系分层" class="headerlink" title="原理体系分层"></a>原理体系分层</h3><ul><li>物理层：物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流;</li><li>数据链路层：数据链路层考虑同一个局域网中的点对点传输（PPP协议）和局域网内的广播传输（以太网、wifi等）；</li><li>网络层：网络层考虑在整个互联的网络中两个主机之间的通信，一个主机的信息需要经过若干路由器传送到目标主机。网络层最核心的功能是分组转发和路由选择。核心协议为网际协议IP，配合协议为地址解析协议（AddressResolutionProtocol，ARP）、逆地址解析协议（ReverseAddressResolutionProtocol，RARP）、网际控制报文协议（InternetControlMessageProtocol，ICMP）、网际组管理协议（InternetGroupManagementProtocol，IGMP）。</li><li>运输层：如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。它属于面向通信部分的最高层，同时也是用户功能中的最低层。根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP。</li><li>应用层：定义运行在不同端系统上的应用进程间为实现特定应用而互相通信的规则。</li></ul><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE.png" alt="应用层协议"></p><h3 id="IP协议是哪层协议"><a href="#IP协议是哪层协议" class="headerlink" title="IP协议是哪层协议"></a>IP协议是哪层协议</h3><p>网络层</p><p>参考：<br>《计算机网络教程》 谢钧，谢希仁 人民邮电出版社</p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP在传送数据之前不需要先建立连接；</p><p>远地主机的运输层在收到UDP报文后，不需要给出任何确认，不提供可靠交付；</p><p>UDP支持一对一、一对多、多对一和多对多的交互通信。</p><p>UDP是面向报文的。这就是说，UDP对应用程序交下来的报文不再划分为若干个分组来发送，也不把收到的若干个报文合并后再交付给应用程序。应用程序交给UDP一个报文，UDP就发送这个报文；而UDP收到一个报文，就把它交付给应用程序。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部相对太大，这也降低了IP层的效率；</p><p>UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很多的实时应用（如IP电话、实时视频会议等）要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延。UDP正好适合这种要求；</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接；</p><p>提供可靠交付(通过TCP连接传送的数据无差错、不丢失、不重复，并且按序到达)的服务，因此需要提供如确认、流量控制、拥塞控制、计时器及连接管理等功能；</p><p>TCP不提供广播或多播服务。每一条TCP连接只能有两端点，即每一条TCP连接只能是点对点的（一对一）。TCP连接唯一地被通信两端的端点所确定，而两个端点分别由二元组（IP地址、端口号）唯一标识，即一条TCP连接由两个套接字（socket）地址标识。与UDP的端口队列不同的是，TCP的发送缓存和接收缓存都是分配给一个连接的，而不是一个端口。</p><p>面向字节流。TCP中的“流”（stream）指的是流入到进程或从进程流出的字节序列；</p><p>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。</p><p>参考：<br>《计算机网络教程》 谢钧，谢希仁 人民邮电出版社</p><h2 id="TCP三次握手、四次挥手"><a href="#TCP三次握手、四次挥手" class="headerlink" title="TCP三次握手、四次挥手"></a>TCP三次握手、四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>设主机B中运行TCP的服务器进程，它先发出一个被动打开（passiveopen）命令，准备接受客户进程的连接请求。然后服务器进程就处于“听”（listen）的状态，不断检测是否有客户进程要发起连接请求。如有，即做出响应。设客户进程运行在主机A中。它先向其TCP发出主动打开（activeopen）命令，表明要向某个IP地址的某个端口建立运输层连接。主机A的TCP向主机B的TCP发出连接请求报文段，其首部中的同步位SYN应置1，同时选择一个序号seq&#x3D;x，这表明下一个报文段的第一个数据字节的序号是x+1。主机B的TCP收到连接请求报文段后，如同意，则发回连接请求确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack&#x3D;x+1，同时也为自己选择一个序号seq&#x3D;y。主机A的TCP收到B接受连接请求的确认后，还要向B给出确认，其ACK置1，确认号ack&#x3D;y+1，而自己的序号seq&#x3D;x+1。TCP的标准规定，SYN&#x3D;1的报文段（例如，A发送的第一个报文段）不能携带数据，但要消耗掉一个序号。因此A发送的第二个报文段的序号应当是第一个报文段的序号加1（虽然在第一个报文段中并没有数据）。注意，A发送的第二个报文段中SYN是0而不是1，ACK位必须为1。该报文段是对B的同步报文段的确认，但是一个普通报文段，可携带数据。若该报文段不携带数据，则按照TCP的规定，确认报文段不消耗序号。运行客户进程的主机A的TCP通知上层应用进程，连接已经建立。当运行服务器进程的主机B的TCP收到主机A的确认后，会通知其上层应用进程，连接已经建立。</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p><h3 id="为何要三次握手"><a href="#为何要三次握手" class="headerlink" title="为何要三次握手"></a>为何要三次握手</h3><p>这主要是为了防止已失效的连接请求报文段突然又传送到了主机B，因而产生错误。</p><p>所谓“已失效的连接请求报文段”是这样产生的。考虑这样一种情况。主机A发出连接请求，但因连接请求报文丢失而未收到确认。主机A于是再重传一次。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。主机A共发送了两个连接请求报文段，其中的第二个到达了主机B。现</p><p>假定出现另一种情况，即主机A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点滞留的时间太长，以致延误到在这次的连接释放以后才传送到主机B。本来这是一个已经失效的报文段。但主机B收到此失效的连接请求报文段后，就误认为是主机A又发出一次新的连接请求。于是就向主机A发出确认报文段，同意建立连接。主机A由于并没有要求建立连接，因此不会理睬主机B的确认，也不会向主机B发送数据。但主机B却以为运输连接就这样建立了，并一直等待主机A发来数据。主机B的许多资源就这样白白浪费了。</p><p>采用三次握手的办法可以防止上述现象的发生。例如，在刚才的情况下，主机A不会向主机B的确认发出确认。主机B收不到确认，连接就建立不起来。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>主机A的应用进程先向其TCP发出连接释放请求，并且不再发送数据。TCP通知对方要释放从A到B这个方向的连接，把发往主机B的报文段首部的FIN置1，其序号seq&#x3D;u。由于FIN报文段要消耗一个序号，因此序号u等于A前面已传送过的数据的最后一个字节的序号加1。主机B的TCP收到释放连接通知后即发出确认，确认号是ack&#x3D;u+1，而这个报文段自己的序号假定为v（v等于B前面已传送过的数据的最后一个字节的序号加1）。主机B的TCP这时应通知高层应用进程。这样，从A到B的连接就释放了，连接处于半关闭（half-close）状态，相当于主机A向主机B说：“我已经没有数据要发送了。但你如果还发送数据，我仍可以接收。”此后，主机B不再接收主机A发来的数据。但若主机B还有一些数据要发往主机A，则可以继续发送（这种情况很少）。主机A只要正确收到数据，仍应向主机B发送确认。若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须使FIN&#x3D;1，并使其序号仍为v（因为前面发送的确认报文段不消耗序号），还必须重复上次已发送过的确认号ack&#x3D;u+1。主机A必须对此发出确认，把ACK置1，确认号ack&#x3D;v+1，而自己的序号是seq&#x3D;u+1（因为根据TCP标准，前面发送过的FIN报文段要消耗一个序号）。这样才把从B到A的反方向连接释放掉。但此时，主机A的TCP并不能马上释放整个连接，还要再等待一个超时时间才能将整个连接释放。因为主机A的确认有可能丢失，这时B会重传FIN报文段。在这段超时时间内，若A又收到B重传的FIN报文段，A需要再次进行确认。收到A的最后确认，B才能最终将整个连接释放。若等待的这段超时时间内没有收到B的FIN报文段，主机A的TCP则向其应用进程报告，整个连接已经全部释放。</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p><h3 id="为何要四次挥手"><a href="#为何要四次挥手" class="headerlink" title="为何要四次挥手"></a>为何要四次挥手</h3><p>因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p>参考：<br>《计算机网络教程》 谢钧，谢希仁 人民邮电出版社<br><a href="https://www.cnblogs.com/softidea/p/5741192.html">TCP连接状态详解及TIME_WAIT过多的解决方法</a></p><h2 id="为什么会有time-wait，close-wait？出现大量的time-wait是什么原因？要怎么解决呢？"><a href="#为什么会有time-wait，close-wait？出现大量的time-wait是什么原因？要怎么解决呢？" class="headerlink" title="为什么会有time-wait，close-wait？出现大量的time-wait是什么原因？要怎么解决呢？"></a>为什么会有time-wait，close-wait？出现大量的time-wait是什么原因？要怎么解决呢？</h2><h3 id="为什么有close-wait"><a href="#为什么有close-wait" class="headerlink" title="为什么有close-wait"></a>为什么有close-wait</h3><p>四次挥手主动关闭方已经关闭了主动发送的单向链接，但是被动关闭方可能还需要继续发送一些数据，等这些数据发送完之后才能关闭从被动关闭方向主动关闭方的单向链接，因此从主动关闭方关闭完成到被动关闭方开始关闭之前的这段时间，被动关闭方的状态都是close-wait。一般都是代码异常，问题应该比time-out更严重。</p><h3 id="为什么会有time-wait"><a href="#为什么会有time-wait" class="headerlink" title="为什么会有time-wait"></a>为什么会有time-wait</h3><p>TIME_WAIT的出现，对应的是你的程序里的异常处理，它的出现，就是为了解决网络的丢包和网络不稳定所带来的其他问题：</p><ol><li>防止前一个连接【五元组，这里继续以 110.122.144.166:45678, tcp, 110.88.92.104:80 为例】上延迟的数据包或者丢失重传的数据包，被后面复用的连接【前一个连接关闭后，此时你再次访问百度，新的连接可能还是由110.122.144.166:45678, tcp, 110.88.92.104:80 这个五元组来表示，也就是源端口凑巧还是45678】错误的接收（异常：数据丢了，或者传输太慢了），参见下图：</li></ol><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/time-wiat%E7%BC%BA%E5%A4%B1%E5%AF%BC%E8%87%B4%E9%94%99%E8%AF%AF%E6%8E%A5%E5%8F%97.png" alt="time-wiat缺失导致错误接受"></p><ul><li>SEQ&#x3D;3的数据包丢失，重传第一次，没有得到ACK确认</li><li>如果没有TIME_WAIT，或者TIME_WAIT时间非常端，那么关闭的连接【110.122.144.166:45678, tcp, 110.88.92.104:80 的状态变为了CLOSED，源端口可被再次利用】，马上被重用【对110.88.92.104:80新建的连接，复用了之前的随机端口45678】，并连续发送SEQ&#x3D;1,2 的数据包; </li><li>此时，前面的连接上的SEQ&#x3D;3的数据包再次重传，同时，seq的序号刚好也是3（这个很重要，不然，SEQ的序号对不上，就会RST掉），此时，前面一个连接上的数据被后面的一个连接错误的接收;</li></ul><ol start="2"><li>确保连接方能在时间范围内，关闭自己的连接。其实，也是因为丢包造成的，参见下图：</li></ol><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/time-wait%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD.png" alt="time-wait未正确关闭"></p><ul><li>主动关闭方关闭了连接，发送了FIN；</li><li>被动关闭方回复ACK同时也执行关闭动作，发送FIN包；此时，被动关闭的一方进入LAST_ACK状态; </li><li>主动关闭的一方回去了ACK，主动关闭一方进入TIME_WAIT状态；</li><li>但是最后的ACK丢失，被动关闭的一方还继续停留在LAST_ACK状态; </li><li>此时，如果没有TIME_WAIT的存在，或者说，停留在TIME_WAIT上的时间很短，则主动关闭的一方很快就进入了CLOSED状态，也即是说，如果此时新建一个连接，源随机端口如果被复用，在connect发送SYN包后，由于被动方仍认为这条连接【五元组】还在等待ACK，但是却收到了SYN，则被动方会回复RST; </li><li>造成主动创建连接的一方，由于收到了RST，则连接无法成功;</li></ul><p>所以，这里看到了，TIME_WAIT的存在是很重要的，如果强制忽略TIME_WAIT，还是有很高的机率，造成数据错乱，或者短暂性的连接失败。</p><h3 id="出现大量的time-wait是什么原因？影响？要怎么解决呢？"><a href="#出现大量的time-wait是什么原因？影响？要怎么解决呢？" class="headerlink" title="出现大量的time-wait是什么原因？影响？要怎么解决呢？"></a>出现大量的time-wait是什么原因？影响？要怎么解决呢？</h3><ul><li>原因</li></ul><p>出现大量的time-wait的原因是大量主动关闭了TCP连接，使当前机器出现大量time-wait状态。</p><ul><li>TIME_WAIT会影响什么</li></ul><p>端口：但是这是对于通信过程中扮演客户端角色的一端来说，因为客户端使用随机端口来访问服务器，当它主动断开的时候会出现这个状态，比如第一次系统给它分配了一个51000的随机端口访问服务器，然后客户端主动断开了，在2MSL期间，该端口就处于TIME_WAIT状态，如果它再次访问相同的服务器，那么系统会为它再次分配一个随机端口，如果51000端口还处于TIME_WAIT状态，那么这个随机端口就肯定不是51000，如果51000端口不处于TIME_WAIT状态，那么这个随机端口就有可能是51000。所以这个状态在一定期间内对于客户端角色来讲会影响并发量，大量这个TIME_WAIT就导致可用随机端口不断减少。</p><p>内存：这个量会很小，无需担心，哪怕是上万的TIME_WAIT。</p><p>文件描述符：但是处于TIME_WAIT状态的套接字其实是已经关闭了文件描述符，也就是说这个状态并不占用文件描述符这也就是意味着该状态不会对应一个打开的文件。</p><p>CPU：会消耗一定的CPU资源</p><ul><li>解决方案主要包括以下三个方案</li></ul><ol><li>几百上千的time-wait对于服务器而言影响过小，基本可以忽略；</li><li>客户端的随机端口使用完，可以通过调整&#x2F;etc&#x2F;sysctl.conf下的net.ipv4.ip_local_port_range配置，至少修改成 net.ipv4.ip_local_port_range&#x3D;1024 65535，保证你的负载均衡服务器至少可以使用6万个随机端口，也即可以有6万的反向代理到后端的连接，可以支持每秒1000的并发（想一想，因为TIME_WAIT状态会持续1分钟后消失，所以一分钟最多有6万，每秒1000）；如果这么多端口都使用完了，也证明你应该加服务器了</li><li>调整tcp配置。编辑内核文件&#x2F;etc&#x2F;sysctl.conf，加入以下内容：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">net.ipv4.tcp_syncookies</span> = <span class="hljs-number">1</span> 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为<span class="hljs-number">0</span>，表示关闭；<br><span class="hljs-attr">net.ipv4.tcp_fin_timeout</span> = <span class="hljs-number">30</span> 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-<span class="hljs-number">2</span>状态的时间。<br><span class="hljs-comment"># 下面三个配置最核心</span><br><span class="hljs-attr">net.ipv4.tcp_timestamps</span> = <span class="hljs-number">1</span> 用于支持net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle<br><span class="hljs-attr">net.ipv4.tcp_tw_reuse</span> = <span class="hljs-number">1</span> 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为<span class="hljs-number">0</span>，表示关闭；<br><span class="hljs-attr">net.ipv4.tcp_tw_recycle</span> = <span class="hljs-number">1</span> 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为<span class="hljs-number">0</span>，表示关闭。<br></code></pre></td></tr></table></figure>然后执行 &#x2F;sbin&#x2F;sysctl -p 让参数生效。<br>简单来说，就是打开系统的TIMEWAIT重用和快速回收。<br>其中tcp_tw_reuse主要用于客户端，即客户端主动发起请求和主动断开请求的情况，可以复用TIME_WAIT状态的连接；tcp_tw_recycle主要用于服务端，即客户端连入，服务端主动关闭的情况，可以快速退出TIME_WAIT状态（在一个RTO时间内），但是如果客户端处于NAT的网络(多个客户端，同一个IP出口的网络环境)，如果配置了tcp_tw_recycle，就可能在一个RTO的时间内，只能有一个客户端和自己连接成功(不同的客户端发包的时间不一致，服务器进入TIME_WAIT状态后，会把后到的数据包丢弃掉)，所以对于客户端在NAT(NAT含义参见<a href="https://zhuanlan.zhihu.com/p/340698491">什么是NAT？</a>)网络的场景，服务端不适用tcp_tw_recycle；<br>有时一个服务器既可以作为上游的服务端，也作为下游的客户端，可能会同时配置tcp_tw_recycle和tcp_tw_reuse，需要根据实际情况（客户端、服务端、谁先断开、客户端所处网络）进行配置。</li></ol><p>参考：<br><a href="https://www.cnblogs.com/kevingrace/p/9988354.html">TCP连接的TIME_WAIT和CLOSE_WAIT 状态解说</a><br><a href="https://blog.csdn.net/weixin_42104231/article/details/83656208">正确理解tcp_fin_timeout到底起什么作用?</a><br><a href="https://www.cnblogs.com/rexcheny/p/11143128.html">解读TIME_WAIT–你在网上看到的大多数帖子可能都是错误的</a><br><a href="https://zhuanlan.zhihu.com/p/340698491">什么是NAT？</a></p><h2 id="Tcp的报文头有了解过？Tcp是怎么保证消息的可靠传输的？网络的拥塞控制和流量控制分别是指什么？"><a href="#Tcp的报文头有了解过？Tcp是怎么保证消息的可靠传输的？网络的拥塞控制和流量控制分别是指什么？" class="headerlink" title="Tcp的报文头有了解过？Tcp是怎么保证消息的可靠传输的？网络的拥塞控制和流量控制分别是指什么？"></a>Tcp的报文头有了解过？Tcp是怎么保证消息的可靠传输的？网络的拥塞控制和流量控制分别是指什么？</h2><h3 id="TCP报文头"><a href="#TCP报文头" class="headerlink" title="TCP报文头"></a>TCP报文头</h3><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E6%8A%A5%E6%96%87%E6%AE%B5.png" alt="tcp报文段"></p><ul><li><p>序号<br>序号字段的值指的是本报文段所发送的数据的第一个字节的序号。</p></li><li><p>确认号<br>确认号占4字节，是期望收到对方的下一个报文段的第一个数据字节的序号。</p></li><li><p>数据偏移<br>数据偏移占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。实际上就是TCP报文段首部的长度。</p></li><li><p>URG与紧急指针<br>紧急URG（URGent）当URG&#x3D;1时，表明紧急指针字段有效。它告诉接收方TCP此报文段中有紧急数据，应尽快交付给应用程序（相当于高优先级的数据），而不要按序从接收缓存中读取。<br>当URG置1时，发送应用进程就告诉发送TCP这两个字符是紧急数据。于是发送TCP就将这两个字符插入到报文段的数据的最前面，其余的数据都是普通数据。这时要与首部中紧急指针（UrgentPointer）字段配合使用。紧急指针指出在本报文段中的紧急数据共有多少个字节。紧急数据到达接收方后，当所有紧急数据都被处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。URG在实际中很少被使用。</p></li><li><p>ACK<br>确认ACK只有当ACK&#x3D;1时确认号字段才有效。当ACK&#x3D;0时，确认号无效。</p></li><li><p>PSH<br>推送PSH（PUSH）出于效率的考虑，TCP可能会延迟发送数据或向应用程序延迟交付数据，这样可以一次处理更多的数据。但是当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，应用程序可以通知TCP使用推送（PUSH）操作。这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去，而不需要积累到足够多的数据再发送。接收TCP收到PSH置1的报文段，就尽快地交付给接收应用进程，而不再等到接收到足够多的数据才向上交付。虽然应用程序可以选择推送操作，但现在多数TCP实现都是根据情况自动设置PUSH标志，而不是交由应用程序去处理。</p></li><li><p>RST<br>复位RST（ReSeT）当RST&#x3D;1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位。</p></li><li><p>SYN<br>同步SYN用来建立一个连接。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN&#x3D;1和ACK&#x3D;1。</p></li><li><p>FIN<br>终止FIN（FINal）用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</p></li><li><p>窗口<br>窗口占2字节。窗口值指示发送该报文段一方的接收窗口大小，在0到216–1之间。窗口字段用来控制对方发送的数据量（从确认号开始，允许对方发送的数据量），单位为字节。窗口字段反映了接收方接收缓存的可用空间大小，计算机网络经常用接收方的接收能力的大小来控制发送方的数据发送量。例如，设确认号是701，窗口字段是1000。这表明，允许对方发送数据的序号范围为701～1700。</p></li><li><p>检验和<br>检验和占2字节。检验和字段检验的范围包括首部和数据这两部分。用于数据校验。</p></li></ul><h3 id="可靠传输、拥塞控制和流量控制"><a href="#可靠传输、拥塞控制和流量控制" class="headerlink" title="可靠传输、拥塞控制和流量控制"></a>可靠传输、拥塞控制和流量控制</h3><p>TCP协议通过以下几个手段确保可靠传输:</p><ul><li><p>数据编号与确认<br>TCP协议是面向字节的。TCP把应用层交下来的长报文（这可能要划分为许多较短的报文段）看成是一个个字节组成的数据流，并使每一个字节对应于一个序号。TCP使用的是累积确认，即确认是对所有按序接收到的数据的确认。但请注意，接收方返回的确认号是已按序收到的数据的最高序号加1。也就是说，确认号表示接收方期望下次收到的数据中的第一个数据字节序号。例如，已经收到了1～700号、801～1000号和1201～1500号，而701～800号及1001～1200号的数据还没有收到，那么这时发送的确认序号应填入701。<br>当TCP发送一报文段时，它同时也在自己的重传队列中存放这个报文段的一个副本。若收到确认，则删除此副本。若在规定时间内没有收到确认，则重传此报文段的副本。</p></li><li><p>滑动窗口、流量控制、拥塞控制<br>为了提高报文段的传输效率，TCP采用滑动窗口协议。TCP发送方已发送的未被确认的字节数不能超过发送窗口的大小。<br><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt="tcp滑动窗口"><br>发送窗口的初始值在连接建立时由双方商定，但在通信的过程中，TCP的流量控制和拥塞控制会根据情况动态地调整发送窗口上限值（可增大或减小），从而控制发送数据的平均速率。<br>流量控制是基于接收方的接收缓存剩余情况限制TCP协议头的窗口字段，限制发送方的发送速率.<br>拥塞控制的任务是防止过多的数据注入到网络中，使网络能够承受现有的网络负载。拥塞控制基于闭环拥塞控制算法分析网络的各节点的网络负载，同流量控制一起限制TCP协议头的窗口字段，限制发送方的发送速率。</p></li><li><p>超时重传</p></li><li><p>快速重传<br>超时触发重传存在的一个问题就是超时时间可能相对较长。由于无法精确估计实际的往返时间，超时重传时间RTO往往比实际的往返时间大很多。当一个报文段丢失时，发送方需要等待很长时间才能重传丢失的报文段，因而增加了端到端时延。幸运的是，有时一个报文段的丢失会引起发送方连续收到多个重复的确认，通过收到多个重复的确认可以快速地判断报文段可能已经丢失而不必等待重传计时器超时。快速重传就是基于该方法对超时触发重传的补充和改进。<br>快速重传算法规定，发送方只要一连收到三个重复的确认，就应立即重传丢失的报文段M2（注意：重复确认的确认号正是要重传的报文段的序号），而不必继续等待为M2设置的重传计时器的超时。不难看出，快速重传并非取消重传计时器，而是尽早重传丢失的报文段。</p></li></ul><p>参考：<br>《计算机网络教程》 谢钧，谢希仁 人民邮电出版社</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="简述一下HTTP协议"><a href="#简述一下HTTP协议" class="headerlink" title="简述一下HTTP协议"></a>简述一下HTTP协议</h3><p>超文本传送协议（HyperTextTransferProtocol，HTTP）是一个应用层协议，HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。虽然HTTP使用面向连接的TCP，但HTTP协议本身是一个无状态协议。也就是说，HTTP不要求服务器保留客户的任何状态信息。若服务器不保存任何客户状态信息，则同一个客户上一次对服务器的访问不会影响其对该服务器的下一次访问结果，因为服务器不记得曾经访问过的这个客户，也不记得曾经服务过多少次。HTTP的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的HTTP请求。<br>HTTP&#x2F;1.0协议采用的非持续连接方式，即一次请求&#x2F;响应对应一个TCP连接。在非持续连接方式中，每次浏览器要请求一个文件都要与服务器建立TCP连接，当收到响应后就立即关闭连接。<br>HTTP&#x2F;1.1协议使用持续连接，较好地解决了这个问题。所谓持续连接就是万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行。为进一步提高效率，HTTP&#x2F;1.1协议的持续连接还可以使用流水线方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文（这样就节省了许多个RTT时间）。流水线工作方式使TCP连接中的空闲时间减少，提高了下载文档的效率。</p><h3 id="常见的http状态码是什么"><a href="#常见的http状态码是什么" class="headerlink" title="常见的http状态码是什么"></a>常见的http状态码是什么</h3><p>下面三种状态行在响应报文中是经常见到的。<br>HTTP&#x2F;1.1 202 Accepted 　{接受}<br>HTTP&#x2F;1.1 400 Bad Request 　{错误的请求}<br>Http&#x2F;1.1 404 Not Found 　{找不到}</p><p>若请求的网页从<a href="http://www.ee.xyz.edu/index.html%E8%BD%AC%E7%A7%BB%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%88%99%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%8A%B6%E6%80%81%E8%A1%8C%E5%92%8C%E4%B8%80%E4%B8%AA%E9%A6%96%E9%83%A8%E8%A1%8C%E5%B0%B1%E6%98%AF%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%BD%A2%E5%BC%8F%EF%BC%9A">http://www.ee.xyz.edu/index.html转移到了一个新的地址，则响应报文的状态行和一个首部行就是下面的形式：</a><br>HTTP&#x2F;1.1 301 Moved Permanently {永久性地转移了}</p><h3 id="http1-0，http1-1和http2-0的区别？"><a href="#http1-0，http1-1和http2-0的区别？" class="headerlink" title="http1.0，http1.1和http2.0的区别？"></a>http1.0，http1.1和http2.0的区别？</h3><p>HTTP&#x2F;1.* 一次请求-响应，建立一个连接，用完关闭；<br>HTTP&#x2F;1.1 串行化单线程处理，可以同时在同一个tcp链接上发送多个请求，但是只有响应是有顺序的，只有上一个请求完成后，下一个才能响应。一旦有任务处理超时等，后续任务只能被阻塞(线头阻塞)；<br>HTTP&#x2F;2 并行执行。某任务耗时严重，不会影响到任务正常执行</p><h3 id="http请求哪些是幂等的？"><a href="#http请求哪些是幂等的？" class="headerlink" title="http请求哪些是幂等的？"></a>http请求哪些是幂等的？</h3><p>幂等这个概念指的是多次同样的操作而不改变结果。幂等的概念广泛运用于各种分布式架构，由于网络延迟等原因，一个请求可能要多次重试，遇到这种情况就需要保证这个对应的请求接口是幂等的。另外还有类似银行转账的情形，就算多次请求也要保证对账户只做一次操作。</p><ul><li><p>GET<br>GET 操作是幂等的，原因是 GET 操作根本不会对服务器产生任何修改。有人可能会说我们访问 GET &#x2F;last_news 可能每次拿到的结果都不一样，这里幂等的一致性指的是数据库的最终的存储结果，而不是调用方拿到的返回结果</p></li><li><p>PUT<br>PUT 方法通常是对已经存在的资源进行修改，也是幂等的。比如我们发起多个把 A 替换成 B 的请求，最终的结果还会是 B</p></li><li><p>DELETE<br>DELETE 方法也是幂等的，例如我们连续发起多个对 A 的删除请求，如果第一个成功的话，后面的请求都应返回资源找不到的错误</p></li><li><p>POST<br>POST 一般是指新增资源，不是幂等的。如果连续发起三个 A 资源的增加，最终的结果会是三个 A 资源，而不是一个</p></li></ul><h3 id="Get和post的区别是什么？"><a href="#Get和post的区别是什么？" class="headerlink" title="Get和post的区别是什么？"></a>Get和post的区别是什么？</h3><ul><li><p>post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据</p></li><li><p>post比get慢：最重要的一条，post在真正接收数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据<br>post请求的过程：<br>（1）浏览器请求tcp连接（第一次握手）<br>（2）服务器答应进行tcp连接（第二次握手）<br>（3）浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）<br>（4）服务器返回100 Continue响应<br>（5）浏览器发送数据<br>（6）服务器返回200 OK响应<br>get请求的过程：<br>（1）浏览器请求tcp连接（第一次握手）<br>（2）服务器答应进行tcp连接（第二次握手）<br>（3）浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）<br>（4）服务器返回200 OK响应<br>也就是说，目测get的总耗是post的2&#x2F;3左右，这个口说无凭，网上已经有网友进行过测试。</p></li></ul><h3 id="http常见请求头"><a href="#http常见请求头" class="headerlink" title="http常见请求头"></a>http常见请求头</h3><table><thead><tr><th>Header</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>Accept</td><td>告诉WEB服务器自己接受什么介质类型，*&#x2F;* 表示任何类型，type&#x2F;* 表示该类型下的所有子类型，type&#x2F;sub-type</td><td>Accept: text&#x2F;plain, text&#x2F;html, application&#x2F;json</td></tr><tr><td>Authorization</td><td>当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。</td><td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td></tr><tr><td>Host</td><td>客户端指定自己想访问的WEB服务器的域名&#x2F;IP 地址和端口号</td><td>Host：rss.sina.com.cn</td></tr><tr><td>User-Agent</td><td>浏览器表明自己的身份（是哪种浏览器）</td><td>User-Agent：Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN;rv:1.8.1.14) Gecko&#x2F;20080404 Firefox&#x2F;2.0.0.14</td></tr><tr><td>Connection: Keep-Alive</td><td>如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）</td><td>Connection: Keep-Alive:300</td></tr><tr><td>Cookie</td><td>可以帮助服务器识别客户端的字段</td><td>Cookie: $Version&#x3D;1; Skin&#x3D;new;</td></tr></tbody></table><h3 id="session和cookie简介"><a href="#session和cookie简介" class="headerlink" title="session和cookie简介"></a>session和cookie简介</h3><h4 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h4><p>cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。一个 cookie 可以认为是一个「变量」，形如 name&#x3D;value，存储在浏览器。</p><p>但问题是，我们也知道现在的很多网站功能很复杂，而且涉及很多的数据交互，比如说电商网站的购物车功能，信息量大，而且结构也比较复杂，无法通过简单的 cookie 机制传递这么多信息，而且要知道 cookie 字段是存储在 HTTP header 中的，就算能够承载这些信息，也会消耗很多的带宽，比较消耗网络资源。</p><p>一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。session 就可以配合 cookie 解决这一问题，比如说一个 cookie 存储这样一个变量 sessionID&#x3D;xxxx，仅仅把这一个 cookie 传给服务器，然后服务器通过这个 ID 找到对应的 session，这个 session 是一个数据结构，里面存储着该用户的购物车等详细信息，服务器可以通过这些信息返回该用户的定制化网页，有效解决了追踪用户的问题。</p><p>session 是一个数据结构，由网站的开发者设计，所以可以承载各种数据，只要客户端的 cookie 传来一个唯一的 session ID，服务器就可以找到对应的 session，认出这个客户。当然，由于 session 存储在服务器中，肯定会消耗服务器的资源，所以 session 一般都会有一个过期时间，服务器一般会定期检查并删除过期的 session，如果后来该用户再次访问服务器，可能就会面临重新登录等等措施，然后服务器新建一个 session，将 session ID 通过 cookie 的形式传送给客户端。</p><h4 id="session处理过程"><a href="#session处理过程" class="headerlink" title="session处理过程"></a>session处理过程</h4><p>session 的原理不难，但是具体实现它可是很有技巧的，一般需要三个组件配合完成，它们分别是 Manager、Provider 和 Session 三个类（接口）。</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/session%E8%BF%87%E7%A8%8B.png" alt="session过程"></p><p>1、浏览器通过 HTTP 协议向服务器请求路径 &#x2F;content 的网页资源，对应路径上有一个 Handler 函数接收请求，解析 HTTP header 中的 cookie，得到其中存储的 sessionID，然后把这个 ID 发给 Manager。</p><p>2、Manager 充当一个 session 管理器的角色，主要存储一些配置信息，比如 session 的存活时间，cookie 的名字等等。而所有的 session 存在 Manager 内部的一个 Provider 中。所以 Manager 会把 sid（sessionID）传递给 Provider，让它去找这个 ID 对应的具体是哪个 session。</p><p>3、Provider 就是一个容器，最常见的应该就是一个散列表，将每个 sid 和对应的 session 一一映射起来。收到 Manager 传递的 sid 之后，它就找到 sid 对应的 session 结构，也就是 Session 结构，然后返回它。</p><p>4、Session 中存储着用户的具体信息，由 Handler 函数中的逻辑拿出这些信息，生成该用户的 HTML 网页，返回给客户端。</p><ul><li>session</li></ul><p>session 就是键值对，为啥不直接用哈希表?</p><p>第一，因为 Session 结构可能不止存储了一个哈希表，还可以存储一些辅助数据，比如 sid，访问次数，过期时间或者最后一次的访问时间，这样便于实现想 LRU、LFU 这样的算法。</p><p>第二，因为 session 可以有不同的存储方式。如果用编程语言内置的哈希表，那么 session 数据就是存储在内存中，如果数据量大，很容易造成程序崩溃，而且一旦程序结束，所有 session 数据都会丢失。所以可以有很多种 session 的存储方式，比如存入缓存数据库 Redis，或者存入 MySQL 等等。</p><p>因此，Session 结构提供一层抽象，屏蔽不同存储方式的差异，只要提供一组通用接口操纵键值对：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> Session interface &#123;<br>    <span class="hljs-comment">// 设置键值对</span><br>    <span class="hljs-constructor">Set(<span class="hljs-params">key</span>, <span class="hljs-params">val</span> <span class="hljs-params">interface</span>&#123;&#125;)</span><br>    <span class="hljs-comment">// 获取 key 对应的值</span><br>    <span class="hljs-constructor">Get(<span class="hljs-params">key</span> <span class="hljs-params">interface</span>&#123;&#125;)</span> interface&#123;&#125;<br>    <span class="hljs-comment">// 删除键 key</span><br>    <span class="hljs-constructor">Delete(<span class="hljs-params">key</span> <span class="hljs-params">interface</span>&#123;&#125;)</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Provider</li></ul><p>Provider 为啥要抽象出来?</p><p>上面那个图的 Provider 就是一个散列表，保存 sid 到 Session 的映射，但是实际中肯定会更加复杂。我们不是要时不时删除一些 session 吗，除了设置存活时间之外，还可以采用一些其他策略，比如 LRU 缓存淘汰算法，这样就需要 Provider 内部使用哈希链表这种数据结构来存储 session。</p><ul><li>Manager</li></ul><p>最后说 Manager，大部分具体工作都委托给 Session 和 Provider 承担了，Manager 主要就是一个参数集合，比如 session 的存活时间，清理过期 session 的策略，以及 session 的可用存储方式。Manager 屏蔽了操作的具体细节，我们可以通过 Manager 灵活地配置 session 机制。</p><p>参考：<br>《计算机网络教程》 谢钧，谢希仁 人民邮电出版社<br><a href="https://www.cnblogs.com/Catherine001/p/8359153.html">http中长连接和websocket的长连接的区别</a><br><a href="https://zhuanlan.zhihu.com/p/89484851">HTTP方法的幂等性</a><br><a href="https://zhuanlan.zhihu.com/p/275695831">http请求中get和post方法的区别</a><br><a href="https://blog.csdn.net/qq_42684504/article/details/106634035">HTTP请求头各参数具体含义</a><br><a href="https://zhuanlan.zhihu.com/p/105088923">cookie和session到底是什么</a></p><h2 id="长连接和短链接"><a href="#长连接和短链接" class="headerlink" title="长连接和短链接"></a>长连接和短链接</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。</p><ul><li>HTTP长连接</li></ul><p>浏览器向服务器进行一次HTTP会话访问后，并不会直接关闭这个连接，而是会默认保持一段时间，那么下一次浏览器继续访问的时候就会再次利用到这个连接。<br>在HTTP&#x2F;1.1版本中，默认的连接都是长连接，我们可以通过Connection: keep-alive字段进行指定。</p><ul><li>HTTP短连接</li></ul><p>浏览器向服务器每进行一次HTTP操作都要建立一个新的连接。<br>在HTTP&#x2F;1.0版本中默认是短链接。</p><h3 id="TCP长连接保活机制"><a href="#TCP长连接保活机制" class="headerlink" title="TCP长连接保活机制"></a>TCP长连接保活机制</h3><p>TCP长连接是通过保活机制来实现的，通过保活机制，可以保证通讯双方的连接不被释放掉；在另一些情况下，如果客户端或者服务器发生了错误或者宕机，也可以依靠这种保活机制探测出网络通信出现了问题，进而可以释放掉这种错误连接。</p><p>首先保活机制的工作原理就是，通过在服务器端设置一个保活定时器，当定时器开始工作后就定时的向网络通信的另一端发出保活探测的TCP报文，如果接收到了ACK报文，那么就证明对方存活，可以继续保有连接；否则就证明网络存在故障。具体如下：</p><p>如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段。客户主机必须处于以下4个状态之一。</p><p>状态1：客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两小时以后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来2小时再复位。<br>状态2：客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务器将不能够收到对探查的响应，并在75秒后超时。服务器总共发送10个这样的探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。<br>状态3：客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。<br>状态4：客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。</p><p>但是保活机制并不是RFC规定的TCP协议的内容，因此有时候在不支持保活机制的机器上，往往我们也需要先看一下内核层面是否支持，如果不支持需要在应用层自己去实现这个功能。<br>Linux相关的TCP保活参数：<br>tcp_keepalive_time，单位：秒，表示发送的探测报文之前的连接空闲时间，默认是7200s。<br>tcp_keepalive_intvl，单位：秒，表示两次探测报文之间的间隔时间，默认是75s<br>tcp_keepalive_probes，单位，秒，表示探测的次数，默认是9</p><h3 id="TCP长连接和短链接比较"><a href="#TCP长连接和短链接比较" class="headerlink" title="TCP长连接和短链接比较"></a>TCP长连接和短链接比较</h3><ul><li>TCP短链接</li></ul><p>优点：<br>短链接不占服务器的内存，服务器能处理的连接数量会比较多</p><p>缺点：<br>在有实际的资源要进行数据通信的时候才建立连接，那么在客户端发送完数据释放连接之后当服务器有向客户端发送数据时就不能做到发送消息的实时性。<br>频繁地建立连接、释放连接会耗费大量的CPU和网络带宽资源。</p><ul><li>TCP长连接</li></ul><p>优点：<br>通信双方因为在保活机制的保证下可以保证数据收发的实时性</p><p>缺点：<br>因为服务器需要一直保存和客户端的这条链接，因为是有状态的，那么在大量并发连接请求过来时，系统资源可能就不够了。</p><h3 id="什么时候需要长连接"><a href="#什么时候需要长连接" class="headerlink" title="什么时候需要长连接"></a>什么时候需要长连接</h3><p>服务器需要主动发送资源给客户端时<br>客户端和服务器通信很频繁时<br>客户端宕机或者掉线时需要服务器做一些处理时</p><h3 id="TCP长连接设计时需要考虑的问题"><a href="#TCP长连接设计时需要考虑的问题" class="headerlink" title="TCP长连接设计时需要考虑的问题"></a>TCP长连接设计时需要考虑的问题</h3><p>默认的keep-alive时间比较长，一般的业务可能不需要这么久的时间</p><p>参考：<br><a href="https://juejin.cn/post/6923887573861564423">HTTP长连接实现原理</a><br><a href="https://www.cnblogs.com/gotodsp/p/6366163.html">HTTP长连接、短连接究竟是什么？</a></p><h2 id="浏览器上点击链接后的处理流程？"><a href="#浏览器上点击链接后的处理流程？" class="headerlink" title="浏览器上点击链接后的处理流程？"></a>浏览器上点击链接后的处理流程？</h2><p>鼠标点击“清华大学院系设置”的页面，其URL是<a href="http://www.tsinghua.edu.cn/chn/yxsz/index.htm%E3%80%82%E4%B8%8B%E9%9D%A2%E8%AF%B4%E6%98%8E%E5%9C%A8%E7%94%A8%E6%88%B7%E5%8D%95%E5%87%BB%E9%BC%A0%E6%A0%87%E5%90%8E%E6%89%80%E5%8F%91%E7%94%9F%E7%9A%84%E5%87%A0%E4%B8%AA%E4%BA%8B%E4%BB%B6%EF%BC%9A%EF%BC%881%EF%BC%89%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%86%E6%9E%90%E9%93%BE%E6%8E%A5%E6%8C%87%E5%90%91%E9%A1%B5%E9%9D%A2%E7%9A%84URL%EF%BC%9B%EF%BC%882%EF%BC%89%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%91DNS%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90www.tsinghua.edu.cn%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%9B%EF%BC%883%EF%BC%89%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS%E8%A7%A3%E6%9E%90%E5%87%BA%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80%E4%B8%BA166.111.4.100%EF%BC%9B%EF%BC%884%EF%BC%89%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%EF%BC%88%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AFIP%E5%9C%B0%E5%9D%80%E6%98%AF166.111.4.100%EF%BC%8C%E7%AB%AF%E5%8F%A3%E6%98%AF80%EF%BC%89%EF%BC%9B%EF%BC%885%EF%BC%89%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E5%87%BA%E5%8F%96%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%EF%BC%9AGET/chn/yxsz/index.htm%EF%BC%9B%EF%BC%886%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8www.tsinghua.edu.cn%E7%BB%99%E5%87%BA%E5%93%8D%E5%BA%94%EF%BC%8C%E6%8A%8A%E6%96%87%E4%BB%B6index.htm%E5%8F%91%E9%80%81%E7%BB%99%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9B%EF%BC%887%EF%BC%89%E9%87%8A%E6%94%BETCP%E8%BF%9E%E6%8E%A5%EF%BC%9B%EF%BC%888%EF%BC%89%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E2%80%9C%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E9%99%A2%E7%B3%BB%E8%AE%BE%E7%BD%AE%E2%80%9D%E6%96%87%E4%BB%B6index.htm%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82">http://www.tsinghua.edu.cn/chn/yxsz/index.htm。下面说明在用户单击鼠标后所发生的几个事件：（1）浏览器分析链接指向页面的URL；（2）浏览器向DNS请求解析www.tsinghua.edu.cn的IP地址；（3）域名系统DNS解析出清华大学服务器的IP地址为166.111.4.100；（4）浏览器与服务器建立TCP连接（在服务器端IP地址是166.111.4.100，端口是80）；（5）浏览器发出取文件命令：GET/chn/yxsz/index.htm；（6）服务器www.tsinghua.edu.cn给出响应，把文件index.htm发送给浏览器；（7）释放TCP连接；（8）浏览器显示“清华大学院系设置”文件index.htm中的内容。</a></p><h2 id="DNS解析流程？"><a href="#DNS解析流程？" class="headerlink" title="DNS解析流程？"></a>DNS解析流程？</h2><h3 id="域名服务器层级"><a href="#域名服务器层级" class="headerlink" title="域名服务器层级"></a>域名服务器层级</h3><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="域名服务器"></p><p>域名服务器可划分为以下4种不同类型:</p><ul><li>根域名服务器<br>这是最高层次的域名服务器。根域名服务器并不直接管辖某个区的域名信息，但每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。在因特网上共有13个不同IP地址的根域名服务器。尽管我们将这13个根域名服务器中的每一个都视为单个的服务器，但每台“服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址。</li><li>顶级域名服务器（即TLD服务器）<br>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时就给出相应的回答（可能是最后的结果，也可能是下一级权威域名服务器的IP地址）。</li><li>权威域名服务器<br>负责管理某个区的域名服务器。每一个主机的域名都必须在某个权威域名服务器处注册登记。因此权威域名服务器知道其管辖的域名与IP地址的映射关系。另外，权威域名服务器还知道其下级域名服务器的地址。</li><li>本地域名服务器<br>本地域名服务器不属于上图的域名服务器的等级结构。当一个主机发出DNS查询报文时，这个查询报文就首先被送往该主机的本地域名服务器。本地域名服务器起着DNS代理的作用，会将该查询报文转发到域名服务器的等级结构中。每一个因特网服务提供者ISP，一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，它有时也称为默认域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离，有可能就在同一个局域网中。本地域名服务器的IP地址需要直接配置在需要域名解析的主机中。例如，在WindowsXP网络连接属性中设置的DNS地址就是该主机本地域名服务器的IP地址。</li></ul><h3 id="域名解析流程"><a href="#域名解析流程" class="headerlink" title="域名解析流程"></a>域名解析流程</h3><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt="域名解析"></p><p>主机向本地域名服务器的查询一般都是采用递归查询（recursivequery）。所谓递归查询就是如果本地域名服务器不知道被查询域名的IP地址时，那么本地域名服务器就以DNS客户的身份向某个根域名服务器继续发出查询请求报文（即替该主机继续查询），而不是让该主机自己进行下一步的查询。</p><p>本地域名服务器向根域名服务器查询时，是优先采用迭代查询（iterativequery）。所谓迭代查询就是由本地域名服务器进行循环查询。当根域名服务器收到查询请求报文但并不知道被查询域名的IP地址时，这个根域名服务器就把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，就告诉本地域名服务器下一步应当向哪一个权威域名服务器进行查询。这样查询下去，主机就知道了所要解析的域名的IP地址。</p><p>本地域名服务器和主机中均会缓存域名信息，主机只在从缓存中找不到欲解析的域名时才向本地域名服务器发送查询请求报文。本地域名服务器和本机的域名信息都会定期更新。</p><p>如果全部迭代查询，上层服务器将长时间保持连接（因为要代替本地域名服务器去查），所以负担大</p><p>参考：<br>《计算机网络教程》 谢钧，谢希仁 人民邮电出版社</p><h2 id="https的流程可以描述一下么？如果没有证书可以么？"><a href="#https的流程可以描述一下么？如果没有证书可以么？" class="headerlink" title="https的流程可以描述一下么？如果没有证书可以么？"></a>https的流程可以描述一下么？如果没有证书可以么？</h2><h3 id="为什么要用https？"><a href="#为什么要用https？" class="headerlink" title="为什么要用https？"></a>为什么要用https？</h3><p>实际使用中，绝大说的网站现在都采用的是https协议，这也是未来互联网发展的趋势。下面是通过wireshark抓取的一个博客网站的登录请求过程。</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF.png" alt="敏感信息"></p><p>可以看到访问的账号密码都是明文传输， 这样客户端发出的请求很容易被不法分子截取利用，因此，HTTP协议不适合传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信息非常不安全。</p><p>一般http中存在如下问题：<br>请求信息明文传输，容易被窃听截取。<br>数据的完整性未校验，容易被篡改<br>没有验证对方身份，存在冒充危险</p><h3 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS?"></a>什么是HTTPS?</h3><p>为了解决上述HTTP存在的问题，就用到了HTTPS。</p><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL&#x2F;TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p><p>那么SSL又是什么？</p><p>SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP&#x2F;IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><p>SSL发展史（互联网加密通信）</p><p>1994年NetSpace公司设计SSL协议（Secure Sockets Layout）1.0版本，但未发布。<br>1995年NetSpace发布SSL&#x2F;2.0版本，很快发现有严重漏洞<br>1996年发布SSL&#x2F;3.0版本，得到大规模应用<br>1999年，发布了SSL升级版TLS&#x2F;1.0版本，目前应用最广泛的版本<br>2006年和2008年，发布了TLS&#x2F;1.1版本和TLS&#x2F;1.2版本</p><h3 id="浏览器在使用HTTPS传输数据的流程是什么？"><a href="#浏览器在使用HTTPS传输数据的流程是什么？" class="headerlink" title="浏览器在使用HTTPS传输数据的流程是什么？"></a>浏览器在使用HTTPS传输数据的流程是什么？</h3><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B.png" alt="数据传输流程"></p><ul><li>首先客户端通过URL访问服务器建立SSL连接。</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。</li><li>客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>服务器利用自己的私钥解密出会话密钥。</li><li>服务器利用会话密钥加密与客户端之间的通信。</li></ul><h3 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h3><p>HTTPS协议多次握手，导致页面的加载时间延长近50%；<br>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；<br>申请SSL证书需要钱，功能越强大的证书费用越高。<br>SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。</p><h3 id="总结HTTPS和HTTP的区别"><a href="#总结HTTPS和HTTP的区别" class="headerlink" title="总结HTTPS和HTTP的区别"></a>总结HTTPS和HTTP的区别</h3><p>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL&#x2F;TLS协议进行了加密处理。<br>http和https使用连接方式不同，默认端口也不一样，http是80，https是443。</p><h3 id="如果没有https证书可以访问么"><a href="#如果没有https证书可以访问么" class="headerlink" title="如果没有https证书可以访问么"></a>如果没有https证书可以访问么</h3><p>可以，就当相信对方，但是实际安全无法保障，因为没有权威机构认证身份。一般界面会显示“告诉你对方证书无效，是否继续连接？”，可以无视提示继续连接。</p><p>参考：<br><a href="https://www.zhihu.com/question/300285738">如果没有有效的证书，HTTPS连接是否加密的？</a><br><a href="https://zhuanlan.zhihu.com/p/34753269">科普！什么是SSL证书？为什么要买SSL证书？</a><br><a href="https://www.zhihu.com/tardis/zm/art/72616216">十分钟搞懂HTTP和HTTPS协议？</a></p><h2 id="select，poll，epoll的区别？epoll的ET和LT分别是什么？"><a href="#select，poll，epoll的区别？epoll的ET和LT分别是什么？" class="headerlink" title="select，poll，epoll的区别？epoll的ET和LT分别是什么？"></a>select，poll，epoll的区别？epoll的ET和LT分别是什么？</h2><h3 id="select，poll，epoll"><a href="#select，poll，epoll" class="headerlink" title="select，poll，epoll"></a>select，poll，epoll</h3><p>最基础的 TCP 的 Socket 编程，它是阻塞 I&#x2F;O 模型，基本上只能一对一通信，那为了服务更多的客户端，我们需要改进网络 I&#x2F;O 模型。</p><p>比较传统的方式是使用多进程&#x2F;线程模型，每来一个客户端连接，就分配一个进程&#x2F;线程，然后后续的读写都在对应的进程&#x2F;线程，这种方式处理 100 个客户端没问题，但是当客户端增大到 10000  个时，10000 个进程&#x2F;线程的调度、上下文切换以及它们占用的内存，都会成为瓶颈。</p><p>为了解决上面这个问题，就出现了 I&#x2F;O 的多路复用，可以只在一个进程里处理多个文件的  I&#x2F;O，Linux 下有三种提供 I&#x2F;O 多路复用的 API，分别是：select、poll、epoll。</p><p>select 和 poll 并没有本质区别，它们内部都是使用「线性结构」来存储进程关注的 Socket 集合。</p><p>在使用的时候，首先需要把关注的 Socket 集合通过 select&#x2F;poll 系统调用从用户态拷贝到内核态，然后由内核检测事件，当有网络事件产生时，内核需要遍历进程关注 Socket 集合，找到对应的 Socket，并设置其状态为可读&#x2F;可写，然后把整个 Socket 集合从内核态拷贝到用户态，用户态还要继续遍历整个 Socket 集合找到可读&#x2F;可写的 Socket，然后对其处理。</p><p>很明显发现，select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。</p><p>epoll 是解决 C10K 问题的利器，通过两个方面解决了 select&#x2F;poll 的问题。</p><p>epoll 在内核里使用「红黑树」来关注进程所有待检测的 Socket，红黑树是个高效的数据结构，增删查一般时间复杂度是 O(logn)，通过对这棵黑红树的管理，不需要像 select&#x2F;poll 在每次操作时都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</p><p>epoll 使用事件驱动的机制，内核里维护了一个「链表」来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select&#x2F;poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。</p><p>而且，epoll 支持边缘触发和水平触发的方式，而 select&#x2F;poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。</p><h3 id="ET和LT"><a href="#ET和LT" class="headerlink" title="ET和LT"></a>ET和LT</h3><p>epoll 支持两种事件触发模式，分别是边缘触发（edge-triggered，ET）和水平触发（level-triggered，LT）。</p><p>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</p><p>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，目的是告诉我们有数据需要读取；</p><p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。</p><p>如果使用边缘触发模式，I&#x2F;O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，边缘触发模式一般和非阻塞 I&#x2F;O 搭配使用，程序会一直执行 I&#x2F;O 操作，直到系统调用（如 read 和 write）返回错误，错误类型为 EAGAIN 或 EWOULDBLOCK。</p><p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p><p>参考：<br><a href="https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA">这次答应我，一举拿下 I&#x2F;O 多路复用</a></p><h2 id="IO的模型有哪几种？Reactor和Preactor线程模型有了解？"><a href="#IO的模型有哪几种？Reactor和Preactor线程模型有了解？" class="headerlink" title="IO的模型有哪几种？Reactor和Preactor线程模型有了解？"></a>IO的模型有哪几种？Reactor和Preactor线程模型有了解？</h2><h3 id="IO的模型有哪几种"><a href="#IO的模型有哪几种" class="headerlink" title="IO的模型有哪几种"></a>IO的模型有哪几种</h3><ul><li>阻塞I&#x2F;O</li></ul><p>当用户程序执行 read ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，read 才会返回。</p><p>注意，阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程。</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%BB%E5%A1%9EIO.png" alt="阻塞IO"></p><ul><li>非阻塞I&#x2F;O</li></ul><p>非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果。</p><p>注意，这里最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png" alt="非阻塞IO"></p><p>如果 socket 设置了 O_NONBLOCK 标志，那么就表示使用的是非阻塞 I&#x2F;O 的方式访问，而不做任何设置的话，默认是阻塞 I&#x2F;O。因此，无论 read 和 send 是阻塞 I&#x2F;O，还是非阻塞 I&#x2F;O 都是同步调用。因为在 read 调用时，内核将数据从内核空间拷贝到用户空间的过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</p><ul><li>异步I&#x2F;O</li></ul><p>真正的异步 I&#x2F;O 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。当我们发起 aio_read （异步 I&#x2F;O） 之后，就立即返回，内核自动将数据从内核空间拷贝到用户空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BC%82%E6%AD%A5IO.png" alt="异步IO"></p><ul><li>对比</li></ul><p>举个你去饭堂吃饭的例子，你好比应用程序，饭堂好比操作系统。<br>阻塞 I&#x2F;O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。<br>非阻塞 I&#x2F;O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。<br>异步 I&#x2F;O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。<br>很明显，异步 I&#x2F;O 比同步 I&#x2F;O 性能更好，因为异步 I&#x2F;O 在「内核数据准备好」和「数据从内核空间拷贝到用户空间」这两个过程都不用等待。</p><p>可惜的是，在 Linux 下的异步 I&#x2F;O 是不完善的， aio 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。</p><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>I&#x2F;O多路复用可以应对高并发请求场景，不必针对每个请求连接创建一个线程去处理。 select&#x2F;poll&#x2F;epoll 就是内核提供给用户态的多路复用系统调用，线程可以通过一个系统调用函数从内核中获取多个事件。但是直接通过I&#x2F;O 多路复用接口写网络程序开发效率太低，于是，大佬们基于面向对象的思想，对 I&#x2F;O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写，这种封装的模式就叫Reactor 模式</p><p>Reactor 模式也叫 Dispatcher 模式，即 I&#x2F;O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 &#x2F; 线程。</p><p>Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：</p><p>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；<br>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</p><p>经典的 Reactor 方案如下：</p><ul><li>单 Reactor 单进程 &#x2F; 线程处理资源池；</li></ul><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%95r%E5%8D%95%E7%BA%BF%E7%A8%8B.png" alt="单r单线程"></p><p>可以看到进程里有 Reactor、Acceptor、Handler 这三个对象：Reactor 对象的作用是监听和分发事件；Acceptor 对象的作用是获取连接；Handler 对象的作用是处理业务；对象里的 select、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。</p><p>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</p><p>单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。但是，这种方案存在 2 个缺点：第一个缺点，因为只有一个进程，无法充分利用 多核 CPU 的性能；第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟；所以，单 Reactor 单进程的方案不适用计算机密集型的场景，只适用于业务处理非常快速的场景。Redis 是由 C 语言实现的，它采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。</p><ul><li>单 Reactor 多线程 &#x2F; 进程处理资源池；</li></ul><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%95r%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="单r多线程"></p><p>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了：Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；</p><p>单 Reator 多线程的方案优势在于能够充分利用多核 CPU 的能，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。「单 Reactor」的模式还有个问题，因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。</p><p>单 Reactor 多进程相比单 Reactor 多线程实现起来很麻烦，实际应用中也看不到单 Reactor 多进程的模式。</p><ul><li>多 Reactor 多进程 &#x2F; 线程处理资源池；</li></ul><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A4%9Ar%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="多r多线程"></p><p>主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</p><p>多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下：主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。</p><p>大名鼎鼎的两个开源软件 Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。</p><h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><p>前面提到的 Reactor 是非阻塞同步网络模式，而 Proactor 是异步网络模式。<br>linux中对于异步I&#x2F;O支持不完善，所以Linux 的高性能网络程序都是使用 Reactor 方案。</p><p>参考：<br><a href="https://www.zhihu.com/question/26943938/answer/1856426252">如何深刻理解Reactor和Proactor</a></p><h2 id="NIO的三大件分别是什么"><a href="#NIO的三大件分别是什么" class="headerlink" title="NIO的三大件分别是什么"></a>NIO的三大件分别是什么</h2><p>Java NIO（New IO）是从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 Java IO API。NIO 与原来的 IO 有同样的作用和目的，但是使用方式完全不同，NIO 支持面向缓冲区的、基于通道的 IO 操作。NIO 将以更加高效的方式进行文件的读写操作。</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E7%BB%9Fio.png" alt="传统io"></p><p>传统的 IO 是面向流的（一个个字节数据的流动）,传统的 IO 流是单向的</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/nio.png" alt="nio"></p><p>NIO面向缓冲区,缓冲区是双向的。通道Channel可以类比铁路，而缓冲区Buffer可以类比火车。</p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>缓冲区（Buffer）：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer</p><ul><li>核心方法</li></ul><p>put():存入数据到缓冲区中；get():获取缓冲区中的数据</p><ul><li>核心属性</li></ul><p>capacity: 容量，表示缓冲区中最大存储数据的容量。一旦声明不能更改。<br>limit: 界限，表示缓冲区中可以操作数据的大小。（limit 后的数据不能进行读写）<br>position: 位置，表示缓冲区中正在操作数据的位置。<br>mark: 标记，表示记录当前 position 的位置。可以通过 reset() 恢复到 mark 的位置。</p><p>0 &lt;&#x3D; mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</p><ul><li>直接缓冲区与非直接缓冲区</li></ul><p>(1)非直接缓冲区</p><p>通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存之中。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">String str = &quot;abcde&quot;;<br>//分配一个指定大小的缓冲区<br>ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;---------allocate-----------&quot;);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(byteBuffer.capacity());   //<span class="hljs-number">1024</span><br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(byteBuffer.<span class="hljs-keyword">limit</span>());      //<span class="hljs-number">1024</span><br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(byteBuffer.position());   //<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2.png" alt="非直接缓冲"></p><p>应用程序想从磁盘中读取一个数据，这时候应用程序向操作系统发起一个读请求，那么首先磁盘中的数据会被读取到内核地址空间中，然后会把内核地址空间中的数据拷贝到用户地址空间中（其实就是 JVM 内存中），最后再把这个数据读取到应用程序中来。同样，如果应用程序有数据想要写到磁盘中去，那么它会首先把这个数据写入到用户地址空间中去，然后把数据拷贝到内核地址空间，最后再把这个数据写入到磁盘中去。</p><p>(2)直接缓冲区</p><p>通过 allocateDirect() 方法分配缓冲区，将缓冲区直接建立在物理内存之中，避免无效的复制。</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2.png" alt="直接缓冲"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span>()</span> &#123;<br>    <span class="hljs-comment">// 分配直接缓冲区</span><br>    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>);<br>    <span class="hljs-comment">// 判断是直接缓冲区还是非直接缓冲区</span><br>    System.<span class="hljs-keyword">out</span>.println(byteBuffer.isDirect());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Channel 用于源节点与目标节点的连接， Channel 本身不能直接访问数据，Channel 只能与 Buffer 进行交互。<br>常见Channel：FileChannel、SocketChannel、ServerSocketChannel、DatagramChannel</p><ul><li>获取通道</li></ul><p>(1) Java 针对支持通道的类提供了 getChannel() 方法</p><p>本地 IO：<br>FileInputStream&#x2F;FileOutputStream<br>RandomAccessFile</p><p>网络 IO:<br>Socket<br>ServerSocket<br>DatagramSocket</p><p>以上几个类都可以通过调用 getChannel() 方法获取通道</p><p>(2)在 JDK1.7 中的 NIO.2 针对各个通道提供了静态方法 open()</p><p>(3)在 JDK1.7 中的 NIO.2 的 Files 工具类的 newByteChannel() 方法</p><ul><li>Channel案例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 利用通道完成文件的复制(非直接缓冲区)</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;b.txt&quot;</span>);<br>        <span class="hljs-comment">// 获取通道</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fisChannel</span> <span class="hljs-operator">=</span> fis.getChannel();<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">foschannel</span> <span class="hljs-operator">=</span> fos.getChannel();<br><br>        <span class="hljs-comment">// 通道没有办法传输数据，必须依赖缓冲区</span><br>        <span class="hljs-comment">// 分配指定大小的缓冲区</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>        <span class="hljs-comment">// 将通道中的数据存入缓冲区中</span><br>        <span class="hljs-keyword">while</span> (fisChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// fisChannel 中的数据读到 byteBuffer 缓冲区中</span><br>            byteBuffer.flip();  <span class="hljs-comment">// 切换成读数据模式</span><br>            <span class="hljs-comment">// 将缓冲区中的数据写入通道</span><br>            foschannel.write(byteBuffer);<br>            byteBuffer.clear();  <span class="hljs-comment">// 清空缓冲区</span><br>        &#125;<br>        foschannel.close();<br>        fisChannel.close();<br>        fos.close();<br>        fis.close();<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> test2() <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 使用直接缓冲区完成文件的复制(内存映射文件)</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 使用 open 方法来获取通道</span><br><span class="hljs-comment">         * 需要两个参数</span><br><span class="hljs-comment">         * 参数1：Path 是 JDK1.7 以后给我们提供的一个类，代表文件路径</span><br><span class="hljs-comment">         * 参数2：Option  就是针对这个文件想要做什么样的操作</span><br><span class="hljs-comment">         *      --StandardOpenOption.READ ：读模式</span><br><span class="hljs-comment">         *      --StandardOpenOption.WRITE ：写模式</span><br><span class="hljs-comment">         *      --StandardOpenOption.CREATE ：如果文件不存在就创建，存在就覆盖</span><br><span class="hljs-comment">         */</span><br>    FileChannel inChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;a.txt&quot;</span>), StandardOpenOption.<span class="hljs-keyword">READ</span>);<br>    FileChannel outChannel = FileChannel.open(Paths.get(<span class="hljs-string">&quot;c.txt&quot;</span>), StandardOpenOption.<span class="hljs-keyword">WRITE</span>,<br>                                              StandardOpenOption.<span class="hljs-keyword">READ</span>, StandardOpenOption.CREATE);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 内存映射文件</span><br><span class="hljs-comment">         * 这种方式缓冲区是直接建立在物理内存之上的</span><br><span class="hljs-comment">         * 所以我们就不需要通道了</span><br><span class="hljs-comment">         */</span><br>    MappedByteBuffer inMapped = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, inChannel.<span class="hljs-keyword">size</span>());<br>    MappedByteBuffer outMapped = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, inChannel.<span class="hljs-keyword">size</span>());<br><br>    <span class="hljs-comment">// 直接对缓冲区进行数据的读写操作</span><br>    <span class="hljs-keyword">byte</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inMapped.limit()];<br>    inMapped.get(dst);  <span class="hljs-comment">// 把数据读取到 dst 这个字节数组中去</span><br>    outMapped.put(dst); <span class="hljs-comment">// 把字节数组中的数据写出去</span><br><br>    inChannel.close();<br>    outChannel.close();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> test3() throws <span class="hljs-keyword">Exception</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 通道之间的数据传输（直接缓冲区的方式）</span><br><span class="hljs-comment">         * transferFrom</span><br><span class="hljs-comment">         * transferTo</span><br><span class="hljs-comment">         */</span><br>    FileChannel inChannel = FileChannel.<span class="hljs-keyword">open</span>(Paths.<span class="hljs-keyword">get</span>(&quot;a.txt&quot;), StandardOpenOption.<span class="hljs-keyword">READ</span>);<br>    FileChannel outChannel = FileChannel.<span class="hljs-keyword">open</span>(Paths.<span class="hljs-keyword">get</span>(&quot;d.txt&quot;), StandardOpenOption.<span class="hljs-keyword">READ</span>, StandardOpenOption.<span class="hljs-keyword">WRITE</span>,<br>                                              StandardOpenOption.<span class="hljs-keyword">CREATE</span>);<br>    inChannel.transferTo(<span class="hljs-number">0</span>, inChannel.size(), outChannel);<br>    // 或者可以使用下面这种方式<br>    //outChannel.transferFrom(inChannel, <span class="hljs-number">0</span>, inChannel.size());<br>    inChannel.<span class="hljs-keyword">close</span>();<br>    outChannel.<span class="hljs-keyword">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>假设NIO没有这个Selector选择器，那么此时一个客户端连接过来就要对应的一个线程去处理，但是这个客户端可能只是连接一下，并不会立马就会有读写事件，那么此时依然会造成线程的阻塞，导致资源的浪费。有了Selector之后，客户端发送连接请求之后，服务端就把对应的SocketChannle注册到Selector上去。如果这时候该客户端Channle上有读写事件发生，再把请求交给对应的线程处理，如果没有就不做任何处理，这样没有事件的时候线程不会处于阻塞状态，也不会导致系统资源的浪费，只有真正有事件发生的Channel才会交给对应的线程去处理。<br>本质也是在做IO多路复用的事情，底层调用的系统调用的select函数。</p><p><img src="/2023/06/06/%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/selector.png" alt="selector"></p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/369062109">Java 中 NIO 看这一篇就够了</a><br><a href="https://blog.csdn.net/qq_34626097/article/details/89278943">Java NIO之三 直接缓冲区、非直接缓冲区、区别、及底层实现</a><br><a href="https://juejin.cn/post/7097020623657893919">NIO三大核心详解</a><br><a href="https://juejin.cn/post/7032547413764079630">Java NIO（NIO socket网络编程）</a><br><a href="https://juejin.cn/post/7059400681949495327">Java NIO 中的 Selector 详解</a><br><a href="https://zhuanlan.zhihu.com/p/150635981">面试系列 深入理解NIO select&amp;epoll</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ">微信公众号:我的IT技术路</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;整理计算机网络的相关面试题，计算机网络在我看来挺复杂的，想要完全精通应该是不可能的，毕竟后端开发的知识点那么多，不过掌握面试的常考知识点是由</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://soatree.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="面试" scheme="http://soatree.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>八股文--jvm</title>
    <link href="http://soatree.github.io/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/"/>
    <id>http://soatree.github.io/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/</id>
    <published>2023-05-23T13:36:37.000Z</published>
    <updated>2023-07-15T01:41:50.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>jvm相关面试题目整理</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="JVM-的内存模型描述一下？"><a href="#JVM-的内存模型描述一下？" class="headerlink" title="JVM 的内存模型描述一下？"></a>JVM 的内存模型描述一下？</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>线程私有。可以看作是当前线程做执行的字节码的行号指示器。此内存区域是唯一一个在《JVM规范》中没有规定任何outOfMemoryError情况的区域。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>线程私有。虚拟机栈描述的是java方法执行的线程内存模型：每个方法执行时，jvm会同步创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法被调用直到执行完毕的过程对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>如果线程请求的栈深度超过了虚拟机允许的深度时会抛出StackOverflowError异常；如果jvm栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常（HopSpot不允许栈空间扩展，只有在申请的时候空间不足会抛出该异常，在运行的时候不会出现该异常）。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>线程私有。和虚拟机栈类似，只不过本地方法栈服务于本地方法（native方法）。也会抛出StackOverflowError异常和OutOfMemoryError异常。<br>当堆内存超过上限时会抛出OutOfMemoryError异常。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>线程共享。几乎所有的对象实例及数组都分配在java堆上。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>线程共享。用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。<br>jdk8以前，Hotspot设计团队把收集器的分代设计扩展至方法区或者说用永久代实现了方法区，所以有的人会认为方法区是永久代，实际上是不严谨的。jdk8将方法区采用本地内存来实现，这个空间叫做元空间（meta-space），方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。<br>运行时常量池是方法去的一部分。Class文件中除了有类版本、字段、方法、接口等信息的描述外，还有一项信息是常量池表，用于存放编译期间生成的各种字面量和符号引用，常量池表在类加载后存放到方法区的运行时常量池中。运行时常量池一般除了保存class文件中描述的符号引用外，还会把符号引用翻译出来的直接引用也存储在运行时常量池中。<br>另外运行时常量池具备动态性，处理类加载时导入的常量外，可以在程序运行中加入新的常量。常量池无法再申请内存的时候会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不是JVM运行时数据区的一部分，也不是《规范》中定义的内存区域，但是这部分可能被频繁使用，而且也会导致OutOfMemoryError异常。一般为NIO使用。</p><h3 id="java运行时数据区域的垃圾回收"><a href="#java运行时数据区域的垃圾回收" class="headerlink" title="java运行时数据区域的垃圾回收"></a>java运行时数据区域的垃圾回收</h3><p>程序计数器、虚拟机栈、本地方法栈3个区域和线程的生命周期一致，栈中的栈帧随着方法的进入和退出有序地执行进栈和出栈。每个栈帧中分配的内存基本是在类结构确定下来就已知了，所以这些区域的内存分配和回收是确定的，不用过多考虑垃圾回收问题，当方法或者线程结束的时候，内存就随着回收了。<br>java堆和方法区里对象和接口的分配和回收是动态，只有在运行期间才会知道有那些接口和对象，这两块的垃圾回收是需要重点关注的。</p><p>参考：<br><a href="https://www.cnblogs.com/lllliuxiaoxia/p/15785650.html">jvm运行时数据区域</a></p><h2 id="内存溢出的情况"><a href="#内存溢出的情况" class="headerlink" title="内存溢出的情况"></a>内存溢出的情况</h2><h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><p>在堆中创建对象一直被GC Roots引用无法被清理，同时堆中的对象内存超过了最大堆内存，发生堆内存溢出。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapOOM</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMObject</span></span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        ArrayList&lt;OOMObject&gt; objects = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            objects.add(<span class="hljs-keyword">new</span> <span class="hljs-type">OOMObject</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>错误信息提示“java.lang.OutOfMemoryError: Java heap space”<br>可以通过MAT进行分析定位</p><h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>由于HotSpot不区分虚拟机栈和本地方法栈，所以栈容量只能由-Xss参数设置。虚拟机栈和本地方法栈在《规范》中有两种异常：（1）栈深度超限，抛出StackOverflowError；（2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。HotSpot虚拟机不支持扩展栈内存，所以除非 在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。<br>每个线程的栈空间是线程独有的。对于HotSpot，-Xss参数表示单个线程的栈空间上限，如果-Xss较小，会导致没有空间创建新的栈帧，抛出StackOverflowError，如果在方法里定义大量变量，增加每个栈帧的大小，在相同的-Xss参数下，会导致能创建的栈帧数量变少，方法调用深度变少，最终也会抛出StackOverflowError。<br>对于多线程而言，每个线程都拥有-Xss参数大小的栈空间，如果反复循环创建线程。如果是32位的windows或者linux环境，每个进程可用的内存上限为若干GB，进程内存上限-堆内存-方法区内存-JVM自身内存-直接内存~&#x3D;栈空间可用内存，当多个线程的栈空间和大于栈空间可用内存时，会抛出OutOfMemoryError异常。如果-Xss参数设置越大，会越快的出现这个异常。<br><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create native thread</code><br>不过对于64位的系统，进程内存上限达上百TB，不会出现上述的OutOfMemoryError异常，但是可能会不断侵占本地内存。在64位linux服务器上尝试了下，cpu基本占满，虚拟内存占用较多（54.3G），实际内存缓慢增长，开始内存增长快，后面速度降低，可能因为线程较多，主线程创建新线程的速度下降，看上去内存增长似乎很难达到服务器上限，主要的问题应该还是集中在cpu占用上。</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%9E%81%E9%99%90.png" alt="线程创建极限"></p><h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><ul><li>字符串常量池溢出</li></ul><p>运行时常量池是方法区的一部分，字符串常量池是运行时常量池的一部分，但是jdk7以上将字符串常量池移到了java堆中。以下代码，如果在jdk6上运行，并且设置-XX: PermSize&#x3D;6M -XX: MaxPermSize&#x3D;6M时，会报OutOfMemoryError: PermGen space，即永久代(方法区)内存溢出；但是如果在jdk7及以上，字符串常量池移到了java堆中，由于堆内存十分大，下面代码的循环几乎一直运行，但是如果设置-Xmx为6MB，也会报OutOfMemoryError: Java heap space。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeConstantPoolOOM</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Set&lt;<span class="hljs-type">String</span>&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-type">short</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            System.out.<span class="hljs-built_in">println</span>(i);<br>            set.<span class="hljs-built_in">add</span>(<span class="hljs-type">String</span>.<span class="hljs-built_in">valueOf</span>(i).<span class="hljs-built_in">intern</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法区的变动：</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/jdk6%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="jdk6方法区"><br><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/jdk8%E6%96%B9%E6%B3%95%E5%8C%BA.png" alt="jdk8及以后方法区"></p><ul><li>方法区其他部分溢出（类加载溢出）</li></ul><p>jdk7，方法区还由永久代实现，可以比较容易的出发方法区溢出，jdk8之后方法区由元空间实现，理论上仅受限于系统内存，同时可以实现垃圾回收，很难出现方法区溢出，如果类大量加载可能出现方法区溢出。但是HotSpot提供了若干防御性参数避免元空间的任意使用。例如：<br>-XX：MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。该值表示了元空间能够申请空间的极限。<br>-XX：MetaspaceSize：指定元空间的最小回收阈值，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值。</p><h3 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h3><p>直接内存（DirectMemory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致。由直接内存导致的内存溢出，一个明显的特征是在HeapDump文件中不会看见有什么明显的异常情况，如果读者发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了。异常信息一般如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.outofMemoryError</span><br>at sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.allocateMemory</span>(Native Method)<br>at org<span class="hljs-selector-class">.fenixsoft</span><span class="hljs-selector-class">.oom</span>. DMOOM<span class="hljs-selector-class">.main</span>(DMOOM<span class="hljs-selector-class">.java</span>:<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>参考：<br>《深入理解java虚拟机：jvm高级特性和最佳实践》<br><a href="https://blog.csdn.net/weixin_42709563/article/details/106234230">一个程序最多可以使用多少内存？</a><br><a href="https://juejin.cn/post/7058375922235211790">深刻理解运行时常量池、字符串常量池</a><br><a href="https://blog.csdn.net/wangyili002/article/details/105584663">JVM参数-XX:MatespaceSize的含义</a></p><h2 id="java对象状态判定"><a href="#java对象状态判定" class="headerlink" title="java对象状态判定"></a>java对象状态判定</h2><h3 id="判断对象存活的方法"><a href="#判断对象存活的方法" class="headerlink" title="判断对象存活的方法"></a>判断对象存活的方法</h3><ul><li>引用计数法</li></ul><p>在对象中添加一个引用计数器，每有一个地方引用就加一，每有一个引用失效就减一，减到0时认为对象已死。<br>优点：判别效率高，原理简单<br>缺点：占用额外内存空间，需要考虑大量的例外情况，例如相互循环引用的问题。</p><ul><li>可达性分析算法</li></ul><p>当前主流的商用程序语言的内存管理子系统都是通过可达性分析算法判定对象是否存活的，通过一系列称为“GC roots”的跟对象作为其实节点集，从这些节点开始，根据应用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说从GC roots到这个对象不可达时，则证明这个对象时不可能再被使用的。</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt="可达性分析"></p><h3 id="java的GC-Roots"><a href="#java的GC-Roots" class="headerlink" title="java的GC Roots"></a>java的GC Roots</h3><p>在Java技术体系里面，固定可作为GCRoots的对象包括以下几种：</p><ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在本地方法栈中JNI（即通常所说的Native方法）方法）引用的对象。</li><li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，譬如字符串常量池（StringTable）里的引用。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。<br>除了这些固定的GCRoots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GCRoots集合</li></ul><h3 id="java如何判定对象死亡"><a href="#java如何判定对象死亡" class="headerlink" title="java如何判定对象死亡"></a>java如何判定对象死亡</h3><p>1）首先通过可达性分析判定对象已经不被引用链关联；<br>2）在对象可能执行的finalize方法（如果没有重写该方法或者已经被调用过将被视为“没有必要执行”）中，该对象没有逃脱（finalize中对象可能重新被引用链关联）。<br>以上两个阶段都符合后，对象将判定死亡并被回收。但是不建议大家使用finalize方法，这个方法十分不可靠。</p><p>参考：<br>《深入理解java虚拟机：jvm高级特性和最佳实践》</p><h2 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h2><p>方法区的回收较为苛刻，性价比低，但是在某些特定的场景（如大量使用反射、动态代理、CGlib等字节码框架）收集方法区是有必要的。<br>如何判定一个类是否属于“不再被使用的类”？</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。</li></ul><h2 id="JVM堆内存为什么要分成新生代，老年代，持久代？新生代中为什么要分为Eden和Survivor？"><a href="#JVM堆内存为什么要分成新生代，老年代，持久代？新生代中为什么要分为Eden和Survivor？" class="headerlink" title="JVM堆内存为什么要分成新生代，老年代，持久代？新生代中为什么要分为Eden和Survivor？"></a>JVM堆内存为什么要分成新生代，老年代，持久代？新生代中为什么要分为Eden和Survivor？</h2><h3 id="为何分代"><a href="#为何分代" class="headerlink" title="为何分代"></a>为何分代</h3><p>分代收集理论<br>1）弱分代假说（WeakGenerationalHypothesis）：绝大多数对象都是朝生夕灭的。<br>2）强分代假说（StrongGenerationalHypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。<br>3）跨代引用假说（IntergenerationalReferenceHypothesis）：跨代引用相对于同代引用来说仅占极少数。<br>jdk8之前采用永久代实现方法区，认为该空间一般不需要进行垃圾回收，jdk8开始使用叫做元空间的本地内存实现方法区，会进行垃圾回收；分代主要是为了让不同代的对象按照不同的频率回收，减少不必要的垃圾回收开销，这里考虑了弱分代假说和强分代假说。</p><p>不用为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，RememberedSet），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生MinorGC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p><h3 id="新生代中为什么要分为Eden和Survivor"><a href="#新生代中为什么要分为Eden和Survivor" class="headerlink" title="新生代中为什么要分为Eden和Survivor"></a>新生代中为什么要分为Eden和Survivor</h3><p>新生代采用标记-复制算法，但是半区的标记-复制只能使用一般的区域。IBM公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。所以产生了Appel式回收，将存活的新生代放到Survivor中，如果Survivor0、Survivor1、Eden的比例为1：1：8，则可以有效利用新生代90的空间。</p><p>任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次MinorGC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（HandlePromotion）。</p><p>参考：<br>《深入理解java虚拟机：jvm高级特性和最佳实践》</p><h2 id="简述下垃圾回收算法？为什么新生代使用复制算法？"><a href="#简述下垃圾回收算法？为什么新生代使用复制算法？" class="headerlink" title="简述下垃圾回收算法？为什么新生代使用复制算法？"></a>简述下垃圾回收算法？为什么新生代使用复制算法？</h2><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul><li>标记-清除算法</li></ul><p>先标记（可能标记存活的对象，也可能标记死亡的对象），标记完成后在清除。<br>优点：标记清除速度快；<br>缺点：标记清除操作效率随着对象的增长而降低，内存碎片化导致大对象无法分配导致再次触发GC；</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="可达性分析"></p><ul><li>标记-复制算法</li></ul><p><strong>半区复制</strong></p><p>将内存分为大小相等的两块，一块内存用完，将存活的少量对象移动到另一块内存上，保障了新的可用内存区域的连续性，然后集中清理原来那块内存。<br>优点：速度快，内存空间连续<br>缺点：可用内存减半</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="可达性分析"></p><p><strong>Appel式回收</strong></p><p>IBM公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。<br>AndrewAppel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。<br>Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次MinorGC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（HandlePromotion）。</p><ul><li>标记-整理算法</li></ul><p>标记-整理算法，先标记，再整理，最后清理。</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="可达性分析"></p><p>CMS收集器平时采用标记清除算法，当内存的碎片化程度较高影响对象分配时，采用标记整理算法整理一次内存空间。</p><h3 id="为什么新生代使用复制算法"><a href="#为什么新生代使用复制算法" class="headerlink" title="为什么新生代使用复制算法"></a>为什么新生代使用复制算法</h3><p>复制算法效率会高于整理算法，新生代使用复制算法每次只需要复制少量的对象，且没有碎片内存空间，另外存在担保空间，所以可以使用；老年代没有担保，所以无法使用复制算法。</p><p>参考：<br>《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》</p><h2 id="简述一下垃圾回收器？说下各自的优缺点？有了解过cms和G1么？能详细说明一下么？"><a href="#简述一下垃圾回收器？说下各自的优缺点？有了解过cms和G1么？能详细说明一下么？" class="headerlink" title="简述一下垃圾回收器？说下各自的优缺点？有了解过cms和G1么？能详细说明一下么？"></a>简述一下垃圾回收器？说下各自的优缺点？有了解过cms和G1么？能详细说明一下么？</h2><h3 id="GC术语"><a href="#GC术语" class="headerlink" title="GC术语"></a>GC术语</h3><p>Partial GC:目标不是完整收集整个java堆的垃圾收集<br>Minor GC&#x2F;Young GC(收集新生代),Major GC&#x2F;Old GC（收集老年代，目前只有CMS会有单独回收老年代的行为）,Mixed GC（收集整个新生代和部分老年代）<br>Full GC:收集整个堆和方法区。</p><h3 id="HotSpot垃圾回收相关概念"><a href="#HotSpot垃圾回收相关概念" class="headerlink" title="HotSpot垃圾回收相关概念"></a>HotSpot垃圾回收相关概念</h3><ul><li>根节点枚举</li></ul><p>尽管可达性分析中耗时最长的查找引用链的过程已经可以做到和用户线程一起并发了，但是根节点的枚举还是必须在一个能保障一致性的快照中才能进行，即根节点枚举阶段，整个执行子系统看起来被冻结在某个时间点上一样。这是导致垃圾收集过程中必须停顿所有用户线程的其中一个重要原因，虽然时间可控，但是这个停顿时不可避免的。<br>HotSpot在类加载和即时编译阶段都会将对象内各个数据类型的位置都计算出来，在根节点枚举前可以直接利用这些信息生成OopMap这么一个数据结构，直接通过OopMap获取根节点信息。</p><ul><li>安全点</li></ul><p>因为很多指令都会导致引用关系变化，同时也会导致OopMap变化，所以不能在完成每条指令后都生成OopMap，这样开销太大，所以HotSpot只在安全点生成OopMap。<br>安全点一般在方法调用、循环跳转、异常调转等指令序列复用（具有让程序长时间执行的特征）处选取。<br>多线程安全点暂停的方案有抢占式中断和主动式中断。目前虚拟机一般都采用主动式中断方式。即在需要中断线程的时候不直接对线程操作，而是简单设置一个标志位，各线程不断主动轮询这个标志位，一旦标志位为真，各线程就在自己最近的安全点上主动中断挂起，一般是到达某个安全点开始轮询标志位。</p><ul><li>安全区域</li></ul><p>线程在处于sleep或者阻塞状态时无法响应虚拟机中断，此时如果等线程自己走到安全点将花费大量的时间，这个不太现实，所以引入安全区域的概念。安全区域能确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中的任意地方开始垃圾回收都是安全的。可以将安全区域当成安全点的延展。如果线程进入安全区域且发生了GCRoots枚举，需要等待枚举完成后再离开安全区域。</p><ul><li>记忆集和卡表</li></ul><p>新生代和老年代可能存在跨代引用（只考虑老年代引用新生代的情况），涉及到部分区域收集的时候（G1、ZGC等）也会面临跨区引用。但是我们不能将引用方所在的整个内存区域如老年代整个扫描一遍，这样成本太高，所以可以维护一个数据结构记录引用了目标垃圾收集区域对象的指针，这个数据结构就是记忆集。但是如果到每一个引用指针所在的具体位置成本太高，所以推出了卡表来实现记忆集，将精确到具体指针位置变成精确到一个内存区域，该区域存在跨代指针。如果一个区域内存在跨代指针，就将这个区域内所有的对象都加入GCRoots。</p><ul><li>并发可达性分析</li></ul><p>可达性分析过程中查找引用链耗时最长，所以需要此部分和用户线程实现并发进行。如果在并发进行过程中，某几个需要清理的垃圾因为用户线程并发操作导致遗漏并不会有太大的影响，但是如果有几个对象本不该清理却因为用户线程的并发操作导致被清理则会产生致命影响。<br>相关论文证明了导致有用有对象被清理的两个条件，后续提出了两个解决方案分别用于破坏这两个条件，分别为增量更新和原始快照。CMS是基于增量更新实现并发的，而G1、Shenandoah则是用原始快照来实现的。</p><h3 id="G1前的经典垃圾收集器"><a href="#G1前的经典垃圾收集器" class="headerlink" title="G1前的经典垃圾收集器"></a>G1前的经典垃圾收集器</h3><p>下图为经典垃圾收集器的关系图，存在连线的是可以配合使用的垃圾收集器，其中有两个配合在jdk9的时候被禁止。</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="经典垃圾收集器组合"></p><p><strong>新生代垃圾收集器</strong>:</p><ul><li>Serial收集器</li></ul><p>使用一个收集器、一个线程收集垃圾，同时必须暂停其他所有工作线程，直到收集结束。采用标记-复制算法。<br>最悠久的收集器，运行在客户端模式下的默认新生代收集器，简单高效（单核环境中基本最强），适用于资源受限的环境，适合客户端或者部分微服务应用，新生代在200MB以内的场景。一般停顿在100毫秒以内。</p><ul><li>ParNew收集器</li></ul><p>ParNew收集器是Serial收集器多线程版本，控制参数、收集算法等一致。jdk9之后只能和CMS收集器配合使用。</p><ul><li>Parallel Scavenge收集器</li></ul><p>多线程并行垃圾收集器，但是Parallel Scavenge关注吞吐量（CMS等关注停顿或者说延迟），被称为“吞吐量优先收集器”，吞吐量&#x3D;（运行用户代码时间）&#x2F;（运行用户代码时间+运行垃圾收集时间），主要适用与后台计算，交互较少的分析任务。Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。XX：+UseAdaptiveSizePolicy开启后，只需要设置-XX：MaxGCPauseMillis或者-XX：GCTimeRatio参数后即可由收集器自动设置新生代大小、代数等细节参数。</p><p><strong>老年代垃圾收集器</strong>:</p><ul><li>Serial Old收集器</li></ul><p>Serial收集器的老年代版本，单线程收集器，标记-整理算法，主要用于客户端模式下的HotSpot虚拟机使用，同时作为CMS发生失败的后备预案。Parallel Scavenge收集器中包含老年代收集器，代码和Serial Old收集器一样，所以可以视为两者搭配使用。</p><ul><li>Parallel Old收集器</li></ul><p>Parallel Scavenge收集器的老年代版本，多线程并发收集，标记-整理算法。关注吞吐量，一般和Parallel Scavenge搭配，用于多核处理器且注重吞吐量的场景。</p><ul><li>CMS收集器</li></ul><p>注重减少停顿（延迟），提供较高的响应速度，提高交互体验。步骤为初始标记-并发标记-重新标记-并发清除。<br>其中并发标记和并发清除是和用户线程并发进行的，而初始标记和重新标记的时间极短，极大的降低了停顿时间。重新标记采用增量更新方式。<br>CMS是HotSpot追求低停顿的的第一次尝试，但是还有以下几个问题：<br>1）资源敏感，处理器核数超过4个时，垃圾回收占用不超过25%的资源<br>2）并发收集时用户线程会产生浮动垃圾，需要预留一定空间存放，需要设定一个阈值提前开始垃圾收集，阈值太低造成回收频率频繁，阈值太高则预留空间不足放不下浮动垃圾，此时造成并发失败，使用Serial Old收集器暂停所有其他线程进行老年代收集，停顿时间很久；<br>3）CMS收集器基于标记-清除算法，当碎片化程度高时使用标记-整理，此时停顿较大。</p><h3 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h3><p>“停顿时间模型”的收集器：能够支持指定所在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。G1可以面向堆内存任何部分来组成回收集进行回收。适用于大内存、多CPU的机器。</p><p>G1同时基于分代理论和region分区进行内存布局，每个region可以根据需要扮演eden、servivor或者老年代空间，region中有一类特殊的humongous区域用来存放大对象，G1认为只要大小超过了一个region容量一般的对象都被判为大对象，对于超过了整个region的超级大对象会存放在多个连续的humongous region 中，G1一般将humongous region当成老年代的一部分看待。G1中新生代、老年代的区域不再需要连续了。</p><p>mixed GC分批开展，基于收集器的停顿目标优先选取回收效率高的老年代进行收集（garbage first），保证了G1在有限的时间里获取尽可能高的收集效率。</p><p>region间垃圾收集看起来像是标记-复制算法又像是标记-整理算法，这两种算法都不会造成内存空间碎片化，有利于程序长期运行。</p><p>如果设置的停顿时间过小，可能导致内存回收的速度跟不上内存分配的速度，G1也要被迫冻结用户线程，导致full gc而长生长时间停顿。</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/G1%E5%A0%86.png" alt="G1堆"></p><p><strong>G1对比CMS</strong></p><p>G1收集器的设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色：<br>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片；<br>G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。采用分批开展MixedGC，避免一次停顿时间过久；<br>但是G1的执行负载较高，小内存应用上CMS表现大概率好于G1，而大内存应用上G1大概率好于CMS，平衡点经验上看在6-8GB之间。</p><h3 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h3><p>内存占用、吞吐量、延迟构成了不可能三角，一个优秀的收集器最多只能达成两项，三个指标中延迟的重要性越发重要，因为硬件规格提升可以提升吞吐量，但是对延迟反而会带来负面效果（堆越大，垃圾收集时间越长），所以延迟被视为收集器最重要的指标。<br>后续推出了新的收集器Shenandoah和ZGC，在任意堆大小情况下，停顿时间都不超过10毫秒。<br>jdk15中，ZGC已经被意见投入生产环境了。最大支持4TB的堆。</p><h3 id="垃圾收集器应用场景"><a href="#垃圾收集器应用场景" class="headerlink" title="垃圾收集器应用场景"></a>垃圾收集器应用场景</h3><p>Serial+Serial Old：单核处理器,轻量化客户端(jdk9-jdk19)<br>CMS+parNew:6GB以下堆内存，关注延迟，cpu核数最好大于4<br>Parallel Scavenge+Parallel Old:关注吞吐（jdk7-jdk8）<br>Parallel Scavenge+Serial Old：鸡肋，不考虑(jdk5-jdk7)<br>G1：6GB以上的堆内存<br>ZGC：jdk15及之后，极低延迟<br>Shenandoah：openjdk12及之后，极低延迟</p><h3 id="jdk默认垃圾收集器"><a href="#jdk默认垃圾收集器" class="headerlink" title="jdk默认垃圾收集器"></a>jdk默认垃圾收集器</h3><p>jdk7-jdk8:Parallel Scavenge+Parallel Old<br>jdk9-jdk19:G1<br>注意，有时将Serial Old和Parallel Old统称为PS MarkSweep。故有时jdk5-jdk8都显示为PS Scavenge + PS MarkSweep.</p><p>参考：<br>《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》<br><a href="https://blog.csdn.net/baidu_38083619/article/details/105752830">ZGC都出来了，你还不懂G1？</a><br><a href="https://blog.csdn.net/lovejj1994/article/details/109620239">G1调优实践日记</a><br><a href="https://zhuanlan.zhihu.com/p/181305087">G1垃圾回收参数优化</a><br><a href="https://juejin.cn/post/7001406102621388831">G1垃圾回收参数优化</a></p><h2 id="JVM-是怎么从新生代到老年代？一个完整的GC流程是怎样的？"><a href="#JVM-是怎么从新生代到老年代？一个完整的GC流程是怎样的？" class="headerlink" title="JVM 是怎么从新生代到老年代？一个完整的GC流程是怎样的？"></a>JVM 是怎么从新生代到老年代？一个完整的GC流程是怎样的？</h2><h3 id="JVM-是怎么从新生代到老年代？"><a href="#JVM-是怎么从新生代到老年代？" class="headerlink" title="JVM 是怎么从新生代到老年代？"></a>JVM 是怎么从新生代到老年代？</h3><p>（1）新创建的对象进入eden区，经过一次young GC后如果没有被清理掉将进入某个Survivor空间，同时这个对象的代数增长一个，当代数增长到某一个阈值的时候将进入老年代；<br>（2）也可能大对象直接进入老年代；<br>（3）也可能是某次young GC后一个Survivor空间容不下剩下的新生代对象，一部分对象直接通过担保机制进入老年代，<br>（4）也可能在Survivor空间中有相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：MaxTenuringThreshold中要求的年龄。</p><h3 id="一个完整的GC流程是怎样的？"><a href="#一个完整的GC流程是怎样的？" class="headerlink" title="一个完整的GC流程是怎样的？"></a>一个完整的GC流程是怎样的？</h3><ul><li>非G1版本</li></ul><p>一般是minor GC(一般是新生代空间不足时发生) -&gt; full GC（当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者方法区没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。并发GC的触发条件就不太一样，以CMS GC为例，它主要是定时去检查old gen的使用量，当使用量超过了触发比例就会启动一次CMS GC，对old gen做并发收集。</p><ul><li>G1版本</li></ul><p>G1，一般是minor GC -&gt; mixed GC -&gt;full GC。</p><p>1）Young GC：在Eden空间耗尽时，Young GC针对Eden区和Survivor区进行回收。首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。<br>扫描根：根引用连同RSet记录的外部引用作为扫描存活对象的入口。<br>更新RSet：处理Dirty Card Queue中的Card，更新RSet。此阶段完成后，RS可以准确的反映老年代对所在的内存分段中对象的引用。<br>处理RSet：识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。<br>复制对象：对象树被遍历，Eden区Region中存活的对象会被复制到Survivor区中空的Region，Survivor区Region中存活的对象如果年龄未达阈值（G1默认是15），年龄会加1，达到阀值会被会被复制到Old区中空的Region。survivor空间不足时进入分配担保空间。<br>清除内存：原有的年轻代分区将被整体回收掉后放入空闲列表中，等待下次被使用。</p><p>2）Mixed GC：当整个堆内存（包括老年代和新生代）被占满一定大小的时候（默认是45%，可以通过-XX:InitiatingHeapOccupancyPercent进行设置），Mixed GC（混合回收）就会被启动。具体检测堆内存使用情况的时机是年轻代回收之后或者Houmongous对象分配之后。Mixed GC主要可以分为两个阶段</p><p>a. 全局并发标记（global concurrent marking）<br>包含以下几个阶段：<br>初始标记（initial mark，STW）：在此阶段对GC Root对象进行标记，初始标记阶段共用了Young GC的暂停，这是因为他们可以复用Root Scan操作。<br>根分区扫描（Root Region Scanning）：在初始标记暂停结束后，年轻代收集也完成的对象复制到 Survivor 的工作，应用线程开始活跃起来。此时为了保证标记算法的正确性，所有新复制到 Survivor 分区的对象，都需要被扫描并标记成根。根分区扫描必须在下一次年轻代垃圾收集启动前完成（并发标记的过程中，可能会被若干次年轻代垃圾收集打断），因为每次 GC 会产生新的存活对象集合。<br>并发标记（Concurrent Marking）：在整个堆中查找根可达（存活的）对象，收集各个Region的存活对象信息，过程中还会扫描上文中提到的SATB write barrier所记录下的引用。<br>重新标记（Remark，STW）：标记那些在并发标记阶段发生变化的对象，将被回收。<br>清理垃圾（Cleanup，部分STW）：在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，为混合收集周期识别回收收益高（基于释放空间和暂停目标）的老年代分区集合。识别所有空闲分区，即发现无存活对象的分区。该分区可在清除阶段直接回收，无需等待下次收集周期。</p><p>b. 拷贝存活对象（Evacuation）<br>将Region里的活对象拷贝到空Region里去（并行拷贝），然后回收原本的Region的空间。</p><p>为了满足停顿预测模型即暂停时间，G1 可能不能一口气将所有的Region都收集掉，因此 G1 可能会产生连续多次的混合收集与应用线程交替执行，每次 STW 的混合收集与年轻代收集过程相类似。由于老年代中的内存分段默认分8次（可以通过-XX:G1MixedGCCountTarget设置）回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，-XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。<br>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。G1 GC 回收了足够的旧区域后（经过多次混合垃圾回收），G1 将恢复执行年轻代垃圾回收，直到下一个标记周期完成。</p><p>3）Full GC<br>转移失败（Evacuation Failure）是指当 G1 无法在堆空间中申请新的分区时，G1 便会触发担保机制，执行一次 STW 式的、单线程的 Full GC。Full GC 会对整堆做标记清除和压缩，最后将只包含纯粹的存活对象。参数 -XX:G1ReservePercent（默认10%）可以保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，更大也无意义。<br>以下场景将触发Full GC：<br>从年轻代分区拷贝存活对象时，无法找到可用的空闲分区<br>从老年代分区转移存活对象时，无法找到可用的空闲分区<br>分配巨型对象时在老年代无法找到足够的连续分区<br>G1的Full GC算法就是单线程执行的 Serial Old GC，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免Full GC。</p><p><strong>G1活动汇总</strong></p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/G1%E6%B4%BB%E5%8A%A8%E6%B1%87%E6%80%BB.png" alt="G1活动汇总"></p><p>年轻代收集和混合收集周期，是G1回收空间的主要活动。当应用运行开始时，堆内存可用空间还比较大，只会在年轻代满时，触发年轻代收集；随着老年代内存增长，当到达IHOP阔值-XX：InitiatingHeapOccupancyPercent时，G1开始着手准备收集老年代空间。<br>首先经历并发标记周期，识别出高收益的老年代分区，前文已述。但随后G1并不会马上开始一次混合收集，而是让应用线程先运行一段时间，等待触发一次年轻代收集(Young Collection Following Concurrent Marking Cycle)，在这次STW中，G1将整理混合收集周期。接看再次让应用线程运行，当接下来的几次年轻代收集时，将会有老年代分区加入到CSet中，即触发混合收集，这些连续多次的混合收集称为混合收集周期(Mxed Colection Cycle)。G1会计算每次加入到CSet中的分区数量、混合收集进行次数，并且确定是否结束混合收集周期。</p><p>参考：<br><a href="https://blog.csdn.net/coderlius/article/details/79272773">详解 JVM Garbage First(G1) 垃圾收集器</a><br><a href="https://juejin.cn/post/7025212933428740110">看完这篇G1垃圾收集器的总结就足以吊打面试官了</a></p><h2 id="简述一下类加载过程，重点说明一下双亲委派模型，怎么破坏双亲委派模型？"><a href="#简述一下类加载过程，重点说明一下双亲委派模型，怎么破坏双亲委派模型？" class="headerlink" title="简述一下类加载过程，重点说明一下双亲委派模型，怎么破坏双亲委派模型？"></a>简述一下类加载过程，重点说明一下双亲委派模型，怎么破坏双亲委派模型？</h2><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>《规范》中没有规定加载的时机，但是规定了必须立即对类进行初始化的情况（而加载、验证、准备自然需要在此之前开始）：</p><ul><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时（·使用new关键字实例化对象的时候。·读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。·调用一个类型的静态方法的时候。）</li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候</li><li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</li><li>当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</li><li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。<br>注意：<br>通过子类引用父类的静态字段，不会导致子类初始化<br>通过数组定义来引用类，不会触发此类的初始化<br>常量（final static）在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li></ul><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类加载"></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</p><ul><li>加载</li></ul><p>“加载”（Loading）阶段是整个“类加载”（ClassLoading）过程中的一个阶段，在加载阶段，Java虚拟机需要完成以下三件事情：1）通过一个类的全限定名来获取定义此类的二进制字节流。2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。3）在内存（堆）中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。<br>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，</p><ul><li>验证</li></ul><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><ul><li>准备</li></ul><p>正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。final static修饰的变量在此阶段会分配空间并赋初始值，如果没有final修饰则只会分配空间并赋零值（例如boolean的零值位false），在初始化阶段再赋初始值。</p><ul><li>解析</li></ul><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，<br>符号引用（SymbolicReferences）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<br>直接引用（DirectReferences）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</p><ul><li>初始化</li></ul><p>变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：初始化阶段就是执行类构造器<clinit>()方法的过程。<br><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。</clinit></clinit></p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>ClassLoader相当于类的命名空间，起到了类隔离的作用。位于同一个 ClassLoader 里面的类名是唯一的，不同的 ClassLoader可以持有同名的类。ClassLoader 是类名称的容器，是类的沙箱。<br>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。<br>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/%E7%B1%BB%E9%9A%94%E7%A6%BB.png" alt="类隔离"></p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。<br>站在Java开发人员的角度来看，类加载器就应当划分得更细致一些，自JDK1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构，绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载：</p><ul><li>启动类加载器（BootstrapClassLoader）：这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</JAVA_HOME></li><li>扩展类加载器（ExtensionClassLoader）：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展JavaSE的功能。</JAVA_HOME></li><li>应用程序类加载器（ApplicationClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。当我们的main方法执行的时候，这第一个用户类的加载器就是AppClassLoader。</li></ul><p>JDK9之前的Java应用都是由这三种类加载器互相配合来完成加载的，如果用户认为有必要，还可以加入自定义的类加载器来进行拓展，典型的如增加除了磁盘位置之外的Class文件来源，或者通过类加载器实现类的隔离、重载等功能。这些类加载器之间的协作关系“通常”会如下图</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt="双亲委派"></p><p>以上各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（ParentsDelegationModel）”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p><p>类加载器的双亲委派模型在JDK1.2时期被引入，并被广泛应用于此后几乎所有的Java程序中，但它并不是一个具有强制性约束力的模型，而是Java设计者们推荐给开发者的一种类加载器实现的最佳实践。<br>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。<br>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。每个Class对象的内部都有一个classLoader字段来标识自己是由哪个ClassLoader加载的。ClassLoader就像一个容器，里面装了很多已经加载的Class对象。<br>双亲委派模型对于保证Java程序的稳定运作极为重要，但它的实现却异常简单，用以实现双亲委派的代码只有短短十余行，全部集中在java.lang.ClassLoader的loadClass()方法之中，</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/loadClass.png" alt="loadClass"></p><p>先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的loadClass()方法，若父加载器为null则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。</p><h3 id="ClassLoader传递性"><a href="#ClassLoader传递性" class="headerlink" title="ClassLoader传递性"></a>ClassLoader传递性</h3><p>程序在运行过程中，遇到了一个未知的类，它会选择哪个ClassLoader来加载它呢？虚拟机的策略是使用调用者Class对象的ClassLoader来加载当前未知的类。何为调用者Class对象？就是在遇到这个未知的类时，虚拟机肯定正在运行一个方法调用（静态方法或者实例方法），这个方法挂在哪个类上面，那这个类就是调用者Class对象。前面我们提到每个Class对象里面都有一个classLoader属性记录了当前的类是由谁来加载的。因为ClassLoader的传递性，如果没有使用其他自定义类加载器，所有延迟加载的类都会由初始调用main方法的这个ClassLoader全全负责，它就是AppClassLoader。</p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>继承ClassLoader类，根据需要重写loadClass、findClass、有参构造方法。<br>一般重写findClass、有参构造方法即可，指定好父加载器，然后先委派父加载器加载，无法加载则转到findClass，一般不用重写loadClass。<br>特殊情况也可以重写loadClass，可能会破坏双亲委派。</p><h3 id="如何破坏双亲委派"><a href="#如何破坏双亲委派" class="headerlink" title="如何破坏双亲委派"></a>如何破坏双亲委派</h3><p>重写loadClass方法即可，不委托给父类加载。</p><h3 id="类加载器的案例"><a href="#类加载器的案例" class="headerlink" title="类加载器的案例"></a>类加载器的案例</h3><ul><li>双亲委派案例</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 自定义了一个类加载器继承ClassLoader，查看ClassLoader可知parent为getSystemClassLoader()，即application类加载器</span><br><span class="hljs-comment">// 这里的findClass()直接用的父类的方法，但是实际调用会报错的</span><br><span class="hljs-comment">// 我们这里直接加载jdk自带的类，所以会进行双亲委派，实际并不会调用ThreeParentClassLoader4Jdk的findClass()方法</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreeParentClassLoader4Jdk</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Class</span>&lt;?&gt; findClass(<span class="hljs-type">String</span> name) <span class="hljs-keyword">throws</span> <span class="hljs-type">ClassNotFoundException</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.findClass(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 测试双亲委派</span><br>import java.sql.JDBCType;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ParentLoadTest</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        load1();<br>        load2();<br>        load3();<br>    &#125;<br>    <span class="hljs-comment">// 直接查看JDBCType的类加载器，然后用ThreeParentClassLoader4Jdk加载并查看实际类加载器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">load1</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;---load1---&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.println(JDBCType.<span class="hljs-keyword">class</span>.getClassLoader());<br>        ThreeParentClassLoader4Jdk threeParentClassLoader4Jdk = <span class="hljs-keyword">new</span> ThreeParentClassLoader4Jdk();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; aClass = threeParentClassLoader4Jdk.loadClass(<span class="hljs-string">&quot;java.sql.JDBCType&quot;</span>);<br>            System.<span class="hljs-keyword">out</span>.println(aClass.getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">load2</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;---load2---&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.println(String.<span class="hljs-keyword">class</span>.getClassLoader());<br>        ThreeParentClassLoader4Jdk threeParentClassLoader4Jdk = <span class="hljs-keyword">new</span> ThreeParentClassLoader4Jdk();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; aClass = threeParentClassLoader4Jdk.loadClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>            System.<span class="hljs-keyword">out</span>.println(aClass.getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">load3</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;---load3---&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.println(TestA.<span class="hljs-keyword">class</span>.getClassLoader());<br>        ThreeParentClassLoader4Jdk threeParentClassLoader4Jdk = <span class="hljs-keyword">new</span> ThreeParentClassLoader4Jdk();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; aClass = threeParentClassLoader4Jdk.loadClass(<span class="hljs-string">&quot;TestA&quot;</span>);<br>            System.<span class="hljs-keyword">out</span>.println(aClass.getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下，可以发现不同层级的类都进行了双亲委派：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs llvm">---<span class="hljs-keyword">load</span><span class="hljs-number">1</span>---<br>jdk.<span class="hljs-keyword">internal</span>.loader.ClassLoaders$PlatformClassLoader<span class="hljs-title">@2812</span>cbfa<br>jdk.<span class="hljs-keyword">internal</span>.loader.ClassLoaders$PlatformClassLoader<span class="hljs-title">@2812</span>cbfa<br>---<span class="hljs-keyword">load</span><span class="hljs-number">2</span>---<br><span class="hljs-keyword">null</span><br><span class="hljs-keyword">null</span><br>---<span class="hljs-keyword">load</span><span class="hljs-number">3</span>---<br>jdk.<span class="hljs-keyword">internal</span>.loader.ClassLoaders$AppClassLoader<span class="hljs-title">@2437</span><span class="hljs-keyword">c</span><span class="hljs-number">6</span>dc<br>jdk.<span class="hljs-keyword">internal</span>.loader.ClassLoaders$AppClassLoader<span class="hljs-title">@2437</span><span class="hljs-keyword">c</span><span class="hljs-number">6</span>dc<br></code></pre></td></tr></table></figure><ul><li>类加载隔离案例</li></ul><p>&#x2F;&#x2F;V1版本TestA</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package clt;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestA</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello,v1&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;V2版本TestA</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package clt;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestA</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello,v2&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;桌面类加载器，直接指定父类为AppClassLoader的父加载器，重写了findClass()，所以不会加载类路径里的TestA，因为前面的父加载器找不到，所以只能从桌面找TestA</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> clt;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> DesktopClassLoader <span class="hljs-keyword">extends</span> ClassLoader&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; classPathMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> DesktopClassLoader() &#123;<br>        <span class="hljs-keyword">super</span>(ClassLoader.getSystemClassLoader().getParent());<br>        classPathMap.put(<span class="hljs-string">&quot;clt.TestA&quot;</span>, <span class="hljs-string">&quot;C:\\Users\\liuwe\\Desktop\\clt\\TestA.class&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">// 重写了 findClass 方法</span><br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">Class</span>&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        String <span class="hljs-keyword">classPath</span> = classPathMap.get(name);<br>        <span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(<span class="hljs-keyword">classPath</span>);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">file</span>.exists()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException();<br>        &#125;<br>        <span class="hljs-keyword">byte</span>[] classBytes = getClassData(<span class="hljs-keyword">file</span>);<br>        <span class="hljs-keyword">if</span> (classBytes == <span class="hljs-keyword">null</span> || classBytes.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException();<br>        &#125;<br>        <span class="hljs-keyword">return</span> defineClass(classBytes, <span class="hljs-number">0</span>, classBytes.length);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] getClassData(<span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span>) &#123;<br>        <span class="hljs-keyword">try</span> (InputStream ins = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">file</span>); ByteArrayOutputStream baos = <span class="hljs-keyword">new</span><br>                ByteArrayOutputStream()) &#123;<br>            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4096</span>];<br>            <span class="hljs-keyword">int</span> bytesNumRead = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> ((bytesNumRead = ins.<span class="hljs-keyword">read</span>(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>                baos.<span class="hljs-keyword">write</span>(buffer, <span class="hljs-number">0</span>, bytesNumRead);<br>            &#125;<br>            <span class="hljs-keyword">return</span> baos.toByteArray();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[] &#123;&#125;;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;开始测试类加载器进行类隔离加载</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">package clt;<br><br>import java.lang.reflect.InvocationTargetException;<br>import java.lang.reflect.Method;<br><br>public <span class="hljs-keyword">class</span> IsolationClassTest &#123;<br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        TestA obj1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TestA()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;---TestA,v1---&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;类加载器为&quot;</span> + obj1.get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">ClassLoader()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;类名为&quot;</span> + obj1.get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">Name()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;hello执行开始&quot;</span>);<br>        obj1.hello<span class="hljs-literal">()</span>;<br><br>        DesktopClassLoader desktopClassLoader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DesktopClassLoader()</span>;<br>        Object obj2;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; aClass = desktopClassLoader.load<span class="hljs-constructor">Class(<span class="hljs-string">&quot;clt.TestA&quot;</span>)</span>;<br>            obj2 = aClass.get<span class="hljs-constructor">DeclaredConstructor()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>            Method hello = aClass.get<span class="hljs-constructor">Method(<span class="hljs-string">&quot;hello&quot;</span>)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;---TestA,v2---&quot;</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;类加载器为&quot;</span> + obj2.get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">ClassLoader()</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;类名为&quot;</span> + obj2.get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">Name()</span>);<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;hello执行开始&quot;</span>);<br>            hello.invoke(obj2);<br>        &#125; catch (ClassNotFoundException e) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-params">e</span>)</span>;<br>        &#125; catch (InstantiationException e) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-params">e</span>)</span>;<br>        &#125; catch (IllegalAccessException e) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-params">e</span>)</span>;<br>        &#125; catch (InvocationTargetException e) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-params">e</span>)</span>;<br>        &#125; catch (NoSuchMethodException e) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-params">e</span>)</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;结果输出如下，可以看到同名类被不同类加载器加载，且相同方法表现不同</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">-<span class="hljs-attr">--TestA</span>,v1---<br>类加载器为jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.loader</span>.ClassLoaders<span class="hljs-variable">$AppClassLoader</span>@<span class="hljs-number">2437</span>c6dc<br>类名为clt<span class="hljs-selector-class">.TestA</span><br>hello执行开始<br>hello,v1<br>-<span class="hljs-attr">--TestA</span>,v2---<br>类加载器为clt.DesktopClassLoader@<span class="hljs-number">668</span>bc3d5<br>类名为clt<span class="hljs-selector-class">.TestA</span><br>hello执行开始<br>hello,v2<br></code></pre></td></tr></table></figure><ul><li>类加载器调用传递</li></ul><p>&#x2F;&#x2F;v1版本的TestB和C</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package clt;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestB</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello B, v1&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;TestB 的类加载器为&quot;</span> + <span class="hljs-keyword">this</span>.getClass().getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package clt;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestC</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello C, v1&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;TestC 的类加载器为&quot;</span> + <span class="hljs-keyword">this</span>.getClass().getClassLoader());<br>        TestB testB = <span class="hljs-keyword">new</span> TestB();<br>        testB.hello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;v1版本的TestB和C</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package clt;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestB</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello B, v2&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;TestB 的类加载器为&quot;</span> + <span class="hljs-keyword">this</span>.getClass().getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>package clt;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestC</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello C, v2&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;TestC 的类加载器为&quot;</span> + <span class="hljs-keyword">this</span>.getClass().getClassLoader());<br>        TestB testB = <span class="hljs-keyword">new</span> TestB();<br>        testB.hello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;DesktopClassLoader增加一些配置项</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-type">DesktopClassLoader</span>() &#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-type">ClassLoader</span>.getSystemClassLoader().getParent());<br>        classPathMap.put(<span class="hljs-string">&quot;clt.TestA&quot;</span>, <span class="hljs-string">&quot;C:<span class="hljs-subst">\\</span>Users<span class="hljs-subst">\\</span>liuwe<span class="hljs-subst">\\</span>Desktop<span class="hljs-subst">\\</span>clt<span class="hljs-subst">\\</span>TestA.class&quot;</span>);<br>        classPathMap.put(<span class="hljs-string">&quot;clt.TestB&quot;</span>, <span class="hljs-string">&quot;C:<span class="hljs-subst">\\</span>Users<span class="hljs-subst">\\</span>liuwe<span class="hljs-subst">\\</span>Desktop<span class="hljs-subst">\\</span>clt<span class="hljs-subst">\\</span>TestB.class&quot;</span>);<br>        classPathMap.put(<span class="hljs-string">&quot;clt.TestC&quot;</span>, <span class="hljs-string">&quot;C:<span class="hljs-subst">\\</span>Users<span class="hljs-subst">\\</span>liuwe<span class="hljs-subst">\\</span>Desktop<span class="hljs-subst">\\</span>clt<span class="hljs-subst">\\</span>TestC.class&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;验证类加载的调用传递</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> clt;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoaderDeliver</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        System.out.println(<span class="hljs-string">&quot;由app类加载器加载的TestC&quot;</span>);<br>        TestC testC = <span class="hljs-keyword">new</span> <span class="hljs-type">TestC</span>();<br>        testC.hello();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;由DesktopClassLoader类加载器加载的TestC&quot;</span>);<br>            DesktopClassLoader desktopClassLoader = <span class="hljs-keyword">new</span> <span class="hljs-type">DesktopClassLoader</span>();<br>            Class&lt;?&gt; aClass = desktopClassLoader.loadClass(<span class="hljs-string">&quot;clt.TestC&quot;</span>);<br>            Object obj = aClass.getDeclaredConstructor().<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>();<br>            Method hello = aClass.getDeclaredMethod(<span class="hljs-string">&quot;hello&quot;</span>);<br>            hello.invoke(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;可以看到由DesktopClassLoader加载的V2版本TestC后续又加载了V2的TestB，验证了类加载器的传递</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">由app类加载器加载的TestC<br>hello C, v1<br>TestC 的类加载器为jdk.internal.loader.ClassLoaders<span class="hljs-number">$AppClassLoader</span><span class="hljs-subst">@2437</span>c6dc<br>hello B, v1<br>TestB 的类加载器为jdk.internal.loader.ClassLoaders<span class="hljs-number">$AppClassLoader</span><span class="hljs-subst">@2437</span>c6dc<br>由DesktopClassLoader类加载器加载的TestC<br>hello C, v2<br>TestC 的类加载器为<span class="hljs-keyword">clt</span>.DesktopClassLoader<span class="hljs-subst">@668</span>bc3d5<br>hello B, v2<br>TestB 的类加载器为<span class="hljs-keyword">clt</span>.DesktopClassLoader<span class="hljs-subst">@668</span>bc3d5<br></code></pre></td></tr></table></figure><ul><li>线程池类加载器隔离<br>&#x2F;&#x2F;新建一个类加载器，可以指定父加载器<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> clt;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoader4ThreadTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span></span>&#123;<br>    public <span class="hljs-type">ClassLoader4ThreadTest</span>(<span class="hljs-type">ClassLoader</span> parent) &#123;<br>        <span class="hljs-keyword">super</span>(parent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>&#x2F;&#x2F;另外创建两个线程测试ContextClassLoader在线程中传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> clt;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContestClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 设置ContextClassLoader为aDesktopClassLoader类加载器</span><br>        Thread.currentThread().setContextClassLoader(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DesktopClassLoader</span>());<br>        <span class="hljs-type">ClassLoaderThread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoaderThread</span>();<br>        thread1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            System.out.println(<span class="hljs-string">&quot;---暂停一会---&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        <span class="hljs-comment">// 设置ContextClassLoader为app类加载器</span><br>        Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader());<br>        <span class="hljs-type">ClassLoaderThread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoaderThread</span>();<br>        thread2.start();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ClassLoader4ThreadTest classLoader4ThreadTest;<br>            classLoader4ThreadTest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoader4ThreadTest</span>(Thread.currentThread().getContextClassLoader());<br>            Class&lt;?&gt; aClass = classLoader4ThreadTest.loadClass(<span class="hljs-string">&quot;clt.TestC&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> aClass.getDeclaredConstructor().newInstance();<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> aClass.getDeclaredMethod(<span class="hljs-string">&quot;hello&quot;</span>);<br>            hello.invoke(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;结果运行如下，分别在不同的ContextClassLoader情况创建两个线程，ContextClassLoader分别传到子线程中用于设置父类加载器，导致分别从不同的地方加载类，可以用于不同的业务进行类加载隔离，这里同样展示了类加载的调用传递</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">hello C, v2<br>TestC 的类加载器为<span class="hljs-keyword">clt</span>.DesktopClassLoader<span class="hljs-subst">@7</span>a79be86<br>hello B, v2<br>TestB 的类加载器为<span class="hljs-keyword">clt</span>.DesktopClassLoader<span class="hljs-subst">@7</span>a79be86<br>---暂停一会---<br>hello C, v1<br>TestC 的类加载器为jdk.internal.loader.ClassLoaders<span class="hljs-number">$AppClassLoader</span><span class="hljs-subst">@2437</span>c6dc<br>hello B, v1<br>TestB 的类加载器为jdk.internal.loader.ClassLoaders<span class="hljs-number">$AppClassLoader</span><span class="hljs-subst">@2437</span>c6dc<br></code></pre></td></tr></table></figure><h3 id="tomcat破坏双亲委派"><a href="#tomcat破坏双亲委派" class="headerlink" title="tomcat破坏双亲委派"></a>tomcat破坏双亲委派</h3><p>tomcat重写ClassLoader的两个方法</p><ul><li>loadClass工作流程</li></ul><p>先在本地Cache查找该类是否已加载过，即Tomcat的类加载器是否已经加载过这个类。若Tomcat类加载器尚未加载过该类，再看看系统类加载器（app类加载器）是否加载过。若都没有，就让ExtClassLoader加载，为防止Web应用自己的类覆盖JRE的核心类。<br>因为Tomcat需打破双亲委托，假如Web应用里自定义了一个叫Object的类，若先加载该Object类，就会覆盖JRE的Object类，所以Tomcat类加载器优先尝试用ExtClassLoader去加载，因为ExtClassLoader会委托给BootstrapClassLoader去加载，BootstrapClassLoader发现自己已经加载了Object类，直接返回给Tomcat的类加载器，这样Tomcat的类加载器就不会去加载Web应用下的Object类了，避免覆盖JRE核心类。<br>若ExtClassLoader加载失败，即JRE无此类，则在本地Web应用目录下查找并加载，若本地目录下无此类，说明不是Web应用自己定义的类，那么由系统类加载器去加载。这里请你注意，Web应用是通过Class.forName调用交给系统类加载器的，因为Class.forName的默认加载器就是系统类加载器。<br>若上述加载过程都失败，抛ClassNotFound。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public Class&lt;?&gt; load<span class="hljs-constructor">Class(String <span class="hljs-params">name</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">resolve</span>)</span> throws ClassNotFoundException &#123;<br> <br>    synchronized (get<span class="hljs-constructor">ClassLoadingLock(<span class="hljs-params">name</span>)</span>) &#123;<br> <br>        Class&lt;?&gt; clazz = null;<br> <br>        <span class="hljs-comment">//1. 先在本地 cache 查找该类是否已经加载过</span><br>        clazz = find<span class="hljs-constructor">LoadedClass0(<span class="hljs-params">name</span>)</span>;<br>        <span class="hljs-keyword">if</span> (clazz != null) &#123;<br>            <span class="hljs-keyword">if</span> (resolve)<br>                resolve<span class="hljs-constructor">Class(<span class="hljs-params">clazz</span>)</span>;<br>            return clazz;<br>        &#125;<br> <br>        <span class="hljs-comment">//2. 从系统类加载器的 cache 中查找是否加载过</span><br>        clazz = find<span class="hljs-constructor">LoadedClass(<span class="hljs-params">name</span>)</span>;<br>        <span class="hljs-keyword">if</span> (clazz != null) &#123;<br>            <span class="hljs-keyword">if</span> (resolve)<br>                resolve<span class="hljs-constructor">Class(<span class="hljs-params">clazz</span>)</span>;<br>            return clazz;<br>        &#125;<br> <br>        <span class="hljs-comment">// 3. 尝试用 ExtClassLoader 类加载器类加载</span><br>        ClassLoader javaseLoader = get<span class="hljs-constructor">JavaseClassLoader()</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            clazz = javaseLoader.load<span class="hljs-constructor">Class(<span class="hljs-params">name</span>)</span>;<br>            <span class="hljs-keyword">if</span> (clazz != null) &#123;<br>                <span class="hljs-keyword">if</span> (resolve)<br>                    resolve<span class="hljs-constructor">Class(<span class="hljs-params">clazz</span>)</span>;<br>                return clazz;<br>            &#125;<br>        &#125; catch (ClassNotFoundException e) &#123;<br>            <span class="hljs-comment">// Ignore</span><br>        &#125;<br> <br>        <span class="hljs-comment">// 4. 调用findClass查找</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            clazz = find<span class="hljs-constructor">Class(<span class="hljs-params">name</span>)</span>;<br>            <span class="hljs-keyword">if</span> (clazz != null) &#123;<br>                <span class="hljs-keyword">if</span> (resolve)<br>                    resolve<span class="hljs-constructor">Class(<span class="hljs-params">clazz</span>)</span>;<br>                return clazz;<br>            &#125;<br>        &#125; catch (ClassNotFoundException e) &#123;<br>            <span class="hljs-comment">// Ignore</span><br>        &#125;<br> <br>        <span class="hljs-comment">// 5. 尝试用系统类加载器 (也就是 AppClassLoader) 来加载</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                clazz = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-params">name</span>, <span class="hljs-params">false</span>, <span class="hljs-params">parent</span>)</span>;<br>                <span class="hljs-keyword">if</span> (clazz != null) &#123;<br>                    <span class="hljs-keyword">if</span> (resolve)<br>                        resolve<span class="hljs-constructor">Class(<span class="hljs-params">clazz</span>)</span>;<br>                    return clazz;<br>                &#125;<br>            &#125; catch (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// Ignore</span><br>            &#125;<br>       &#125;<br>    <br>    <span class="hljs-comment">//6. 上述过程都加载失败，抛出异常</span><br>    throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassNotFoundException(<span class="hljs-params">name</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>findClass工作流程：</li></ul><p>先在Web应用本地目录下查找要加载的类<br>若未找到，调用父加载器的findClass查找<br>若父加载器也没找到这个类，抛ClassNotFound</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">Class</span>&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <br>    <span class="hljs-keyword">Class</span>&lt;?&gt; clazz = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1. 先在 Web 应用目录下查找类 </span><br>            clazz = findClassInternal(name);<br>    &#125;  <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>           <span class="hljs-keyword">throw</span> e;<br>       &#125;<br>    <br>    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//2. 如果在本地目录没有找到，交给父加载器去查找</span><br>            clazz = <span class="hljs-keyword">super</span>.findClass(name);<br>    &#125;  <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>           <span class="hljs-keyword">throw</span> e;<br>       &#125;<br>    <br>    <span class="hljs-comment">//3. 如果父类也没找到，抛出 ClassNotFoundException</span><br>    <span class="hljs-keyword">if</span> (clazz == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);<br>     &#125;<br> <br>    <span class="hljs-keyword">return</span> clazz;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总体是先上部分类加载器加载（ExtClassLoader），再下部分类加载器加载（findClass），最终用app类加载器进行中间部分类加载器加载（通过调用Class.forName）。</p><p><img src="/2023/05/23/%E5%85%AB%E8%82%A1%E6%96%87-jvm/tomcat%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt="tomcat破坏双亲委派"></p><p>参考：<br>《深入理解java虚拟机》<br><a href="https://zhuanlan.zhihu.com/p/51374915https://zhuanlan.zhihu.com/p/51374915">老大难的 Java ClassLoader 再不理解就老了</a><br><a href="https://blog.csdn.net/Miiiiiiiiiii/article/details/119324305">【Tomcat框架】Tomcat如何打破双亲委派机制？</a><br><a href="https://mp.weixin.qq.com/s/9mojzm8URjNRBg3r8BamdQ">《对线面试官》双亲委派机制</a></p><h2 id="说说你了解的jvm参数和其作用？"><a href="#说说你了解的jvm参数和其作用？" class="headerlink" title="说说你了解的jvm参数和其作用？"></a>说说你了解的jvm参数和其作用？</h2><h3 id="经典垃圾收集器参数"><a href="#经典垃圾收集器参数" class="headerlink" title="经典垃圾收集器参数"></a>经典垃圾收集器参数</h3><p>-Xms:初始大小内存，默认为物理内存的1&#x2F;64，等价于-XX:InitialHeapSize</p><p>-Xmx:最大分配内存，默认为物理内存的1&#x2F;4，等价于-XX:MaxHeapSize</p><p>-Xss:设置单个线程栈的大小，一般默认为512k~1024k，等价于-XX:ThreadStackSize<br>当值等于0的时候，代表使用得是默认大小</p><p>-Xmn：设置年轻代大小</p><p>-XX:MetaspaceSize：设置元空间大小（元空间与永久代最大的区别为：元空间并不在虚拟机中，而使用的是本地内存，因此，元空间只收本地内存的限制），触发元空间回收的阈值<br>手动设置：-XX：MetaspaceSize&#x3D;1024m</p><p>-XX:MaxMetaspaceSize: 设置元空间的最大内存，元空间可分配的最大值</p><p>-XX:SurvivorRatio：设置新生代中 eden 和 S0&#x2F;S1 空间比例，默认 -XX:SurvivorRatio&#x3D;8，Eden : S0 : S1 &#x3D; 8 : 1 : 1；​-XX:SurvivorRatio&#x3D;4，Eden : S0 : S1 &#x3D; 4 : 1 : 1</p><p>-XX:NewRatio：配置年轻代和老年代在堆结构的占比，默认 -XX:NewRatio&#x3D;2 新生代占1，老年代占2，年轻代占整个堆的 1&#x2F;3；​-XX:NewRatio&#x3D;4 新生代占1，老年代占4，年轻代占整个堆的 1&#x2F;5。-Xmn 优先级大于-XX:NewRatio</p><p>-XX:MaxTenuringThreshold：设置垃圾最大年龄。默认是15。-XX:MaxTenuringThreshold&#x3D;0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。如果此值设置为一个较大的值，则年前对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代被回收的概率！</p><p>-XX:CMSInitiatingOccupancyFraction：CMS垃圾收集器触发CMS垃圾回收的老年代阈值。</p><h3 id="G1参数"><a href="#G1参数" class="headerlink" title="G1参数"></a>G1参数</h3><p><strong>暂停时间</strong>：用-XX:MaxGCPauseMillis来指定，默认值200ms。这是一个软性目标，G1会尽量达成，如果达不成，会逐渐做自我调整。对于Young GC来说，会逐渐减少Eden区个数，减少Eden空间那么Young GC的处理时间就会相应减少；对于Mixed GC，G1会调整每次Choose Cset的比例，默认最大值是10%，当然每次选择的Cset少了，所要经历的Mixed GC的次数会相应增加。同时减少Eden的总空间时，就会更加频繁的触发Young GC，也就是会加快Mixed GC的执行频率，因为Mixed GC是由Young GC触发的，或者说借机同时执行的。频繁GC会对对应用的吞吐量造成影响，每次Mixed GC回收时间太短，回收的垃圾量太少，可能最后GC的垃圾清理速度赶不上应用产生的速度，那么可能会造成串行的Full GC，这是要极力避免的。所以暂停时间肯定不是设置的越小越好，当然也不能设置的偏大，转而指望G1自己会尽快的处理，这样可能会导致一次全部并发标记后触发的Mixed GC次数变少，但每次的时间变长，STW时间变长，对应用的影响更加明显。</p><p><strong>Region大小</strong>：用-XX:G1HeapRegionSize来指定，若未指定则默认最多生成2048块，每块的大小需要为2的幂次方，如1,2,4,8,16,32，最大值为32M。Region的大小主要是关系到Humongous Object的判定，当一个对象超过Region大小的一半时，则为巨型对象，那么其会至少独占一个Region，如果一个放不下，会占用连续的多个Region。当一个Humongous Region放入了一个巨型对象，可能还有不少剩余空间，但是不能用于存放其他对象，这些空间就浪费了。所以如果应用里有很多大小差不多的巨型对象，可以适当调整Region的大小，尽量让他们以普通对象的形式分配，合理利用Region空间。</p><p><strong>新生代比例</strong>：新生代比例有两个数值指定，下限：-XX:G1NewSizePercent，默认值5%，上限：-XX:G1MaxNewSizePercent，默认值60%。G1会根据实际的GC情况(主要是暂停时间)来动态的调整新生代的大小，主要是Eden Region的个数。最好是Eden的空间大一点，毕竟Young GC的频率更大，大的Eden空间能够降低Young GC的发生次数。但是Mixed GC是伴随着Young GC一起的，如果暂停时间短，那么需要更加频繁的Young GC，同时也需要平衡好Mixed GC中新生代和老年代的Region，因为新生代的所有Region都会被回收，如果Eden很大，那么留给老年代回收空间就不多了，最后可能会导致Full GC。避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。</p><p><strong>并发GC线程数</strong>：通过 -XX:ConcGCThreads来指定，默认是-XX:ParallelGCThreads&#x2F;4，也就是在非STW期间的GC工作线程数，当然其他的线程很多工作在应用上。当并发周期时间过长时，可以尝试调大GC工作线程数，但是这也意味着此期间应用所占的线程数减少，会对吞吐量有一定影响。<br>并行GC线程数：通过 -XX:ParallelGCThreads来指定，也就是在STW阶段工作的GC线程数，其值遵循以下原则：<br>① 如果用户显示指定了ParallelGCThreads，则使用用户指定的值。<br>② 否则，需要根据实际的CPU所能够支持的线程数来计算ParallelGCThreads的值，计算方法见步骤③和步骤④。<br>③ 如果物理CPU所能够支持线程数小于8，则ParallelGCThreads的值为CPU所支持的线程数。这里的阀值为8，是因为JVM中调用nof_parallel_worker_threads接口所传入的switch_pt的值均为8。<br>④ 如果物理CPU所能够支持线程数大于8，则ParallelGCThreads的值为8加上一个调整值，调整值的计算方式为：物理CPU所支持的线程数减去8所得值的5&#x2F;8或者5&#x2F;16，JVM会根据实际的情况来选择具体是乘以5&#x2F;8还是5&#x2F;16。<br>比如，在64线程的x86 CPU上，如果用户未指定ParallelGCThreads的值，则默认的计算方式为：ParallelGCThreads &#x3D; 8 + (64 - 8) * (5&#x2F;8) &#x3D; 8 + 35 &#x3D; 43。</p><p><strong>触发全局并发标记的老年代使用占比</strong>：通过-XX:InitiatingHeapOccupancyPercent指定，默认值45%，也就是老年代占堆的比例超过45%。如果Mixed GC周期结束后老年代使用率还是超过45%,那么会再次触发全局并发标记过程，这样就会导致频繁的老年代GC，影响应用吞吐量。同时老年代空间不大，Mixed GC回收的空间肯定是偏少的。可以适当调高IHOP的值，当然如果此值太高，很容易导致年轻代晋升失败而出发Full GC，所以需要多次调整测试。</p><p><strong>被纳入Cset的Region的存活空间占比阈值</strong>：通过 -XX:G1MixedGCLiveThresholdPercent指定，不同版本默认值不同，有65%和85%。在全局并发标记阶段，如果一个Region的存活对象的空间占比低于此值，则会被纳入Cset。此值直接影响到Mixed GC选择回收的区域，当发现GC时间较长时，可以尝试调低此阈值，尽量优先选择回收垃圾占比高的Region，但此举也可能导致垃圾回收的不够彻底，最终触发Full GC。</p><p><strong>触发Mixed GC的堆垃圾占比</strong>：通过-XX:G1HeapWastePercent指定，默认值5%，也就是在全局标记结束后能够统计出所有Cset内可被回收的垃圾占整对的比例值，如果超过5%，那么就会触发之后的多轮Mixed GC，如果不超过，那么会在之后的某次Young GC中重新执行全局并发标记。可以尝试适当的调高此阈值，能够适当的降低Mixed GC的频率。</p><p><strong>每轮Mixed GC回收的Region最大比例</strong>：通过-XX:G1OldCSetRegionThresholdPercent指定，默认10%，也就是每轮Mixed GC附加的Cset的Region不超过全部Region的10%，最多10%，如果暂停时间短，那么可能会少于10%。一般这个值不需要额外调整。</p><p><strong>一个周期内触发Mixed GC最大次数</strong>：通过-XX:G1MixedGCCountTarget指定，默认值8。也就是在一次全局并发标记后，最多接着8此Mixed GC，也就是会把全局并发标记阶段生成的Cset里的Region拆分为最多8部分，然后在每轮Mixed GC里收集一部分。这个值要和上一个参数配合使用，8*10%&#x3D;80%，应该来说会大于每次标记阶段的Cset集合了。一般此参数也不需额外调整。</p><p><strong>G1为分配担保预留的空间比例</strong>：通过-XX:G1ReservePercent指定，默认10%。也就是老年代会预留10%的空间来给新生代的对象晋升，如果经常发生新生代晋升失败而导致Full GC，那么可以适当调高此阈值。但是调高此值同时也意味着降低了老年代的实际可用空间。</p><p><strong>晋升年龄阈值</strong>：通过-XX:MaxTenuringThreshold指定，默认值15。一般新生对象经过15次Young GC会晋升到老年代，巨型对象会直接分配在老年代，同时在Young GC时，如果相同age的对象占Survivors空间的比例超过 -XX:TargetSurvivorRatio的值(默认50%)，则会自动将此次晋升年龄阈值设置为此age的值，所有年龄超过此值的对象都会被晋升到老年代，此举可能会导致老年代需要不少空间应对此种晋升。一般这个值不需要额外调整。</p><p>参考：<br><a href="https://blog.csdn.net/qq_27529917/article/details/87072130">G1调优常用参数及其作用</a></p><h2 id="Java的四种引用有了解么？引用队列怎么使用？作用是什么？"><a href="#Java的四种引用有了解么？引用队列怎么使用？作用是什么？" class="headerlink" title="Java的四种引用有了解么？引用队列怎么使用？作用是什么？"></a>Java的四种引用有了解么？引用队列怎么使用？作用是什么？</h2><ul><li><p>强引用<br>普通赋值就是强引用</p></li><li><p>软引用<br>用WeakReference类实现，被软引用关联的对象，当系统要发生OOM异常时，会将软引用关联的对象列进回收范围之中进行第二次回收，如果这次回收后还没有足够资源才抛出OOM异常</p></li><li><p>弱引用<br>用WeakReference类实现，被弱引用关联的对象只能生存到下次垃圾回收发生为止，不管内存是否够用，只要发生垃圾回收就会收回只被弱引用关联的对象。</p></li><li><p>虚引用<br>用PhantomReference类实现，无法通过虚引用来获取一个对象实例，虚引用也不会对对象的生存实践构成影响。唯一作用是能在对象被收集器回收的时候收到一个系统通知。虚引用必须配合引用队列使用。</p></li><li><p>引用队列<br>当联合使用软引用、弱引用和引用队列时，系统在回收被引用的对象之后，将把它所回收对象对应的引用添加到关联的引用队列中，这相当于是一种通知机制，我们可以通过 ReferenceQueue 中的元素（引用）来知道哪些对象（被引用的对象）被回收掉了，通过这种方式，我们就可以在对象被回收掉之后，做一些我们自己想做的事情。<br>ReferenceQueue 提供了三种方法来弹出队头元素：<br>poll()：用于移除并返回该队列中的下一个引用对象，如果队列为空，则返回null<br>remove()：用于移除并返回该队列中的下一个引用对象，该方法会在队列返回可用引用对象之前一直阻塞<br>remove (long timeout)：用于移除并返回队列中的下一个引用对象。该方法会在队列返回可用引用对象之前一直阻塞，或者在超出指定超时后结束。如果超出指定超时，则返回null。如果指定超时为0，意味着将无限期地等待。</p></li></ul><p>引用队列案例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws InterruptedException &#123;<br>        <span class="hljs-keyword">SavePoint</span> <span class="hljs-keyword">savePoint</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">SavePoint</span>(&quot;Random&quot;); // 创建一个强引用<br>        ReferenceQueue&lt;<span class="hljs-keyword">SavePoint</span>&gt; savepointQ = <span class="hljs-built_in">new</span> ReferenceQueue&lt;<span class="hljs-keyword">SavePoint</span>&gt;();// 引用队列<br>        WeakReference&lt;<span class="hljs-keyword">SavePoint</span>&gt; savePointWRefernce = <span class="hljs-built_in">new</span> WeakReference&lt;<span class="hljs-keyword">SavePoint</span>&gt;(<span class="hljs-keyword">savePoint</span>, savepointQ);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;在队列中有任何弱引用吗? &quot; + (savepointQ.poll() != <span class="hljs-keyword">null</span>));<br>        <span class="hljs-keyword">savePoint</span> = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;现在调用GC...&quot;);<br>        Runtime.getRuntime().gc(); // 对象在这里会被清除掉 - finalize方法会被调用<br>        Reference&lt;? extends <span class="hljs-keyword">SavePoint</span>&gt; reCreatedSavePoint = savepointQ.remove();<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;在队列中存在任何弱引用吗 ? &quot; + (reCreatedSavePoint != <span class="hljs-keyword">null</span>));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;这个引用和原先的弱引是同一个对象吗 ? &quot; + (reCreatedSavePoint == savePointWRefernce));<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;堆中对象是： &quot; + reCreatedSavePoint.<span class="hljs-keyword">get</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso">在队列中有任何弱引用吗? <span class="hljs-literal">false</span><br>现在调用GC<span class="hljs-params">...</span><br>在队列中存在任何弱引用吗 ? <span class="hljs-literal">true</span><br>这个引用和原先的弱引是同一个对象吗 ? <span class="hljs-literal">true</span><br>堆中对象是： <span class="hljs-built_in">null</span><br></code></pre></td></tr></table></figure><p>正如上面输出结果所看到的那样，引用队列实际上只是持有着已经不再引用堆中的要被清除的对象的引用型对象。因此这个弱引用和内存中的对象没有任何关联。调用get会返回null。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/477314507">偏僻又热门，引用与引用队列</a><br><a href="https://blog.csdn.net/lverniu777fubiwei/article/details/53876211">引用队列（ReferenceQueue）浅析</a></p><h2 id="怎么打出一个线程的堆栈信息？如果内存过高怎么分析？如果cpu过高怎么定位？"><a href="#怎么打出一个线程的堆栈信息？如果内存过高怎么分析？如果cpu过高怎么定位？" class="headerlink" title="怎么打出一个线程的堆栈信息？如果内存过高怎么分析？如果cpu过高怎么定位？"></a>怎么打出一个线程的堆栈信息？如果内存过高怎么分析？如果cpu过高怎么定位？</h2><h3 id="怎么打出一个线程的堆栈信息？"><a href="#怎么打出一个线程的堆栈信息？" class="headerlink" title="怎么打出一个线程的堆栈信息？"></a>怎么打出一个线程的堆栈信息？</h3><p>jstack</p><h3 id="如果cpu过高怎么定位？"><a href="#如果cpu过高怎么定位？" class="headerlink" title="如果cpu过高怎么定位？"></a>如果cpu过高怎么定位？</h3><ol><li>使用 top 找到占用 CPU 最高的 Java 进程。使用 top命令发现占用 CPU 99.7% 的线程是 Java 进程，进程 PID 为 13731。</li><li>用 top -Hp 命令查看占用 CPU 最高的线程。执行top -Hp pid命令，pid 就是前面的 Java 进程。可以看到占用 CPU 最高的那个线程 PID 为 13756。然后将 13756转换为 16 进制的，后面会用到，可以用在线进制转换的网站直接转换，转换结果为 0x35bc</li><li>当前 Java 程序的所有线程信息都可以通过 jstack命令查看，我们用jstack命令将第一步找到的 Java 进程的线程栈保存下来。jstack 13731 &gt; thread_stack.log</li><li>再jstack输出记录中查找0x35bc，可以定位到具体的代码行，调用栈。</li></ol><h3 id="如果内存过高怎么分析？"><a href="#如果内存过高怎么分析？" class="headerlink" title="如果内存过高怎么分析？"></a>如果内存过高怎么分析？</h3><p>设置fullGC或者堆溢出时dump，通过mat工具分析，查看对象的数量和内存占比。还可以利用MAT的泄露检查报告（leak suspect）进行分析。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/271783423">高频面试题：Java程序占用 CPU 过高怎么排查</a><br><a href="https://blog.csdn.net/chihaihai/article/details/108695821">JVM—常规堆内存溢出场景排查方法</a></p><h2 id="内存的哪些部分会参与GC的回收"><a href="#内存的哪些部分会参与GC的回收" class="headerlink" title="内存的哪些部分会参与GC的回收"></a>内存的哪些部分会参与GC的回收</h2><p>堆、方法区、直接内存</p><h2 id="While（true）里一直new-thread-start-会有什么问题"><a href="#While（true）里一直new-thread-start-会有什么问题" class="headerlink" title="While（true）里一直new thread().start()会有什么问题"></a>While（true）里一直new thread().start()会有什么问题</h2><p>线程一直运行的情况会导致CPU被占满，创建线程的速度越来越慢。<br>线程不一直运行的情况会导致创建大量线程对象，导致垃圾收集器频繁young gc。</p><h2 id="jvm调优"><a href="#jvm调优" class="headerlink" title="jvm调优"></a>jvm调优</h2><p>JVM调优不是常规手段，性能问题一般第一选择是优化程序，最后的选择才是进行JVM调优。</p><h3 id="jvm调优目标"><a href="#jvm调优目标" class="headerlink" title="jvm调优目标"></a>jvm调优目标</h3><p>吞吐量、延迟、内存占用三者构成了一个不可能三角，只能选择其中两个进行调优，不可三者兼得。</p><p>延迟：GC低停顿和GC低频率；<br>低内存占用；<br>高吞吐量;</p><p>选择了其中两个，必然会会以牺牲另一个为代价。</p><p>下面展示了一些JVM调优的量化目标参考实例：</p><p>Heap 内存使用率 &lt;&#x3D; 70%;<br>Old generation内存使用率&lt;&#x3D; 70%;<br>jvm.gc.time：每分钟的GC耗时在1s以内，500ms以内尤佳<br>jvm.gc.meantime：每次YGC耗时在100ms以内，50ms以内尤佳<br>jvm.fullgc.count：FGC最多几小时1次，1天不到1次尤佳<br>jvm.fullgc.time：每次FGC耗时在1s以内，500ms以内尤佳<br>注意：不同应用的JVM调优量化目标是不一样的。</p><h3 id="不得不考虑进行JVM调优的是那些情况"><a href="#不得不考虑进行JVM调优的是那些情况" class="headerlink" title="不得不考虑进行JVM调优的是那些情况"></a>不得不考虑进行JVM调优的是那些情况</h3><p>Heap内存（老年代）持续上涨达到设置的最大内存值或应用出现OutOfMemory 等内存异常；<br>Full GC 次数频繁（系统吞吐量下降）；<br>GC 停顿时间过长（超过1秒）</p><h3 id="调优步骤"><a href="#调优步骤" class="headerlink" title="调优步骤"></a>调优步骤</h3><ol><li>分析和定位当前系统的瓶颈</li><li>确定优化目标</li><li>制订优化方案</li><li>对比优化前后的指标，统计优化效果</li><li>持续观察和跟踪优化效果</li><li>如果还需要的话，重复以上步骤</li></ol><h3 id="常见问题与对策"><a href="#常见问题与对策" class="headerlink" title="常见问题与对策"></a>常见问题与对策</h3><ol><li><p>cpu过高<br>参照“怎么打出一个线程的堆栈信息？如果内存过高怎么分析？如果cpu过高怎么定位？”定位处理；</p></li><li><p>堆内存溢出<br>堆dump然后基于MAT分析，查看对象数量、内存排序，查看内存泄漏报告。如果是内存泄漏，通过修改代码改变，如果没有内存泄漏，考虑增加堆内存大小-Xmx。</p></li><li><p>单核处理器<br>Serial 垃圾收集器是你唯一的选择</p></li><li><p>吞吐量优先<br>选择PS+PO组合</p></li><li><p>停顿时间太久<br>CMS和G1，G1可以指定期望停顿时间</p></li><li><p>频繁GC<br>增加堆内存大小</p></li><li><p>某一个区域的GC频繁，其他都正常<br>传统GC，调整内存区域大小比率；G1一般不指定分区比例，因为G1内部会根据停顿时间自适应调整</p></li><li><p>老年代频繁GC，每次回收的对象很多<br>如果升代年龄小，新生代的对象很快就进入老年代了，导致老年代对象变多，而这些对象其实在随后的很短时间内就可以回收，这时候可以调整对象的升级代年龄，让对象不那么容易进入老年代解决老年代空间不足频繁GC问题。<br>另外需要检查是否是因为存活的新生代太多触发担保机制，这是需要调整年轻代的比例。</p></li><li><p>CMS&#x2F;G1经常Serial Old GC长时间停顿<br>原因是并发收集时浮动垃圾过多，导致内存空间不足，触发备用的单线程垃圾收集器，造成长时间停顿</p></li></ol><p>CMS：降低CMS垃圾回收的老年代阈值<br>-XX:CMSInitiatingOccupancyFraction，CMS垃圾回收的老年代阈值</p><p>G1: 降低并发标记的触发阈值与纳入Cset的Region的存活空间占比阈值<br>-XX:G1MixedGCLiveThresholdPercent，被纳入Cset的Region的存活空间占比阈值<br>-XX:InitiatingHeapOccupancyPercent指定，默认值45%，也就是老年代占堆的比例超过45%。触发全局并发标记的老年代使用占比</p><ol start="10"><li>GC的次数、时间和回收的对象都正常，堆内存空间充足，但是报OOM<br>JVM除了堆内存之外还有一块堆外内存，这片内存也叫本地内存，可是这块内存区域不足了并不会主动触发GC，只有在堆内存区域触发的时候顺带会把本地内存回收了，而一旦本地内存分配不足就会直接报OOM异常。<br>注意： 本地内存异常的时候除了上面的现象之外，异常信息可能是OutOfMemoryError：Direct buffer memory。 解决方式除了调整本地内存大小之外，也可以在出现此异常时进行捕获，手动触发GC（System.gc()）。<br>配置参数：XX:MaxDirectMemorySize</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>oom，改最大堆，方法内大对象置为null提前回收；<br>改数据处理流程，中间结果提前缓存redis；</p><h3 id="面试官对线策略"><a href="#面试官对线策略" class="headerlink" title="面试官对线策略"></a>面试官对线策略</h3><p>首先表态如果使用合理的 JVM 参数配置，在大多数情况应该是不需要调优的<br>其次说明可能还是存在少量场景需要调优，我们可以对一些 JVM 核心指标配置监控告警，当出现波动时人为介入分析评估，导出GC日志，通过GCEASY网站进行可视化分析GC日志<br>最后举一个实际的调优例子来加以说明</p><p>参考：<br><a href="https://www.cnblogs.com/three-fighter/p/14644152.html">【JVM进阶之路】十：JVM调优总结</a><br><a href="https://zhuanlan.zhihu.com/p/488615913?utm_id=0">面试官：如何进行 JVM 调优（附真实案例）</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ">微信公众号:我的IT技术路</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;jvm相关面试题目整理&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目</summary>
      
    
    
    
    <category term="java" scheme="http://soatree.github.io/categories/java/"/>
    
    
    <category term="面试" scheme="http://soatree.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>未来简史</title>
    <link href="http://soatree.github.io/2023/05/17/%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2/"/>
    <id>http://soatree.github.io/2023/05/17/%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2/</id>
    <published>2023-05-17T13:19:34.000Z</published>
    <updated>2023-08-03T14:13:34.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《未来简史》 尤瓦尔·赫拉利　中信出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>这正是研究历史最好的理由：不是为了预测未来，而是要将自己从过去中释放出来，想象是否有另一种命运。当然，我们仍不免受到过去的影响，所以永远不可能得到完全的自由；然而，部分自由总比全无自由要好得多。</li><li>住在宫殿里的人，心中的重要议题永远与住在陋室里的人不同，而就算在21世纪，这件事也不太可能改变。</li><li>在大约2300年前，伊壁鸠鲁就曾警告门徒，无节制追求享乐带来的很可能是痛苦而非快乐。得到快感时，我们的反应不是满足，反而是想得到更多。因此，不论我们感受到多少幸福、兴奋的感觉，也永远无法满足。 如果我认定快乐就是这些稍纵即逝的快感，并且渴望得到更多，我就别无选择，只能不断追求下去。好不容易得到之后，快感又很快消失，而且因为仅有过去快乐的回忆并不足以令我满足，所以我又得从头再来。像这样的追求，就算持续几十年，也永远无法带来任何长久的成果；相反，我越渴望这些快感，就会变得更加压力重重、无法满足。想得到真正的幸福快乐，人类该做的并非加速，而是放慢追求快感的脚步。</li><li>1958——1987年，日本人均实际收入增长了5倍，但对日本人的主观幸福感却出人意料地几乎没有造成什么影响。20世纪90年代，日本人对生活还是如同20世纪50年代时一样满意或不满意。从1950年到2000年，美国GDP从2万亿美元增长到12万亿美元。人均实际收入增加了一倍。但研究显示，美国人在20世纪90年代的主观幸福感，与20世纪50年代的调查结果仍然大致相同。</li><li>伊壁鸠鲁把幸福快乐定义成至善的时候，就曾告诫弟子，快乐是件辛苦的差使。仅有物质成就，并不能让我们长久感到满足。事实上，盲目追求金钱、名誉和欢愉，只会让我们痛苦不堪。举例来说，伊壁鸠鲁就建议吃喝要适量，性欲也要控制。从长远来看，深厚的友谊会比一夜狂欢让人更快乐。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>这本书整体更偏向于哲学思考，物质并一定不能带来幸福，精神带来的幸福远大于物质。因为人的物欲是无穷无尽的，只有节制自己的物欲，倾听内心，做自己内心真正认同的事情才能获得长久的幸福。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h1&gt;&lt;p&gt;《未来简史》 尤瓦尔·赫拉利　中信出版社&lt;/p&gt;
&lt;h1 id=&quot;摘录&quot;&gt;&lt;a href=&quot;#摘录&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="读书" scheme="http://soatree.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="哲学" scheme="http://soatree.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
    <category term="历史" scheme="http://soatree.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>常用快捷键记录</title>
    <link href="http://soatree.github.io/2023/05/17/Windows%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BD%95/"/>
    <id>http://soatree.github.io/2023/05/17/Windows%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BD%95/</id>
    <published>2023-05-17T11:42:15.000Z</published>
    <updated>2023-07-15T01:41:50.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows通用"><a href="#Windows通用" class="headerlink" title="Windows通用"></a>Windows通用</h2><ul><li>打开操作中心</li></ul><p></p><p>Win + A</p><ul><li>打开通知面板（通知中心）</li></ul><p></p><p>Win + N</p><ul><li>打开预览</li></ul><p>Win + Z</p><ul><li>在任务栏间切换应用程序</li></ul><p>Win + T</p><ul><li>执行该字母的命令</li></ul><p></p><p>Alt + 带下划线的字母</p><ul><li>转到退回</li></ul><p></p><p>Alt + 左箭头</p><ul><li>转到向前</li></ul><p></p><p>Alt + 右箭头</p><ul><li>打开设置</li></ul><p>Win + I</p><ul><li>打开任务视图</li></ul><p></p><p>Win + Tab</p><ul><li>添加虚拟桌面</li></ul><p></p><p>Win + Ctrl + D</p><ul><li>在右侧创建的虚拟桌面之间切换</li></ul><p></p><p>Win + Ctrl + 右箭头</p><ul><li>在左侧创建的虚拟桌面之间切换</li></ul><p></p><p>Win + Ctrl + 左箭头</p><ul><li>关闭您正在使用的虚拟桌面</li></ul><p></p><p>Win + Ctrl + F4</p><h1 id="edge"><a href="#edge" class="headerlink" title="edge"></a>edge</h1><ul><li>在地址栏中选择 URL 进行编辑</li></ul><p></p><p>Alt + D</p><ul><li>打开历史</li></ul><p></p><p>Ctrl + H</p><ul><li>打开一个新选项卡并切换到它</li></ul><p></p><p>Ctrl + T</p><ul><li>关闭当前选项卡</li></ul><p>Ctrl + W</p><h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><ul><li>复制当前行到下一行</li></ul><p>ctrl + d</p><ul><li>运行</li></ul><p>shift + f10</p><ul><li>debug</li></ul><p>shift + f9</p><ul><li>方法或类注释</li></ul><p>在一个方法或类的开头，输入&#x2F;**，然后按回车,自动根据参数和返回值生成注释模板，我们在这个模板上面编写即可。</p><ul><li>生成UML图</li></ul><p>ctrl + shift + alt + u</p><h1 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h1><ul><li>单行注释</li></ul><p>ctrl+&#x2F;</p><ul><li>移动行</li></ul><p>alt+up&#x2F;down</p><ul><li>复制当前行</li></ul><p>shift + alt +up&#x2F;down</p><ul><li>删除当前行</li></ul><p>shift + ctrl + k</p><ul><li>代码格式化</li></ul><p>shift + alt +f </p><ul><li>快速回到顶部</li></ul><p>ctrl + home</p><ul><li>快速回到底部</li></ul><p>ctrl + end</p><ul><li>当前文件替换</li></ul><p>ctrl + h</p><ul><li>切换文件</li></ul><p>ctrl + tab</p><ul><li>取消撤销</li></ul><p>ctrl + y</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/460274555">非常实用的 Windows 11 键盘快捷键终极列表</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Windows通用&quot;&gt;&lt;a href=&quot;#Windows通用&quot; class=&quot;headerlink&quot; title=&quot;Windows通用&quot;&gt;&lt;/a&gt;Windows通用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;打开操作中心&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;	&lt;/p&gt;
&lt;p&gt;Win + </summary>
      
    
    
    
    <category term="记录" scheme="http://soatree.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="快捷键" scheme="http://soatree.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>无伤跑法</title>
    <link href="http://soatree.github.io/2023/04/22/%E6%97%A0%E4%BC%A4%E8%B7%91%E6%B3%95/"/>
    <id>http://soatree.github.io/2023/04/22/%E6%97%A0%E4%BC%A4%E8%B7%91%E6%B3%95/</id>
    <published>2023-04-22T10:11:59.000Z</published>
    <updated>2023-08-03T14:13:33.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《无伤跑法》 戴剑松 人民邮电出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="运动频率强度"><a href="#运动频率强度" class="headerlink" title="运动频率强度"></a>运动频率强度</h2><ul><li>成年人每周应该累计进行至少150分钟（2小时30分钟）的中等强度运动或累计每周参加75分钟（1小时15分钟）的大强度运动。也可以将中等强度和大强度的运动相结合。普通步行为中等强度运动，跑步为大强度运动。</li><li>力量型运动的频率建议一周2次或更多。</li></ul><h2 id="跑步谣言"><a href="#跑步谣言" class="headerlink" title="跑步谣言"></a>跑步谣言</h2><ul><li>清晨空气质量对于运动不构成影响，主要还是看当时实际的空气质量，早上二氧化碳浓度高的说法没有依据。</li><li>早晨空腹跑步低血糖的概率极低，只要跑步距离不超过10km一般都可空腹跑步，如果超过10km，建议早餐后1小时跑步。但是建议早晨喝点水再跑步。</li><li>晨跑仍然是糖和脂肪混合供能，目前没有足够科学证据证明晨跑更有利于燃烧脂肪。</li><li>早上或者下午跑步状态因人而异，没有科学依据支持早晨或者下午跑步更好。</li></ul><h2 id="正确热身"><a href="#正确热身" class="headerlink" title="正确热身"></a>正确热身</h2><ul><li><p>肌肉动态牵拉(12次)：大腿前侧动态牵拉，大腿后侧动态牵拉，大腿内侧动态牵拉，臀肌动态牵拉，小腿动态牵拉，最伟大热身</p></li><li><p>肌肉激活（10s）: 马步蹲，单腿硬拉 </p></li><li><p>原地跑（30s）：前后垫步，垫步高抬腿</p></li></ul><h2 id="跑鞋"><a href="#跑鞋" class="headerlink" title="跑鞋"></a>跑鞋</h2><ul><li>跑鞋在600km可以考虑更换。</li><li>尝试不同品牌不同类型的跑鞋。</li><li>跑鞋可以发挥一定作用保护身体，但是指望跑鞋来避免损伤是不可能的。</li></ul><h2 id="跑姿"><a href="#跑姿" class="headerlink" title="跑姿"></a>跑姿</h2><ul><li>导致跑步伤痛的众多危险因素中，居于首位的原因是步幅过大。</li><li>在慢速跑步时，采用全脚掌外侧着地既避免了脚后跟着地的弊端（容易受到较大的峰值应力），也避免了一味前脚掌着地脚踝小腿肌肉容易紧张疲劳的问题。对于大众跑者这或许是一种更加合理的着地方式。</li><li>合理的着地位置为：着地点在重心投影点略微靠前一点，既不是在重心正下方，但也不会距离重心投影点太远，膝关节在着地时保持弯曲非常必要。跑者应当极力避免脚跟着地同时膝关节伸直锁死的着地方式，即甩小腿跑法，这种跑法对于下肢关节伤害极大。</li><li>推荐跑步姿势：头部正直，挺胸收腹并略微前倾；以肩为轴心，自然前后摆臂，摆臂不要越过身体正中线；采用全脚掌外侧着地；着地点在重心投影点略微靠前一点，膝关节在着地时保持弯曲，避免脚跟着地同时膝关节伸直锁死的着地方式；适当控制步幅，步频180步&#x2F;分最佳。</li></ul><h2 id="跑步策略"><a href="#跑步策略" class="headerlink" title="跑步策略"></a>跑步策略</h2><ul><li>本人采用MAF180训练</li></ul><h2 id="跑步损伤"><a href="#跑步损伤" class="headerlink" title="跑步损伤"></a>跑步损伤</h2><ul><li>冬季跑步口鼻并用时，启口不易过大，尽量保持空气的湿润温暖。</li><li>每周跑步92km以内对关节更加健康，跑步百利唯伤膝的说法是没有依据的。</li><li>不要盲目激增训练，否则会给身体造成无法修复的损伤。</li><li>出现膝痛并不意味着一定要完全停跑休息。如果是急性损伤，如肌肉拉伤、韧带扭伤。需要停跑，完全休息1~2周。而跑者膝属于慢性劳损，如果疼痛不是很明显，则不必完全停跑；但一定要减少跑量，减至跑步时和跑步后不引起疼痛为度。跑步过程中如果出现疼痛，要果断停跑，因为越痛越跑的后果在往就是越跑越痛。</li><li>不适合膝痛跑者的腿部力量训练：幅度较大的靠墙静蹲，下蹲，弓箭步。</li><li>针对膝痛跑者的康复训练：高位靠墙静蹲，仰卧直腿抬高，单腿硬拉，臀桥。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>好好锻炼，保护身体。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h1&gt;&lt;p&gt;《无伤跑法》 戴剑松 人民邮电出版社&lt;/p&gt;
&lt;h1 id=&quot;摘录&quot;&gt;&lt;a href=&quot;#摘录&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="读书" scheme="http://soatree.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="运动" scheme="http://soatree.github.io/tags/%E8%BF%90%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>传习录</title>
    <link href="http://soatree.github.io/2023/04/22/%E4%BC%A0%E4%B9%A0%E5%BD%95/"/>
    <id>http://soatree.github.io/2023/04/22/%E4%BC%A0%E4%B9%A0%E5%BD%95/</id>
    <published>2023-04-22T04:09:38.000Z</published>
    <updated>2023-08-03T14:13:31.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《传习录》 王阳明 江苏文艺出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="知行"><a href="#知行" class="headerlink" title="知行"></a>知行</h2><ul><li>良知之在人心，不但圣贤，虽常人亦无不如此。若无有物欲牵蔽，但循着良知发用流行将去，即无不是道。但在常人多为物欲牵蔽，不能循得良知。</li><li>真知即所以为行，不行不足谓之知。</li><li>未有知而不行者。知而不行，只是未知。</li><li>无善无恶是心之体，有善有恶是意之动。知善知恶是良知，为善去恶是格物。</li><li>问：“先生尝谓善恶只是一物。善恶两端，如冰炭相反，如何谓只一物？” 先生曰：“至善者，心之本体。本体上才过当些子，便是恶了。不是有一个善，却又有一个恶来相对也。故善恶只是一物。” 直因闻先生之说，则知程子所谓“善固性也，恶亦不可不谓之性”，又曰“善恶皆天理。谓之恶者本非恶，但于本性上过与不及之间耳”，其说皆无可疑。</li></ul><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>先生尝语学者曰：“心体上着不得一念留滞，就如眼着不得些子尘沙。些子能得几多？满眼便昏天黑地了。” 又曰：“这一念不但是私念，便好的念头亦着不得些子。如眼中放些金玉屑，眼亦开不得了。”</li><li>问：“圣人‘生知安行’是自然的，如何？有甚功夫？” 先生曰：“‘知行’二字即是功夫，但有浅深难易之殊耳。良知原是精精明明的，如欲孝亲。‘生知安行’的只是依此良知实落尽孝而已；‘学知利行’者只是时时省觉，务要依此良知尽孝已；至于‘困知勉行’者，蔽锢已深，虽要依此良知去孝，又为私欲所阻，是以不能，必须加人一己百、人十己千之功，方能依此良知以尽其孝。圣人虽是‘生知安行’，然其心不敢自是，肯做‘困知勉行’的功夫。‘困知勉行’的却要思量做‘生知安行’的事，怎生成得？”</li><li>先生曰：“学问功夫，于一切声利嗜好俱能脱落殆尽，尚有一种生死念头毫发挂带，便于全体有未融释处。人于生死念头，本从生身命根上带来，故不易去。若于此处见得破、透得过，此心全体方是流行无碍，方是尽性至命之学。”</li><li>又曰：“诸君功夫，最不可助长。上智绝少，学者无超入圣人之理。一起一伏，一进一退，自是功夫节次。不可以我前日用得功夫了，今却不济，便要矫强做出一个没破绽的模样，这便是助长，连前些子功夫都坏了。此非小过，譬如行路的人遭一蹶跌，起来便走，不要欺人，做那不曾跌倒的样子出来。诸君只要常常怀个‘遁世无闷，不见是而无闷’之心，依此良知，忍耐做去，不管人非笑，不管人毁谤，不管人荣辱，任他功夫有进有退，我只是这致良知的主宰不息，久久自然有得力处，一切外事亦自能不动。” 又曰：“人若着实用功，随人毁谤，随人欺慢，处处得益，处处是进德之资。若不用功，只是魔也，终被累倒。”</li><li>先生尝谓：“人但得好善如好好色，恶恶如恶恶臭，便是圣人。” 直初时闻之，觉甚易，后体验得来，此个功夫着实是难。如一念虽知好善恶恶，然不知不觉，又夹杂去了。才有夹杂，便不是好善如好好色、恶恶如恶恶臭的心。善能实实的好，是无念不善矣；恶能实实的恶，是无念及恶矣。如何不是圣人？故圣人之学，只是一诚而已。</li><li>先生曰：“我这里自有功夫，何缘得他来？只为尔功夫断了，便蔽其知。既断了，则继续旧功便是。何必如此？” 九川曰：“直是难鏖。虽知，丢他不去。” 先生曰：“须是勇。用功久，自有勇。</li><li>又问：“用功收心时，有声、色在前，如常闻见，恐不是专一？” 曰：“如何欲不闻见？除是槁木死灰，耳聋目盲则可。只是虽闻见而不流去便是。” 曰：“昔有人静坐，其子隔壁读书，不知其勤惰。程子称其甚敬。何如？” 曰：“伊川恐亦是讥他。”</li><li>先生又曰：“吾辈用力，只求日减，不求日增。减得一分人欲，便是复得一分天理，何等轻快脱洒！何等简易！”</li><li>“只存得此心常见在便是学。过去未来事，思之何益？徒放心耳。”</li><li>曰仁云：“心犹镜也，圣人心如明镜，常人心如昏镜。近世格物之说，如以镜照物，照上用功，不知镜尚昏在，何能照？先生之格物，如磨镜而使之明，磨上用功，明了后亦未尝废照。”</li><li>是知圣人遇此时，方有此事。只怕镜不明，不怕物来不能照。讲求事变，亦是照时事。然学者却须先有个明的工夫。学者惟患此心之未能明，不患事变之不能尽。</li></ul><h2 id="警惕"><a href="#警惕" class="headerlink" title="警惕"></a>警惕</h2><ul><li>孟子云：“学问之道无他，求其放心而已矣。”非若后世广记博诵古人之言词，以为好古，而汲汲然惟以求功名利达之具于外者也。“</li><li>今曰“养生以清心寡欲为要”，只“养生”二字便是自私自利、将迎意必之根。有此病根潜伏于中，宜其有“灭于东而生于西”“引犬上堂而逐之”之患也。</li><li>先生曰：“人生大病，只是一‘傲’字。为子而傲必不孝，为臣而傲必不忠，为父而傲必不慈，为友而傲必不信。故象与丹朱俱不肖，亦只一‘傲’字，便结果了此生。诸君常要体此。人心本是天然之理，精精明明，无纤介染着，只是一‘无我’而已。胸中切不可‘有’，‘有’即‘傲’也。古先圣人许多好处，也只是‘无我’而已。‘无我’自能谦，谦者众善之基，傲者众恶之魁。”</li><li>先生曰：“此‘格物’之说未透。心何尝有内外？即如惟浚今在此讲论，又岂有一心在内照管？这听讲说时专敬，即是那静坐时心。功夫一贯，何须更起念头？人须在事上磨炼，做功夫乃有益。若只好静，遇事便乱，终无长进。那静时功夫亦差似收敛，而实放溺也。”</li><li>曰：“只要去人欲、存天理，方是功夫。静时念念去人欲、存天理，动时念念去人欲、存天理，不管宁静不宁静。若靠那宁静，不惟渐有喜静厌动之弊，中间许多病痛，只是潜伏在，终不能绝去，遇事依旧滋长。以循理为主，何尝不宁静？以宁静为主，未必能循理。”</li><li>先生曰：“是徒知静养，而不用克己工夫也。如此，临事便要倾倒。人须在事上磨，方立得住，方能‘静亦定，动亦定’。”</li><li>曰：“虽未相着，然平日好色、好利、好名之心，原未尝无。既未尝无，即谓之有。既谓之有，则亦不可谓无偏倚。譬之病疟之人，虽有时不发，而病根原不曾除，则亦不得谓之无病之人矣。须是平日好色、好利、好名等项一应私心扫除荡涤，无复纤毫留滞，而此心全体廓然，纯是天理，方可谓之喜怒哀乐‘未发之中’，方是天下之大本。”</li><li>“克己须要扫除廓清，一毫不存方是。有一毫在，则众恶相引而来。”</li><li>人于此处多认做天理当忧，则一向忧苦，不知已是‘有所忧患，不得其正’。大抵七情所感，多只是过，少不及者。才过便非心之本体。必须调停适中始得。</li><li>问“有所忿懥”一条。 先生曰：“忿懥几件，人心怎能无得，只是不可有所耳。凡人忿懥，着了一分意思，便怒得过当，非廓然大公之体了。故有所忿懥，便不得其正也。如今于凡忿懥等件，只是个物来顺应，不要着一分意思，便心体廓然大公，得其本体之正了。且如出外见人相斗，其不是的，我心亦怒。然虽怒，却此心廓然，不曾动些子气。如今怒人，亦得如此，方才是正。”</li><li>“喜怒哀乐，本体自是中和的，才自家着些意思，便过不及，便是私。”</li><li>问孟子言“执中无权犹执一”。 先生曰：“中只是天理，只是易。随时变易，如何执得？须是因时制宜，难预先定一个规矩在。如后世儒者，要将道理一一说得无罅漏，立定个格式，此正是执一。”</li><li>“日间工夫，觉纷扰，则静坐；觉懒看书，则且看书。是亦因病而药。”</li><li>先生曰：“好色则一心在好色上，好货则一心在好货上，可以为主一乎？是所谓逐物，非主一也。主一是专主一个天理。”</li><li>子夏笃信圣人，曾子反求诸己。笃信固亦是，然不如反求之切。今既不得于心，安可狃于旧闻，不求是当？</li></ul><h2 id="交友"><a href="#交友" class="headerlink" title="交友"></a>交友</h2><ul><li>先生曰：“大凡朋友，须箴规指摘处少，诱掖奖劝意多，方是。” 后又戒九川云：“与朋友论学，须委曲谦下，宽以居之。”</li><li>先生曰：“凡朋友问难，纵有浅近粗疏，或露才扬己，皆是病发，当因其病而药之可也，不可便怀鄙薄之心。非君子与人为善之心矣。”</li><li>“处朋友，务相下，则得益，相上则损。”</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>格物致知，知行合一，诚意坚持</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h1&gt;&lt;p&gt;《传习录》 王阳明 江苏文艺出版社&lt;/p&gt;
&lt;h1 id=&quot;摘录&quot;&gt;&lt;a href=&quot;#摘录&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="读书" scheme="http://soatree.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="哲学" scheme="http://soatree.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>人类简史</title>
    <link href="http://soatree.github.io/2023/03/31/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"/>
    <id>http://soatree.github.io/2023/03/31/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/</id>
    <published>2023-03-31T14:24:38.000Z</published>
    <updated>2023-08-03T14:13:28.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《人类简史：从动物到上帝》 尤瓦尔·赫拉利　中信出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h2><ul><li>农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚构故事也更为细致完整。人类几乎从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照着这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化”。</li><li>根据这种说法，文化并不是某些人为了剥削他人而设计出的阴谋，而是因为种种机缘巧合所出现的心理寄生虫，从出现之后就开始剥削所有受到感染的人。</li><li>然而，以上所有的区别，不管是自由人／奴隶、白人／黑人、富人／穷人，都只是虚构的想象所建构出来的。（后面会另外来谈男女的阶级问题。）然而历史的铁则告诉我们，每一种由想象建构出来的秩序，都绝不会承认自己出于想象和虚构，而会大谈自己是自然、必然的结果。</li><li>但人类可就不同了，这种事总是不断发生。因为智人的社会秩序是通过想象建构，维持秩序所需的关键信息无法单纯靠DNA复制就传给后代，需要通过各种努力，才能维持种种法律、习俗、程序、礼仪，否则社会秩序很快就会崩溃。</li><li>为了改变现有由想象建构出的秩序，就得先用想象建构出另一套秩序才行。</li><li>身为人类，我们不可能脱离想象所建构出的秩序。每一次我们以为自己打破了监狱的高墙、迈向自由的前方，其实只是到了另一间更大的监狱，把活动范围稍稍加以扩大。</li><li>“主体间”事物的存在，靠的是许多个人主观意识之间的连接网络。就算有某个人改变了想法，甚至过世，对这项事物的影响并不大。但如果是这个网络里面的大多数都死亡或是改变了想法，这种“主体间”的事物就会发生改变或是消失。之所以会有事物存在于主体之间，其目的并不是想存心骗人，也不是只想打哈哈敷衍。虽然它们不像放射线会直接造成实质影响，但对世界的影响仍然不容小觑。历史上有许多最重要的驱动因素，都是这种存在于主体之间的概念想法：法律、金钱、神、国家。</li><li>想象建构的秩序并非个人主观的想象，而是存在于主体之间（inter-subjective），存在于千千万万人共同的想象之中。</li><li>多数人很难接受自己的生活秩序只是虚构的想象，但事实是我们从出生就已经置身于这种想象之中，而且连我们的欲望也深受其影响。于是，个人欲望也就成为虚构秩序最强大的守护者。</li><li>消费主义告诉我们，想要快乐，就该去买更多的产品、更多的服务。如果觉得少了什么，或是有什么不够舒服的地方，那很可能是该买些什么商品（新车、新衣服、有机食品），或是买点什么服务（清洁工、心理咨询、瑜伽课）。就连每一则电视广告，也都是个小小的虚构故事，告诉你买了什么产品或服务可以让日子更好。浪漫主义告诉我们，为了要尽量发挥潜力，就必须尽量累积不同的经验。必须体会不同的情感，尝试不同的关系，品尝不同的美食，还必须学会欣赏不同风格的音乐。而其中最好的一种办法，就是摆脱日常生活及工作，远离熟悉的环境，前往遥远的国度，好亲身“体验”不同的文化、气味、美食和规范。我们总会不断听到浪漫主义的神话，告诉我们“那次的经验让我眼界大开，从此整个生活都不一样了”。现代人之所以要花费大把银子到国外度假，正是因为他们真正相信了浪漫的消费主义神话。</li><li>我们困于人类文化太久了</li></ul><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul><li>历史上的每一个时间点，都像是一个十字路口。虽然从过去到现在已经只剩单行道，但到未来却有无数岔路可走。其中某些路比较宽、比较平坦，路标比较明确，所以也是比较可能的选择。然而，历史有时候就是选了一些完全出人意表的道路。</li><li>无论我们把历史发展的动力称为博弈理论、后现代主义或迷因学，“提升人类福祉”绝不是其主要目标。并没有证据显示史上最成功的文化就一定是对智人最好的文化。而就像演化一样，历史的演进并不在意生物个体是否幸福。</li></ul><h2 id="生活方式"><a href="#生活方式" class="headerlink" title="生活方式"></a>生活方式</h2><ul><li>农业带来的压力影响深远，这正是后代大规模政治和社会制度的基础。但可悲的是，虽然农民勤劳不懈、希望能够保障自己未来的经济安全，但这几乎从来未曾实现。不管在任何地方，都出现了统治者和精英阶级，不仅靠着农民辛苦种出的食粮维生，还几乎全征收抢光，只留给农民勉强可过活的数量。</li><li>农业时代人类的空间缩小，但时间却变长了。一般来说，采集者不会花太多心思考虑下周或下个月的事，但农民却会想象预测着未来几年甚至几十年的事。绝大多数的农民都是住在永久聚落里，只有少数是游牧民族。“定居”这件事，让大多数人的活动范围大幅缩小。远古狩猎采集者的活动范围可能有几十甚至上百平方公里。当时这片范围都是他们的“家”，有山丘、溪流、树林，还有开阔的天空。但对农民而言，几乎整天就是在一小片田地或果园里工作，就算回到“家”，这时的房子也就是个用木头、石头或泥巴盖起的局促结构，每边再长也不过几十米。一般来说，农民就会和房屋这种构造建立起非常强烈的连接。这场革命意义深远，除了影响建筑，更影响了心理。在农业革命之后，人类成了远比过去更以自我为中心的生物，与“自己家”紧密相连，但与周遭其他物种画出界线。</li><li>三不五时，总有些反对提高机械化和自动化的勒德分子（Luddite）坚持不用电子邮件，就像几千年前，也有某些人类部落拒绝农业，所以躲过了奢侈生活的陷阱。</li><li>于是，种种想让生活变得轻松的努力，反而给人带来无穷的麻烦；而且这可不是史上的最后一次。就算今天，仍然如此。有多少年轻的大学毕业生投身大企业、从事各种劳心劳力的工作，发誓要努力赚钱，好在35岁就退休，去从事他们真正有兴趣的事业？但等他们到了35岁，却发现自己背着巨额贷款，要付子女的学费，要养在高级住宅区的豪宅，每家得有两部车，而且觉得生活里不能没有高级红酒和国外的假期。他们该怎么做？他们会放下一切，回去野外采果子挖树根吗？当然不可能，而是加倍努力，继续把自己累得半死。</li><li>谁该负责？这背后的主谋，既不是国王，不是牧师，也不是商人。真正的主要嫌疑人，就是那极少数的植物物种，其中包括小麦、稻米和马铃薯。人类以为自己驯化了植物，但其实是植物驯化了智人。</li><li>普遍来说，农民的工作要比采集者更辛苦，而且到头来的饮食还要更糟。农业革命可说是史上最大的一桩骗局。</li><li>远在人类还没有发明轮子、文字和铁器之前，智人就已经让全球大约一半的大型兽类魂归西天、就此灭绝。</li><li>采集者之所以能够免受饥饿或营养不良的困扰，秘诀就在于多样化的饮食。相较之下，之后农民的饮食往往种类极少，而且不均衡。</li><li>狩猎采集的生活方式依地区、季节有所不同，但整体而言，比起后来的农夫、牧羊人、工人或上班族，他们的生活似乎要来得更舒适，也更有意义。 在现代的富裕社会，平均每周的工时是40-45小时，发展中国家则是60甚至80小时；但如果是狩猎采集者，就算住在最贫瘠的地区（像是卡拉哈里沙漠），平均每周也只需要工作35-45小时。他们大概只需要每三天打猎一次，每天采集3-6小时。</li></ul><h2 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h2><ul><li>痛苦来自欲望；要从痛苦中解脱，就要放下欲望；而要放下欲望，就必须训练心智，体验事物的本质。</li><li>释迦牟尼找到一种方法可以跳出这种恶性循环。在事物带来快乐或痛苦的时候，重点是要看清事物的本质，而不是着重在它带来的感受，于是就能不再为此所困。虽然感受悲伤，但不要希望悲伤结束，于是虽然仍有悲伤，也能不再为此而困。即使仍然悲伤，也是一种丰硕的经验。虽然感受快乐，但不要希望快乐继续，于是虽然仍有快乐，也能不失去心中的平静。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>智人的现代化发展是血腥的，且生活质量也并不是向好的，我们应该积极挖掘生活的意义，更好地度过此生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h1&gt;&lt;p&gt;《人类简史：从动物到上帝》 尤瓦尔·赫拉利　中信出版社&lt;/p&gt;
&lt;h1 id=&quot;摘录&quot;&gt;&lt;a href=&quot;#摘录&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="读书" scheme="http://soatree.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="历史" scheme="http://soatree.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>每个人的战争</title>
    <link href="http://soatree.github.io/2023/03/25/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%88%98%E4%BA%89/"/>
    <id>http://soatree.github.io/2023/03/25/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%88%98%E4%BA%89/</id>
    <published>2023-03-25T13:40:01.000Z</published>
    <updated>2023-08-03T14:13:15.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《每个人的战争:抵御癌症的有效生活方式》 大卫·塞尔旺-施莱伯　广西师范大学出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="影响因素分析"><a href="#影响因素分析" class="headerlink" title="影响因素分析"></a>影响因素分析</h2><ul><li>抑制和活跃免疫细胞的因素</li></ul><table><thead><tr><th>抑制因素</th><th>活跃因素</th></tr></thead><tbody><tr><td>传统西方饮食</td><td>地中海、印度、亚洲饮食烹饪方式</td></tr><tr><td>长期愤怒和绝望情绪</td><td>平静、快乐的情绪</td></tr><tr><td>与世隔绝</td><td>有家人朋友的支持</td></tr><tr><td>久坐习惯</td><td>规律体育锻炼</td></tr></tbody></table><ul><li>影响炎症的主要因素</li></ul><table><thead><tr><th>抑制因素</th><th>活跃因素</th></tr></thead><tbody><tr><td>传统西方饮食</td><td>地中海、印度、亚洲饮食烹饪方式</td></tr><tr><td>精制糖、白面粉</td><td>杂粮</td></tr><tr><td>工业饲养的红肉、白肉、全脂乳品</td><td>草饲乳品、肉类</td></tr><tr><td>w6脂肪如玉米油、大豆油、葵花籽油</td><td>橄榄油、菜籽油</td></tr><tr><td>长期愤怒和绝望情绪</td><td>平静、快乐的情绪</td></tr><tr><td>久坐习惯</td><td>规律体育锻炼，每周6次，每次30分钟</td></tr></tbody></table><ul><li><p>近来已经发现了多种食品具有抗血管生成功效，包括常见的食用菌类、某些绿茶、辣椒和香草</p></li><li><p>很多加工食品的升糖指数都较高，应尽量食用原始的食物，少吃零食。</p></li><li><p>日常饮食保护</p></li></ul><table><thead><tr><th>少吃</th><th>替代</th></tr></thead><tbody><tr><td>高升糖指数食物</td><td>低升糖指数食物</td></tr><tr><td>油炸、w6脂肪酸</td><td>橄榄油、菜籽油，有机草饲食物，豆制品，水果</td></tr><tr><td>非有机红肉和蛋类、家禽皮</td><td>蔬菜、豆类、有机家禽蛋类、有机草饲红肉（每周不超过200g）、鱼类</td></tr><tr><td>非有机蔬菜</td><td>削皮水果、洗过的蔬菜</td></tr><tr><td>污染的饮用水</td><td>包装水或者过滤水</td></tr></tbody></table><ul><li><p>是的，我也许会比预计的更早去世，但是我也有可能比预计的活得更久。无论发生什么，我都要从现在起尽可能地好好活着。无论最后发生什么，这都是最好的应对方式。</p></li><li><p>抗癌购物单</p></li></ul><p>蛋白质 ·鱼类和贝类（含有硒、维生素D和长链ω-3脂肪酸），特别是三文鱼、鲭鱼、鳗鱼 ·有机肉类和家禽肉（适当食用） ·富含ω-3脂肪酸的蛋类（适当食用）·植物蛋白（豆类、豌豆、豆子、鹰嘴豆、绿豆） ·有机大豆类食品：豆腐、印尼豆豉、味噌、素肉排、豆芽、黄豆、豆奶、豆酸奶（含大豆异黄酮） </p><p>谷类和碳水化合物 ·杂粮面包或发酵面包 ·全粒大米（或印度香米、泰国大米） ·藜麦 ·碾碎的干小麦 ·燕麦片（燕麦粥），牛奶什锦早餐、全麸食品、全麦或燕麦、麸、亚麻籽、黑麦、大麦、斯佩尔特小麦混合的谷类食品 ·尼古拉土豆 ·红薯、山药 ·植物蛋白（见蛋白质一栏） </p><p>脂肪 ·橄榄油 ·亚麻籽油（富含ω-3脂肪酸、含有木酚素、植物油类） ·ω-3黄油 ·鱼肝油（含维生素D） ·菜籽油 </p><p>蔬菜 ·卷心菜：小洋白菜、白菜、大白菜、西兰花、花椰菜等 ·富含β胡萝卜素的蔬菜：胡萝卜、红薯、山药、西葫芦、南瓜、某些品种的法国栗子瓜（也叫北海道南瓜）、西红柿、甜菜等（含维生素A和番茄红素） ·菠菜（含镁） </p><p>蘑菇 ·香菇、灰树花菇、金针菇、褐菇、平菇或土耳其尾菇（含多糖和香菇多糖） </p><p>香草和香料 ·姜黄（姜黄素）与黑胡椒和橄榄油混合食用 ·咖喱 ·荷兰芹和芹菜（含芹菜素） ·唇形科植物：薄荷、百里香、墨角兰、牛至、罗勒属植物和迷迭香（含萜烯） ·葱属植物：大蒜、洋葱、韭葱、大葱、香葱（含二烯丙基二硫） ·肉桂（含原花青素） ·姜（含姜辣素）</p><p>益生菌 ·有机酸奶和酸奶酒、豆酸奶 ·德国泡菜、韩国泡菜 </p><p>具有益生作用的食物 ·大蒜、洋葱、西红柿、芦笋、香蕉、小麦 </p><p>海藻 ·紫菜、海带、裙带菜、海草和红皮藻（含褐藻多糖） </p><p>水果 ·浆果：草莓、覆盆子、蓝莓、黑莓、蔓越橘（含鞣花酸和多酚） ·樱桃（含葡萄二酸） ·石榴汁 ·柑橘类水果：橙、橘子（如果是有机水果，皮也可以吃）、柠檬、葡萄柚（含类黄酮） ·柿子和杏（含维生素A和番茄红素）</p><p>干果 ·核桃和榛子（含植物ω-3和镁元素） ·美洲山核桃（含鞣花酸） ·杏仁（含镁元素） </p><p>饮料 ·过滤水、矿物质水、泉水 ·用柠檬调味的水（或是百里香、鼠尾草、橘子、橙皮） ·绿茶（含茶多酚EGCG），特别是日本绿茶（煎茶、玉露茶、抹茶等） ·姜泡制的饮料（姜辣素） </p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>格物致知，善待每一天</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h1&gt;&lt;p&gt;《每个人的战争:抵御癌症的有效生活方式》 大卫·塞尔旺-施莱伯　广西师范大学出版社&lt;/p&gt;
&lt;h1 id=&quot;摘录&quot;&gt;&lt;a href=&quot;#摘录</summary>
      
    
    
    
    <category term="读书" scheme="http://soatree.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="养生" scheme="http://soatree.github.io/tags/%E5%85%BB%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>八股文-java多线程-其他</title>
    <link href="http://soatree.github.io/2023/02/23/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%B6%E4%BB%96/"/>
    <id>http://soatree.github.io/2023/02/23/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%B6%E4%BB%96/</id>
    <published>2023-02-23T14:13:45.000Z</published>
    <updated>2023-07-15T01:41:50.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java多线程的线程安全、线程管理、线程活性等相关面试题目整理，面经尽量用简短的语句说明问题，详细的信息可以参考每个面经下的参考链接。面经不保证完全正确，欢迎大家邮件联系作者进行相应的修改和交流。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Threadlocal使用场景？原理？如何保证内存不泄露？"><a href="#Threadlocal使用场景？原理？如何保证内存不泄露？" class="headerlink" title="Threadlocal使用场景？原理？如何保证内存不泄露？"></a>Threadlocal使用场景？原理？如何保证内存不泄露？</h2><h3 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h3><p>不加锁的情况下，多线程安全访问共享变量，每个线程保留共享变量的副本（线程特有对象），每个线程往这个ThreadLocal中读写是线程隔离。</p><h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p>Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个自己的ThreadLocalMap。<br>ThreadLocal的get\set\remove方法均先找出当前线程的ThreadLocalMap，然后执行ThreadLocalMap的get\set\remove，每个线程调用ThreadLocal的get\set\remove方法时，均在本线程对象的ThreadLocalMap中操作，所以实现了线程隔离。</p><p>ThreadLocalMap不是传统意义上的map，它其实是一个环形数组，数据元素entry是ThreadLocal变量的弱引用，而这个entry中有个变量为value是ThreadLocal变量的实际引用值，这样看起来是一个key-value的形式。<br>Entry便是ThreadLocalMap里定义的节点，它继承了WeakReference类，定义了一个类型为Object的value，用于存放塞到ThreadLocal里的值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference&lt;java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;<br>    <span class="hljs-comment">// 往ThreadLocal里实际塞入的值</span><br>    <span class="hljs-type">Object</span> value;<br><br>    <span class="hljs-type">Entry</span>(java.lang.<span class="hljs-type">ThreadLocal</span>&lt;?&gt; k, <span class="hljs-type">Object</span> v) &#123;<br>        <span class="hljs-keyword">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么用弱引用？因为如果这里使用普通的key-value形式来定义存储结构，实质上就会造成节点的生命周期与线程强绑定，只要线程没有销毁，那么节点在GC分析中一直处于可达状态，没办法被回收，而程序本身也无法判断是否可以清理节点。弱引用是Java中四档引用的第三档，比软引用更加弱一些，如果一个对象没有强引用链可达，那么一般活不过下一次GC。当某个ThreadLocal已经没有强引用可达，则随着它被垃圾回收，在ThreadLocalMap里对应的Entry的键值会失效，这为ThreadLocalMap本身的垃圾清理提供了便利。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重新分配表大小的阈值，默认为0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> threshold; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Entry表，大小必须为2的幂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Entry<span class="hljs-literal">[]</span> table;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置resize阈值以维持最坏2/3的装载因子</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> void set<span class="hljs-constructor">Threshold(<span class="hljs-params">int</span> <span class="hljs-params">len</span>)</span> &#123;<br>    threshold = len<span class="hljs-operator"> * </span><span class="hljs-number">2</span><span class="hljs-operator"> / </span><span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 环形意义的下一个索引</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> static <span class="hljs-built_in">int</span> next<span class="hljs-constructor">Index(<span class="hljs-params">int</span> <span class="hljs-params">i</span>, <span class="hljs-params">int</span> <span class="hljs-params">len</span>)</span> &#123;<br>    return ((i + <span class="hljs-number">1</span> &lt; len) ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 环形意义的上一个索引</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> static <span class="hljs-built_in">int</span> prev<span class="hljs-constructor">Index(<span class="hljs-params">int</span> <span class="hljs-params">i</span>, <span class="hljs-params">int</span> <span class="hljs-params">len</span>)</span> &#123;<br>    return ((i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ? i - <span class="hljs-number">1</span> : len - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal需要维持一个最坏2&#x2F;3的负载因子，ThreadLocal有两个方法用于得到上一个&#x2F;下一个索引，注意这里实际上是环形意义下的上一个与下一个。由于ThreadLocalMap使用线性探测法来解决散列冲突，所以实际上Entry[]数组在程序逻辑上是作为一个环形存在的。hreadLocalMap维护了Entry环形数组，数组中元素Entry的逻辑上的key为指向该ThreadLocal对象的弱引用，value为代码中该线程往该ThreadLoacl变量实际塞入的值。</p><p><img src="/2023/02/23/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%B6%E4%BB%96/threadlocal%E7%8E%AF%E5%BD%A2%E5%88%97%E8%A1%A8.png" alt="threadlocal环形列表"></p><p>执行ThreadLocalMap的get\set方法和扩容时，当发现有entry的弱引用为null时（因为entry是ThreadLocal的弱引用，所以如果没有其他强引用使用时就会被清理），会将无效的entry去掉，顺便做一些启发式的清理，所以大部分失效的entry一般都是可以清理的。但是这样清理终究是有漏网之鱼的，所以需要使用remove方法来避免这种情况的发生，remove方法直接在table中找key，如果找到了，把弱引用断掉并做一次段清理，这样可以避免无效entry的残留。</p><h3 id="关于内存泄漏"><a href="#关于内存泄漏" class="headerlink" title="关于内存泄漏"></a>关于内存泄漏</h3><p>之所以有关于内存泄露的讨论是因为在有线程复用如线程池的场景中，一个线程的寿命很长，大对象长期不被回收影响系统运行效率与安全。如果线程不会复用，用完即销毁了也不会有ThreadLocal引发内存泄露的问题。<br>只有在get的时候才会第一次创建初始值，所以用完后使用remove，可以将这个entry去掉，下次get还会重新加载，这样避免了内存泄漏。<br>Get和set方法执行时，偶尔发现无效entry后做段清理，可能清理不完全，导致可能存在大对象滞留。<br>如果在使用的ThreadLocal的过程中，显式地进行remove是个很好的编码习惯，这样是不会引起内存泄漏。</p><h3 id="为什么Entry数组大小必须为2的幂"><a href="#为什么Entry数组大小必须为2的幂" class="headerlink" title="为什么Entry数组大小必须为2的幂?"></a>为什么Entry数组大小必须为2的幂?</h3><p>这和hash函数相关，基于ThreadLocal特有的hash函数，可以使entry在Entry数组上均匀分布，减少hash冲突。</p><h3 id="Hash冲突的处理"><a href="#Hash冲突的处理" class="headerlink" title="Hash冲突的处理"></a>Hash冲突的处理</h3><p>ThreadLocalMap使用线性探测法来解决散列冲突，所以实际上Entry[]数组在程序逻辑上是作为一个环形存在的。注意如果删除一个节点后，需要将后面的节点重新hash。</p><p>参考：<br><a href="https://www.cnblogs.com/lllliuxiaoxia/p/15683558.html">Thread local原理梳理</a><br><a href="https://www.cnblogs.com/micrari/p/6790229.html">ThreadLocal源码解读</a></p><h2 id="了解死锁么？怎么防止死锁？"><a href="#了解死锁么？怎么防止死锁？" class="headerlink" title="了解死锁么？怎么防止死锁？"></a>了解死锁么？怎么防止死锁？</h2><h3 id="死锁的产生条件"><a href="#死锁的产生条件" class="headerlink" title="死锁的产生条件"></a>死锁的产生条件</h3><p>资源互斥，每个资源一次只能被一个线程持有<br>资源不可抢夺<br>占用并等待资源，涉及的线程当前至少持有一个资源并申请其他资源，而这些资源恰好被其他线程持有<br>循环等待资源</p><h3 id="死锁的排查"><a href="#死锁的排查" class="headerlink" title="死锁的排查"></a>死锁的排查</h3><p>Jstack、arthas、jvisualvm 直接检查</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li>已经产生</li></ul><p>重启</p><ul><li>修复</li></ul><p>锁粗法，用一个粗粒度的锁代替原来多个细粒度的锁，这样每个线程只申请一个锁，避免了死锁。但是这个方法会导致资源浪费。避免了“循环等待资源”的必要条件。<br>锁排序法，相关线程使用全局统一的顺序申请锁，消除“循环等待资源”的必要条件，比如一个对象方法要申请两个锁，先申请hashcode值小的那个锁，然后再申请hashcode值大的那个锁。“循环等待资源”实际为每个对象使用局部顺序去申请锁，如果依赖全局统一的顺序，即可消除“循环等待资源”的必要条件。<br>ReentrantLock.tryLock(long, TimeUnit)，为申请锁这个操作指定一个超时时间，避免了“占用并等待资源”的必要条件。<br>不用锁。</p><p>参考:<br><a href="https://www.cnblogs.com/lllliuxiaoxia/p/15689367.html">死锁问题整理</a><br>《Java多线程编程实战指南》黄文海</p><h2 id="Java安全的阻塞队列有哪些？分别提供了什么功能？"><a href="#Java安全的阻塞队列有哪些？分别提供了什么功能？" class="headerlink" title="Java安全的阻塞队列有哪些？分别提供了什么功能？"></a>Java安全的阻塞队列有哪些？分别提供了什么功能？</h2><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><p>多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时concurrent包出现了，而他也给我们带来了强大的BlockingQueue。</p><h3 id="阻塞队列的方法"><a href="#阻塞队列的方法" class="headerlink" title="阻塞队列的方法"></a>阻塞队列的方法</h3><p><img src="/2023/02/23/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%B6%E4%BB%96/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="阻塞队列的方法"></p><p>核心方法如下：</p><ul><li>放入数据</li></ul><p>（1）offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）；<br>（2）offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败。<br>（3）put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.</p><ul><li>获取数据</li></ul><p>（1）poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null;<br>（2）poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。<br>（3）take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入;<br>（4）drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p><h3 id="常见阻塞队列"><a href="#常见阻塞队列" class="headerlink" title="常见阻塞队列"></a>常见阻塞队列</h3><p><img src="/2023/02/23/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%B6%E4%BB%96/%E5%B8%B8%E8%A7%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt="常见阻塞队列"></p><ul><li>ArrayBlockingQueue</li></ul><p>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。<br>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue，可能导致锁的高争用，进而导致较多的上下文切换；<br>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。ArrayBlockingQueue不会增加GC负担，这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p><ul><li>LinkedBlockingQueue</li></ul><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p><ul><li>SynchronousQueue</li></ul><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。<br>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:<br>如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；<br>但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p><ul><li>DelayQueue</li></ul><p>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br>使用场景：DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。</p><ul><li>PriorityBlockingQueue</li></ul><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p><ul><li>对比</li></ul><p>ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列。<br>是否有界:<br>ArrayBlockingQueue是有界队列， LinkedBlockingQueue既可以有界也可以无界<br>调度:<br>LinkedBlockingQueue仅支持非公平调度<br>ArrayBlockingQueue和SynchronousQueue支持公平和非公平调度<br>适用场景:<br>LinkedBlockingQueue适合生产者和消费者线程并发程度较大的场景；<br>ArrayBlockingQueue适合生产者和消费者线程并发程度较低的场景；<br>SynchronousQueue适合生产者和消费者处理能力相差不大的场景。</p><p>参考：<br><a href="https://www.cnblogs.com/lllliuxiaoxia/p/15724940.html">阻塞队列、线程池、异步</a><br><a href="https://www.cnblogs.com/aspirant/p/8657801.html">BlockingQueue（阻塞队列）详解</a></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><p>线程工厂可以统一线程生成的样式，增加线程异常处理对象、定制线程名称等。</p><h3 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3><p>线程启动会产生相应的线程调度开销，线程的销毁也有开销，通过线程池来使用线程更加有效，避免不必要的反复创建线程的开销，同时可以方便实现任务提交与任务调度执行的功能分离。<br>线程池预先创建一定数目的工作者线程，客户端不需要向线程池借用线程而是将其需要执行的任务作为一个对象提交给线程池，线程池可能将这些任务缓存在队列之中，而线程池内部的各个工作者线程则不断取出任务并执行之。因此，线程池可以看做基于生产者—消费者模式的一种服务。</p><h3 id="基本参数和原理"><a href="#基本参数和原理" class="headerlink" title="基本参数和原理"></a>基本参数和原理</h3><p>ThreadPoolExecutor类是一个常用的线程池，客户端可以调用ThreadPoolExecutor.submit方法提交任务。Task如果是一个Runnable实例，没有返回结果，Task如果是Callable实例，可以由返回结果。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Public</span> Future&lt;?&gt; submit(Runnable <span class="hljs-keyword">task</span>); <br><span class="hljs-keyword">Public</span> Future&lt; T &gt; submit(Callable&lt;T&gt; <span class="hljs-keyword">task</span>);<br></code></pre></td></tr></table></figure><p>通过submit向线程池提交Runnable 或 Callable<T> 任务后，任务都会被转化为FutureTask然后提交给execute方法。</T></p><p>关于线程池线程数量有三个概念，当前线程池大小表示线程池中实际工作者线程的数量；最大线程池大小表示线程池中允许存在的工作者线程的数量上限；核心线程大小表示一个不大于最大线程池大小的工作者线程数量上限。<br>三个线程池线程概念的关系如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">当前线程池大小&lt;<span class="hljs-operator">=</span>核心线程大小&lt;<span class="hljs-operator">=</span>最大线程池大小<br>或者<br>核心线程大小&lt;<span class="hljs-operator">=</span>当前线程池大小&lt;<span class="hljs-operator">=</span>最大线程池大小<br></code></pre></td></tr></table></figure><p>ThreadPoolExecutor最详尽的构造函数如下（还有很多简化的构造函数，部分入参可以采用默认值）：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                      <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                      TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                      ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                      RejectedExecutionHandler <span class="hljs-keyword">handler</span>)</span> </span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>corePoolSize：线程池核心大小<br>maximumPoolSize：最大线程池大小<br>keepAliveTime和unit指定线程池中空闲线程的最大存活时间<br>workQueue: 称为工作队列的阻塞队列<br>threadFactory：指定创建工作者线程的线程工厂<br>handler：线程拒绝策略</p><p>初始状态下，客户端每提交一个任务线程池就创建一个工作者线程来处理任务。随着任务的提交，当前线程池大小相应增加，在当前线程池大小达到核心线程池大小是，新来的任务被存入到工作队列之中。这些缓存的任务由线程池种所有的工作者线程负责取出进行执行。线程池将任务放入工作队列的时候调用的是BlockingQueue的非阻塞方法offer（E e），所以当工作队列满的时候不会使提交任务的客户端线程暂停。当工作队列满的时候，线程池会继续创建新的工作者线程，直到当前线程池大小达到最大线程池大小。</p><p>在当前线程池大小超过核心线程池大小的时候，超过核心线程池大小部分的工作者线程空闲（即工作者队列中没有待处理的任务）时间达到了keepAliveTime所指定的时间后就会被清理掉，即这些工作者线程会自动终止并被从线程池中被移除，需要谨慎设置，否则造成线程反复创建。</p><p>线程池是通过threadFactory的newThread方法来创建工作者线程的。如果在创建线程池的时候没有指定线程工厂（调用了ThreadPoolExecutor的其他构造器），那么ThreadPoolExecutor会使用Executord.defaultThreadFactory()所返回的默认线程工厂。</p><p>当线程池饱和的时候，即工作队列满且当前线程池大小达到最大线程池大小的情况下，客户端试图提交的任务就会被拒绝。RejectExecutionHandler接口用于封装被拒绝的任务的处理策略，ThreadPoolExecutor提供几个现成的RejectExecutionHandler的实现类，其中ThreadPoolExecutor.AbortPolicy是ThreadPoolExecutor使用的默认RejectExecutionHandler。如果默认的AbortPolicy无法满足可以优先考虑ThreadPoolExecutor提供的其他RejectExecutionHandler，其次考虑自行实现RejectExecutionHandler。<br>以下为拒绝策略<br>AbortPolicy：直接抛出异常，默认策略；<br>CallerRunsPolicy：用调用者所在的线程来执行任务；<br>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>DiscardPolicy：直接丢弃任务；</p><h3 id="线程池怎么设计核心线程数和最大线程数"><a href="#线程池怎么设计核心线程数和最大线程数" class="headerlink" title="线程池怎么设计核心线程数和最大线程数"></a>线程池怎么设计核心线程数和最大线程数</h3><p>暂时没有了解到最合理的线程设置原则。对于cpu核数为N的机器一般原则如下：cpu密集型程序可以设置核心线程为N+1，IO密集型程序可以设置核心线程为N*2。也可以参照《Java多线程编程实战指南》中的一些公式来计算核心线程数，可以设置最大线程数为核心线程数的2倍。</p><p>对于快速响应用户请求的需求，一般设置缓冲队列为同步队列，即不缓存任务，尽可能调高核心线程和最大线程，实现快速响应。对于批量处理的需求，一般会设置一定容量的缓冲队列，过多的线程可能导致频繁上下文切换，影响程序运行的吞吐量。</p><p>美团技术博客中也提到了传统线程池线程设置的困难，所以开发了一个线程池监控配置平台，用来实时监控线程池的负载，同时提供了实时变更线程池参数的界面。</p><h3 id="拒绝策略怎么选择？"><a href="#拒绝策略怎么选择？" class="headerlink" title="拒绝策略怎么选择？"></a>拒绝策略怎么选择？</h3><p>没有最佳实践，只有更适合自身业务的策略。现在我们聊聊各种策略的适用场景。</p><p>AbortPolicy 中止策略，线程池默认的拒绝策略，也是我们最常用的拒绝策略。当系统线程池满载的时候，可以通过异常的形式告知使用方，交由使用方自行处理。一般出现此异常时，我们可以提示用户稍后再试，或者我们把未执行的任务记录下来，等到适当时机再次执行。</p><p>DiscardPolicy 丢弃策略，一般我们都不会选择它，因为它直接就把任务丢弃掉了，我们毫无感知。如果任务不重要，丢弃掉也没有没关系，就可以使用它。还有一种情况，我们也可以使用它，我们事后知道哪些任务没有执行，说明任务是被丢弃了，需要重新执行。</p><p>DiscardOldestPolicy 丢弃最老任务策略，如果有这种业务场景：需要淘汰等待时间最长任务，就可以适用该策略。</p><p>CallerRunsPolicy 调用者执行策略。为了保证所有任务都能执行，可以使用该策略。但是它也隐藏着非常大的风险。</p><p>比如，我们在SpringWeb项目中，有一个web请求过来需要处理一个异步任务，正常情况下，我们是交由线程池来处理任务的，但是由于线程池满了，我们使用了CallerRunsPolicy策略，该异步任务就由web请求线程来处理。<br>看起来好像没有什么问题，但实际情况是，web请求已经使用了tomcat的线程池中的线程来处理的了，异步任务也交由该线程处理，此时的线程资源就被此次的web请求长久占用了。如果这样的web请求有很多，Tomcat的可用线程将会变得很少，这导致整个服务器的qps大大降低，甚至系统奔溃。<br>所以使用CallerRunsPolicy策略时，要站在更高的角度来评估，这会不会给系统带来其他问题！</p><h3 id="优雅关闭线程池"><a href="#优雅关闭线程池" class="headerlink" title="优雅关闭线程池"></a>优雅关闭线程池</h3><p>用shutdown + awaitTermination关闭线程池，如果检测线程池在指定时间范围内没有关闭，可以使用shutdownNow()来主动中断所有子线程。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">executeCallableCommand</span>(<span class="hljs-params">Callable&lt;T&gt; callable</span>)</span> &#123;<br>    ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>,<br>            TimeUnit.SECONDS, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">5</span>));<br>    Future&lt;T&gt; submit = threadPoolExecutor.submit(callable);<br>    threadPoolExecutor.shutdown();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(!threadPoolExecutor.awaitTermination(<span class="hljs-number">60</span>, TimeUnit.SECONDS))&#123;<br>            <span class="hljs-comment">// 超时的时候向线程池中所有的线程发出中断(interrupted)。</span><br>            threadPoolExecutor.shutdownNow();<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;AwaitTermination Finished&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;<br>        threadPoolExecutor.shutdownNow();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://www.cnblogs.com/slankka/p/11609615.html">Java线程池的正确关闭方法，awaitTermination还不够</a><br><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践</a><br><a href="https://juejin.cn/post/7090570473611722788">线程池拒绝策略最佳实践</a><br>《Java多线程编程实战指南》黄文海</p><h2 id="ConcurrenthashMap的put、get方法"><a href="#ConcurrenthashMap的put、get方法" class="headerlink" title="ConcurrenthashMap的put、get方法"></a>ConcurrenthashMap的put、get方法</h2><h3 id="jdk1-7的ConcurrenthashMap"><a href="#jdk1-7的ConcurrenthashMap" class="headerlink" title="jdk1.7的ConcurrenthashMap"></a>jdk1.7的ConcurrenthashMap</h3><p>jdk1.7的ConcurrenthashMap由多个Segment组合而成，Segment相当于一个HashMap对象。同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。可以说，ConcurrentHashMap是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-title">implements</span> <span class="hljs-title">Serializable</span></span><br></code></pre></td></tr></table></figure><p>Segment继承了ReentrantLock，所以在put中加锁的时候是以Segment为单元进行加锁的。</p><ul><li>put操作</li></ul><p>1、通过key首先定位到Segment，然后在Segment中进行put；<br>2、加锁操作（首先tryLock，如果没成功就自旋tryLock，如果还获取不到就lock阻塞获取）；<br>3、定位到Segment中特定的位置的HashEntry；<br>4、遍历该HashEntry，如果不为空则判断传入的key和当前遍历的key是否相等，相等则覆盖旧的value；<br>5、为空则需要新建一个HashEntry并加入到Segment中，同时会先判断是否需要扩容；<br>6、释放锁；</p><ul><li>get操作</li></ul><p>1、Key通过Hash之后定位到具体的Segment；<br>2、再通过一次Hash定位到具体的元素上；<br>3、遍历HashEntry，如果找到则返回对应的value，否则返回null。由于HashEntry中的value属性是用volatile关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p><h3 id="jdk1-8的ConcurrenthashMap"><a href="#jdk1-8的ConcurrenthashMap" class="headerlink" title="jdk1.8的ConcurrenthashMap"></a>jdk1.8的ConcurrenthashMap</h3><p>jdk1.8的ConcurrenthashMap的结构变得和jdk1.8的hashMap类似，取消了Segment结构，hash定位直接定位到某个Node上（1.8的元素由HashEntry改为了Node），在加锁的时候直接以Node为monitor加锁，加锁的粒度更细，且也有了长链表转红黑树的优化。</p><ul><li>put操作</li></ul><p>1、求出hash值<br>2、是否已经初始化数组，如果没有初始化，直接初始化<br>3、是否该位置为空，空的话直接cas设置第一个节点<br>4、判断是否正在扩容，如果正在扩容，就加入一起进行扩容<br>5、如果不为空的话，锁住头结点，开始进行插入操作，如果是链表，就遍历是否相同，如果是红黑树就直接添加<br>6、添加完成之后，判断是否需要扩容，如果超过阈值就扩容。</p><ul><li>get操作</li></ul><p>1、获取hash值<br>2、如果是第一个节点，直接返回<br>3、如果不是，判断是否正在扩容或者是红黑树，那就调用find方法<br>4、如果不是，那就是链表结构，直接while寻找。同样，node中的val是volatile，我们每次取出来的是最新的值，这里使用的是volatile的可见性。</p><ul><li>jdk1.8的ConcurrentHashMap是怎么保证线程安全的？</li></ul><p>1、CAS操作数据：sizectl的修改，扩容数值等修改使用cas保证数据修改的原子性。<br>2、synchronized互斥锁：put和扩容过程，使用synchronized保证线程只有一个操作，保证线程安全。<br>3、volatile修饰变量：table、sizeCtl等变量用volatile修饰，保证可见性</p><p>参考：<br><a href="https://mp.weixin.qq.com/s/fxKmlW1Qt9tHfd22tILE1Q">java 面试–concurrentHashMap</a><br><a href="https://blog.csdn.net/qq_29051413/article/details/107869427">深入浅出ConcurrentHashMap详解</a></p><h2 id="简述一下JMM，as-if-serial语义、happens-before模型？"><a href="#简述一下JMM，as-if-serial语义、happens-before模型？" class="headerlink" title="简述一下JMM，as-if-serial语义、happens-before模型？"></a>简述一下JMM，as-if-serial语义、happens-before模型？</h2><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>《Java虚拟机规范》中曾试图定义一种“Java内存模型”（Java Memory Model，JMM）来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C和C++等）直接使用物理硬件和操作系统的内存模型。因此，由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，所以在某些场景下必须针对不同的平台来编写程序。</p><h3 id="happens-before模型"><a href="#happens-before模型" class="headerlink" title="happens-before模型"></a>happens-before模型</h3><p>Happens-before模型描述了两个操作的执行顺序，happens-before模型保障JMM中的可见性和有序性问题。<br>从JDK 5开始，Java使用新的JSR-133内存模型，JSR-133使用happens-before的概念来阐述操作之间的内存可见性：在JMM中，如果一个操作执行的结果需要对另一个操作可见（两个操作既可以是在一个线程之内，也可以是在不同线程之间），那么这两个操作之间必须要存在happens-before关系：<br>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>线程启动规则：调用一个线程的start方法happens-before被启动的这个线程中的任意一个动作。<br>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</p><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>java单线程程序运行时并不是完全按照编码的代码顺序执行的，中间可能涉及到很多重排序等调整，但是最终的运行结果是和按照编码的代码顺序执行的一样，所以称为貌似串行语义。貌似串行语义只是从单线程程序的角度保证重排序后的运行结果不影响程序的正确性，它并不保证多线程环境下程序的正确性。</p><p>参考：<br>《Java多线程编程实战指南》黄文海<br><a href="https://mp.weixin.qq.com/s/uF4PSxItyyXLJ5VaO-kyLA">java 面试–多线程基本概念</a></p><h2 id="缓存的一致性协议是什么？"><a href="#缓存的一致性协议是什么？" class="headerlink" title="缓存的一致性协议是什么？"></a>缓存的一致性协议是什么？</h2><p>由于cpu的执行速度远远大于IO的速度，为了减少和IO的交互，增高效率，cpu内部会有高速缓存（cache）。当程序运行的时候，高速缓存中会从主存中保存一份副本数据。每次读写都在高速缓存中操作，这个在单线程下是没有问题的，但是多线程下会导致数据不一致的情况（其他线程中的数据没有同步该线程修改的数据）。为了解决这个问题（其实就是上图中可见性描述），通常有两种方案进行解决：锁和缓存一致性协议。由于在总线上加锁的机制导致效率低下，所以缓存一致性协议就变得关键了。具体原理是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><p>参考：<br><a href="https://mp.weixin.qq.com/s/uF4PSxItyyXLJ5VaO-kyLA">java 面试–多线程基本概念</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ">微信公众号:我的IT技术路</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;java多线程的线程安全、线程管理、线程活性等相关面试题目整理，面经尽量用简短的语句说明问题，详细的信息可以参考每个面经下的参考链接。面经不</summary>
      
    
    
    
    <category term="java" scheme="http://soatree.github.io/categories/java/"/>
    
    
    <category term="面试" scheme="http://soatree.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="多线程" scheme="http://soatree.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>八股文-java多线程-同步协作</title>
    <link href="http://soatree.github.io/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/"/>
    <id>http://soatree.github.io/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/</id>
    <published>2023-02-14T14:36:40.000Z</published>
    <updated>2023-02-24T14:26:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java多线程同步与协作相关面试题目整理，面经尽量用简短的语句说明问题，详细的信息可以参考每个面经下的参考链接。面经不保证完全正确，欢迎大家邮件联系作者进行相应的修改和交流。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Synchronized和ReentryLock"><a href="#Synchronized和ReentryLock" class="headerlink" title="Synchronized和ReentryLock"></a>Synchronized和ReentryLock</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁可以视作访问共享数据的许可证。锁能够保护共享数据以实现线程安全，其作用包括保障原子性、保障可见性和保障有序性。<br>Java平台中的锁包括内部锁（IntrinsicLock）和显式锁（ExplicitLock）。内部锁是通过synchronized关键字实现的；显式锁是通过java.util.concurrent.locks.Lock接口的实现类（如java.concurrent.locks.ReentrantLock类）实现的。synchronized在软件层面依赖JVM（jvm指令），而j.u.c.Lock在硬件层面依赖特殊的CPU指令。</p><h3 id="锁的调度"><a href="#锁的调度" class="headerlink" title="锁的调度"></a>锁的调度</h3><p>公平调度，多个线程申请锁的时候需要排队，先到先得，不允许插队，在线程任务执行时间较长的情况下使用公平调度效率更高，公平调度适合线程任务执行时间较长的场景；<br>非公平调度，多个线程申请锁的时候需要排队，但是允许插队，一般情况下效率更高；</p><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>Java平台中的任何一个对象都有唯一一个与之关联的锁。这种锁被称为监视器（Monitor）或者内部锁（IntrinsicLock）。内部锁是一种排他锁，它能够保障原子性、可见性和有序性。内部锁是通过synchronized关键字实现的。synchronized关键字可以用来修饰方法以及代码块（花括号“{}”包裹的代码）。<br>同步静态方法，锁为类对象；如果同步实例方法，锁为this，即当前对象实例；同步代码块的时候需要指定的锁句柄，作为锁句柄的变量通常采用final修饰<br>synchronized关键字申请锁和释放锁都是JVM代为实施，不需要手动操作，所以称为内部锁，内部锁是使用最方便的锁。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeCircularSeqGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CircularSeqGenerator</span> </span>&#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">short</span> sequence = <span class="hljs-number">-1</span>; <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">short</span> <span class="hljs-title">nextSequence</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sequence &gt;= <span class="hljs-number">999</span>) &#123;<br>            sequence = <span class="hljs-number">0</span>; <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            sequence++; <br>        &#125; <br>        <span class="hljs-keyword">return</span> sequence; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">short</span> <span class="hljs-title">nextSequence</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123; <br>        <span class="hljs-keyword">if</span> (sequence &gt;= <span class="hljs-number">999</span>) &#123; <br>            sequence = <span class="hljs-number">0</span>; <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            sequence++; <br>        &#125; <br>        <span class="hljs-keyword">return</span> sequence; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReentryLock"><a href="#ReentryLock" class="headerlink" title="ReentryLock"></a>ReentryLock</h3><p>显示锁最常用的是ReentrantLock，需要创建一个ReentrantLock对象lock，并且在同步代码前插入<code>lock.lock()</code>，在同步代码后插入<code>lock.unlock()</code>;，注意<code>lock.unlock();</code>需要放在finally里中，避免锁泄露；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>(); <span class="hljs-comment">// 申请锁lock </span><br><span class="hljs-keyword">try</span>&#123; <br>    <span class="hljs-comment">// 在此对共享数据进行访问 </span><br>    …… <br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">// 总是在finally块中释放锁，以避免锁泄漏 </span><br>    <span class="hljs-keyword">lock</span>.unlock(); <span class="hljs-comment">// 释放锁lock </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>两者都是可重入锁。内部锁只支持非公平调度，ReentrantLock同时支持公平和非公平调度。<br>内部锁和ReentrantLock两者性能接近，内部锁使用简单，ReentrantLock使用复杂，需要手动释放锁。一般情况下使用synchronized内部锁即可，如果需要使用更加复杂的线程协作或者需要公平调度等时候可以考虑使用ReentrantLock。</p><p>参考：<br>《Java多线程编程实战指南》黄文海<br><a href="https://www.cnblogs.com/lllliuxiaoxia/p/15775069.html">java多线程基础 </a></p><h2 id="内存屏障？Java是怎么实现原子性，有序性，可见性呢"><a href="#内存屏障？Java是怎么实现原子性，有序性，可见性呢" class="headerlink" title="内存屏障？Java是怎么实现原子性，有序性，可见性呢?"></a>内存屏障？Java是怎么实现原子性，有序性，可见性呢?</h2><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>内存屏障是对一类仅针对内存读、写操作指令（Instruction）的跨处理器架构（比如x86、ARM）的比较底层的抽象（或者称呼）。内存屏障是被插入到两个指令之间进行使用的，其作用是禁止编译器、处理器重排序从而保障有序性。它在指令序列（如指令1；指令2；指令3）中就像是一堵墙（因此被称为屏障）一样使其两侧（之前和之后）的指令无法“穿越”它（一旦穿越了就是重排序了）。但是，为了实现禁止重排序的功能，这些指令也往往具有一个副作用——刷新处理器缓存、冲刷处理器缓存，从而保证可见性。不同微架构的处理器所提供的这样的指令是不同的，并且出于不同的目的使用的相应指令也是不同的。</p><p>按照可见性保障来划分，内存屏障可分为加载屏障（LoadBarrier）和存储屏障（StoreBarrier）。加载屏障的作用是刷新处理器缓存，存储屏障的作用冲刷处理器缓存。</p><p>按照有序性保障来划分，内存屏障可以分为获取屏障（AcquireBarrier）和释放屏障（ReleaseBarrier）。获取屏障的使用方式是在一个读操作（包括Read-Modify-Write以及普通的读操作）之后插入该内存屏障，其作用是禁止该读操作与其后的任何读写操作之间进行重排序，这相当于在进行后续操作之前先要获得相应共享数据的所有权（这也是该屏障的名称来源）。释放屏障的使用方式是在一个写操作之前插入该内存屏障，其作用是禁止该写操作与其前面的任何读写操作之间进行重排序。这相当于在对相应共享数据操作结束后释放所有权（这也是该屏障的名称来源）。</p><h3 id="内部锁中内存屏障的使用"><a href="#内部锁中内存屏障的使用" class="headerlink" title="内部锁中内存屏障的使用"></a>内部锁中内存屏障的使用</h3><p>由于内部锁的申请与释放对应的Java虚拟机字节码指令分别是monitorenter和monitorexit，因此习惯上我们用MonitorEnter表示锁的申请，用MonitorExit表示锁的释放。</p><p>Java虚拟机会在MonitorExit（释放锁）对应的机器码指令之后插入一个存储屏障，这就保障了写线程在释放锁之前在临界区中对共享变量所做的更新对读线程的执行处理器来说是可同步的；相应地，Java虚拟机会在MonitorEnter（申请锁）对应的机器码指令之后临界区开始之前的地方插入一个加载屏障，这使得读线程的执行处理器能够将写线程对相应共享变量所做的更新从其他处理器同步到该处理器的高速缓存中。</p><p>Java虚拟机会在MonitorEnter（它包含了读操作）对应的机器码指令之后临界区开始之前的地方插入一个获取屏障，并在临界区结束之后MonitorExit（它包含了写操作）对应的机器码指令之前的地方插入一个释放屏障。因此，这两种屏障就像是三明治的两层面包片把火腿夹住一样把临界区中的代码（指令序列）包括起来。由于获取屏障禁止了临界区中的任何读、写操作被重排序到临界区之前的可能性，而释放屏障又禁止了临界区中的任何读、写操作被重排序到临界区之后的可能性，因此临界区内的任何读、写操作都无法被重排序到临界区之外。在锁的排他性的作用下，这使得临界区中执行的操作序列具有原子性。因此，写线程在临界区中对各个共享变量所做的更新会同时对读线程可见，即在读线程看来各个共享变量就像是“一下子”被更新的，于是这些线程无从（也无必要）区分这些共享变量是以何种顺序被更新的。这使得写线程在临界区中执行的操作自然而然地具有有序性——读线程对这些操作的感知顺序与源代码顺序一致。</p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E5%9C%A8%E9%94%81%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt="内存屏障在锁中的使用"></p><h3 id="Java内部锁是怎么实现原子性，有序性，可见性呢"><a href="#Java内部锁是怎么实现原子性，有序性，可见性呢" class="headerlink" title="Java内部锁是怎么实现原子性，有序性，可见性呢?"></a>Java内部锁是怎么实现原子性，有序性，可见性呢?</h3><p>临界区中执行操作序列的原子性由锁的排他性实现。<br>锁对可见性的保障是通过写线程和读线程成对地使用存储屏障和加载屏障实现的。<br>锁对有序性的保障是通过写线程和读线程配对使用释放屏障与获取屏障屏障实现的。</p><p>参考：<br>《Java多线程编程实战指南》黄文海</p><h2 id="Volatile的作用是什么？底层是怎么实现的？"><a href="#Volatile的作用是什么？底层是怎么实现的？" class="headerlink" title="Volatile的作用是什么？底层是怎么实现的？"></a>Volatile的作用是什么？底层是怎么实现的？</h2><p>volatile关键字用于修饰共享可变变量，即没有使用final关键字修饰的实例变量或静态变量，相应的变量就被称为volatile变量。volatile可以保障可见性、保障有序性和保障long&#x2F;double型变量读写操作的原子性。</p><p>可见性和有序性由内存屏障保障：</p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/volatile%E5%8F%98%E9%87%8F%E5%86%99%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="volatile变量写操作与内存屏障"></p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/volatile%E5%8F%98%E9%87%8F%E8%AF%BB%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" alt="volatile变量读操作与内存屏障"></p><p>注意：</p><p>volatile仅仅保障对其修饰的变量的写操作（以及读操作）本身的原子性，而这并不表示对volatile变量的赋值操作一定具有原子性。</p><p>volatile关键字在可见性方面仅仅是保证读线程能够读取到共享变量的相对新值。对于引用型变量和数组变量，volatile关键字并不能保证读线程能够读取到相应对象的字段（实例变量、静态变量）、元素的相对新值。</p><p>参考：<br>《Java多线程编程实战指南》黄文海</p><h2 id="Java的CAS是怎么实现的？Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别？"><a href="#Java的CAS是怎么实现的？Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别？" class="headerlink" title="Java的CAS是怎么实现的？Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别？"></a>Java的CAS是怎么实现的？Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别？</h2><h3 id="Java的CAS是怎么实现的"><a href="#Java的CAS是怎么实现的" class="headerlink" title="Java的CAS是怎么实现的"></a>Java的CAS是怎么实现的</h3><p>CAS（CompareandSwap）是对一种处理器指令（例如x86处理器中的cmpxchg指令）的称呼。</p><p>原子变量类（Atomics）通常是借助一个volatile变量基于CAS实现的能够保障对共享变量进行read-modify-write更新操作的原子性和可见性的一组工具类。关于CAS的操作都是基于Unsafe类中的一些方法实现的，这些方法对处理器的CAS指令进行了包装。</p><h3 id="简单分析下Atmoicinteger"><a href="#简单分析下Atmoicinteger" class="headerlink" title="简单分析下Atmoicinteger"></a>简单分析下Atmoicinteger</h3><p>主要看下getAndIncrement方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> U.<span class="hljs-title">getAndAddInt</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, VALUE, <span class="hljs-number">1</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的U是<code>private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</code>，是unsafe对象</p><p>AtomicInteger中用value来实际存储值</p><p><code>private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, &quot;value&quot;);</code>，VALUE是value属性的内存地址位置较AtomicInteger对象内存地址位置的偏移量，所以<code>U.getAndAddInt(this, VALUE, 1);</code>中通过this和VALUE可以直接定位到value的内存地址位置。</p><p>再看getAndAddInt方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final <span class="hljs-built_in">int</span> get<span class="hljs-constructor">AndAddInt(Object <span class="hljs-params">o</span>, <span class="hljs-params">long</span> <span class="hljs-params">offset</span>, <span class="hljs-params">int</span> <span class="hljs-params">delta</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = get<span class="hljs-constructor">IntVolatile(<span class="hljs-params">o</span>, <span class="hljs-params">offset</span>)</span>;<br>    &#125; <span class="hljs-keyword">while</span> (!weak<span class="hljs-constructor">CompareAndSetInt(<span class="hljs-params">o</span>, <span class="hljs-params">offset</span>, <span class="hljs-params">v</span>, <span class="hljs-params">v</span> + <span class="hljs-params">delta</span>)</span>);<br>    return v;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先基于value的内存地址位置获取它的当前值，然后尝试CAS对value增加delta，如果成功则返回原value值，否则重复以上操作直到成功。</p><h3 id="Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别"><a href="#Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别" class="headerlink" title="Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别"></a>Atomic包中的Atmoicinteger和AtmoicintegerFiledUpdater区别</h3><p>两者使用对比：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerFieldUpdaterDemo</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Candidate</span> &#123;<br>        <span class="hljs-built_in">int</span> id;<br> <br>        <span class="hljs-keyword">volatile</span> <span class="hljs-built_in">int</span> score = <span class="hljs-number">0</span>;<br> <br>        AtomicInteger score2 = <span class="hljs-keyword">new</span> AtomicInteger();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> final AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater =<br>            AtomicIntegerFieldUpdater.newUpdater(Candidate.<span class="hljs-keyword">class</span>, <span class="hljs-string">&quot;score&quot;</span>);<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AtomicInteger realScore = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>        final Candidate candidate = <span class="hljs-keyword">new</span> Candidate();<br>        Thread[] t = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">10000</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            t[i] = <span class="hljs-keyword">new</span> Thread() &#123;<br>                @Override<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>                    <span class="hljs-keyword">if</span> (Math.random() &gt; <span class="hljs-number">0.4</span>) &#123;<br>                        candidate.score2.incrementAndGet();<br>                        scoreUpdater.incrementAndGet(candidate);<br>                        realScore.incrementAndGet();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            t[i].start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            t[i].<span class="hljs-keyword">join</span>();<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;AtomicIntegerFieldUpdater Score=&quot;</span> + candidate.score);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;AtomicInteger Score=&quot;</span> + candidate.score2.<span class="hljs-keyword">get</span>());<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;realScore=&quot;</span> + realScore.<span class="hljs-keyword">get</span>());<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出台如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">AtomicIntegerFieldUpdater <span class="hljs-attribute">Score</span>=6003<br>AtomicInteger <span class="hljs-attribute">Score</span>=6003<br><span class="hljs-attribute">realScore</span>=6003<br></code></pre></td></tr></table></figure><p>通过上述代码我们不难得知使用AtomicIntegerFieldUpdater与AtomicInteger其实效果是一致的，那既然已经存在了AtomicInteger并发之神又要写一个AtomicIntegerFieldUpdater呢？</p><p>1.从AtomicIntegerFieldUpdaterDemo代码中我们不难发现，通过AtomicIntegerFieldUpdater更新score我们获取最后的int值时相较于AtomicInteger来说不需要调用get()方法！<br>2.对于AtomicIntegerFieldUpdaterDemo类的AtomicIntegerFieldUpdater是static final类型也就是说即使创建了100个对象AtomicIntegerField也只存在一个不会占用对象的内存，但是AtomicInteger会创建多个AtomicInteger对象，占用的内存比AtomicIntegerFieldUpdater大，所以对于熟悉dubbo源码的人都知道，dubbo有个实现轮询负载均衡策略的类AtomicPositiveInteger用的就是AtomicIntegerFieldUpdater。</p><p>参考：<br>《Java多线程编程实战指南》黄文海<br><a href="https://blog.csdn.net/qq_23536449/article/details/103880340">AtomicIntegerFieldUpdater与AtomicInteger使用引发的思考</a></p><h2 id="sleep和wait的区别？notify和notifyall的区别是啥？"><a href="#sleep和wait的区别？notify和notifyall的区别是啥？" class="headerlink" title="sleep和wait的区别？notify和notifyall的区别是啥？"></a>sleep和wait的区别？notify和notifyall的区别是啥？</h2><h3 id="wait-notify-notifyall基本用法"><a href="#wait-notify-notifyall基本用法" class="headerlink" title="wait\notify\notifyall基本用法"></a>wait\notify\notifyall基本用法</h3><p>wait模板</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">synchronized</span>(someObject)&#123;<br>  <span class="hljs-built_in">while</span>(保护条件不成立)（<br>  someObject<span class="hljs-selector-class">.wait</span>();<br>）<br>doAction;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<br>保护条件需要循环判断，防止在获取锁的时候，保护条件又不成立，内部锁支持非公平调度，可能有插队将保护条件给修改了，这是需要让线程重新等待。</p><p>notify模板</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">synchronized</span>(someObject)&#123;<br>  <span class="hljs-built_in">updateShareState</span>();<br>  someObject<span class="hljs-selector-class">.notify</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<br>notify()需要尽可能放在临界区的结束的地方，否则被唤醒线程可能拿不到锁(被其他线程抢占)，导致上下文切换。</p><p>开销和问题:<br>Notifyall（）过早唤醒，保护条件还没有成立就被唤醒，可以利用显示锁的Condition接口来解决，实现分组唤醒；</p><p>notify()和notifyall():<br>只有在特定条件下采用notify()，否则都用notifyall()：<br>条件1：一次通知只唤醒一个线程；条件2：线程同质</p><h3 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h3><p>这两个方法来自不同的类，sleep()是Thread的静态方法，wait()是Object的实例方法；<br>sleep方法没有释放锁，而wait方法释放了锁;<br>wait，notify和notifyAll的调用需要放在同一个对象所引导的临界区中，而sleep可以在任何地方使用;<br>sleep到时间会自动恢复。wait必须使用notify或者是notifyall进行唤醒;<br>Wait通常被用于线程间交互&#x2F;通信，sleep通常被用于暂停执行。</p><p>参考：<br>《Java多线程编程实战指南》黄文海<br><a href="https://zhuanlan.zhihu.com/p/86717279">java多线程中sleep和wait的4个区别，你知道几个？</a><br><a href="https://blog.csdn.net/qq_42787645/article/details/101326366">wait()和sleep()方法的区别</a></p><h2 id="await-x2F-signal-x2F-signalAll-x2F-condition"><a href="#await-x2F-signal-x2F-signalAll-x2F-condition" class="headerlink" title="await&#x2F;signal&#x2F;signalAll&#x2F;condition"></a>await&#x2F;signal&#x2F;signalAll&#x2F;condition</h2><p>Condition接口可作为wait&#x2F;notify的替代品来实现等待&#x2F;通知，它为解决过早唤醒问题提供了支持，并解决了Object.wait(long)不能区分其返回是否是由等待超时而导致的问题。<br>Lock.newCondition()的返回值就是一个Condition实例，因此调用任意一个显式锁实例的newCondition方法可以创建一个相应的Condition接口。Object.wait()&#x2F;notify()要求其执行线程持有这些方法所属对象的内部锁，类似地，Condition.await()&#x2F;signal()也要求其执行线程持有创建该Condition实例的显式锁。<br>通过condition，可以将等待线程分组并进行分组唤醒。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionUsage</span> &#123;<br>    <span class="hljs-keyword">private</span> final Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> final Condition condition = <span class="hljs-keyword">lock</span>.newCondition();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aGuaredMethod</span>() throws InterruptedException</span> &#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (保护条件不满足) &#123;<br>                condition.<span class="hljs-keyword">await</span>();<br>            &#125;<br>            <span class="hljs-comment">// 执行目标动作 </span><br>            doAction();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAction</span>()</span> &#123;<br>        <span class="hljs-comment">// ... </span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anNotificationMethod</span>() throws InterruptedException</span> &#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 更新共享变量 </span><br>            changeState();<br>            condition.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeState</span>()</span> &#123;<br>        <span class="hljs-comment">// ... </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Condition.awaitUntil(Date)返回值true表示进行的等待尚未达到最后期限，即此时方法的返回是由于其他线程执行了相应条件变量的signal&#x2F;signalAll方法。</p><p>参考：<br>《Java多线程编程实战指南》黄文海</p><h2 id="synchronized原理？锁升级？"><a href="#synchronized原理？锁升级？" class="headerlink" title="synchronized原理？锁升级？"></a>synchronized原理？锁升级？</h2><p>JDK1.5之前synchronized是一个重量级锁，不过，随着Javs SE 1.6对synchronized进行的各种优化后，性能上synchronized和显示锁相差不大，不过显示锁的功能更为强大，且显示锁的读写锁在特定场景性能提升明显。</p><h3 id="synchronized基本原理"><a href="#synchronized基本原理" class="headerlink" title="synchronized基本原理"></a>synchronized基本原理</h3><p>j.u.c.Lock在硬件层面依赖特殊的CPU指令实现同步，synchronized是在软件层面依赖JVM（jvm指令）实现同步，编译后可以看到实际靠monitorenter和monitorexit指令来实现同步。</p><p>monitorenter：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：<br>1）如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者，如果同一个线程反复重入则反复加1；<br>2）如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；<br>3）如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；<br>monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。</p><p>其实wait&#x2F;notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait&#x2F;notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><p>与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的。ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表（ 每个等待锁的线程都会被封装成ObjectWaiter对象 ），_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时：<br>1）首先会进入 _EntryList 集合，当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1；<br>2）若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒；<br>3）若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)；</p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/monitor.png" alt="monitor"></p><h3 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h3><p>JDK1.6对synchronized的实现机制进行了较大调整，包括锁升级、锁消除、锁粗化等优化策略，使得synchronized性能极大提高。锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁升级指锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。在JDK1.6中默认是开启偏向锁和轻量级锁的。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。引入偏向锁是为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令。偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁&#x2F;解锁流程。</p><p>如果一个线程A持有偏向锁，线程B来竞争，如果线程B通过CAS竞争失败，则在安全点偏向锁升级为轻量级锁。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>因为重量级锁会导致线程上下文切换，所以偏向锁不会直接升级到重量级锁，而是会升级到轻量级锁的状态。<br>在轻量锁的状态下，线程间通过自旋加CAS的方式来竞争锁，如果可以很快获得锁资源，这样的开销比较小，如果自旋一定次数后仍然无法竞争到锁，此时轻量级锁升级为重量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>Synchronized是通过对象内部的一个叫做监视器锁（Monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “重量级锁”。“重量级锁”才是我们平时以为的同步锁。</p><h3 id="synchronized其他优化"><a href="#synchronized其他优化" class="headerlink" title="synchronized其他优化"></a>synchronized其他优化</h3><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>为了保证数据的完整性，在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。<br>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</p><p>参考：<br>《Java多线程编程实战指南》黄文海<br><a href="https://www.cnblogs.com/lllliuxiaoxia/p/15711549.html">synchronized原理</a></p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h3><p>AbstractQueuedSynchronizer（AQS），抽象的队列式的同步器。AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程同步队列，多线程争用资源被阻塞时线程被封装成Node加入这个队列中。AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）。<br>AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch，这些同步类内部都有具体的自定义同步器，这些同步器继承了AQS，不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。<br>自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。<br>这些方式不需要都实现，一般实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。</li></ul><h3 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h3><p>AQS使用时比较核心的方法是acquire-release、acquireShared-releaseShared。</p><ul><li>acquire(int)</li></ul><p>ReentrantLock的lock方法，内部其实就是调用的acquire(1)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public final void acquire(<span class="hljs-built_in">int</span> arg) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">arg</span>)</span><span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">        </span>acquire<span class="hljs-constructor">Queued(<span class="hljs-params">addWaiter</span>(Node.EXCLUSIVE)</span>, arg))<br>        self<span class="hljs-constructor">Interrupt()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）；<br>如果直接通过tryAcquire()获取资源失败，addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；<br>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false；<br>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/AQS-acquire.png" alt="tryAcquire"></p><ul><li>release(int)</li></ul><p>ReentrantLock的unlock方法，内部其实就是调用的release(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>tryRelease()释放资源，自义定同步器在实现时，如果已经彻底释放资源(state&#x3D;0)，要返回true，否则返回false。<br>如果资源彻底释放了（即state&#x3D;0）,unparkSuccessor()会唤醒等待队列里的其他线程来获取资源</p><p>acquireShared()和releaseShared()类似，不同的是acquireShared()中一个线程拿到资源后如果有剩余资源还会去唤醒后继线程，releaseShared()在释放部分资源后就会唤醒后继线程，不需要完全释放资源。</p><h3 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h3><p>内部的Sync继承AQS，而Sync有两个子类分别为NonfairSync和FairSync，分别对应非公平锁和公平锁的Sync，Sync重写了AQS的tryAcquire和tryRelease等方法。针对公平或不公平的需求，会将Sync设置为NonfairSync或FairSync。<br>ReentrantLock在调用lock和unlock时，实际使用的为Sync(AQS)的acquire(1)和release(1)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span>()</span> &#123;<br>    sync.acquire(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>NonfairSync和FairSync的tryRelease()相同，都是释放一定的资源量，如果资源为0时，则将独占线程设为null然后退出。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected final boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Release(<span class="hljs-params">int</span> <span class="hljs-params">releases</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> c = get<span class="hljs-constructor">State()</span> - releases;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> != get<span class="hljs-constructor">ExclusiveOwnerThread()</span>)<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalMonitorStateException()</span>;<br>    boolean free = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (c<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        set<span class="hljs-constructor">ExclusiveOwnerThread(<span class="hljs-params">null</span>)</span>;<br>    &#125;<br>    set<span class="hljs-constructor">State(<span class="hljs-params">c</span>)</span>;<br>    return free;<br>&#125;<br></code></pre></td></tr></table></figure><p>NonfairSync和FairSync的tryAcquire()因为公平性问题，所以有一些差别：NonfairSync的tryAcquire()在资源为0时（c &#x3D;&#x3D; 0）直接尝试通过cas来增加state并将当前线程设为独占线程，如果当前线程本身就是独占线程的话，则将state增加一定的数量。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static final <span class="hljs-keyword">class</span> NonfairSync extends Sync &#123;<br>    protected final boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">int</span> <span class="hljs-params">acquires</span>)</span> &#123;<br>        return nonfair<span class="hljs-constructor">TryAcquire(<span class="hljs-params">acquires</span>)</span>;<br>    &#125;<br>&#125;<br>final boolean nonfair<span class="hljs-constructor">TryAcquire(<span class="hljs-params">int</span> <span class="hljs-params">acquires</span>)</span> &#123;<br>    final Thread current = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;<br>    <span class="hljs-built_in">int</span> c = get<span class="hljs-constructor">State()</span>;<br>    <span class="hljs-keyword">if</span> (c<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compare<span class="hljs-constructor">AndSetState(0, <span class="hljs-params">acquires</span>)</span>) &#123;<br>            set<span class="hljs-constructor">ExclusiveOwnerThread(<span class="hljs-params">current</span>)</span>;<br>            return <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current<span class="hljs-operator"> == </span>get<span class="hljs-constructor">ExclusiveOwnerThread()</span>) &#123;<br>        <span class="hljs-built_in">int</span> nextc = c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>)</span>;<br>        set<span class="hljs-constructor">State(<span class="hljs-params">nextc</span>)</span>;<br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br>    return <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>FairSync的tryAcquire()在资源为0时（c &#x3D;&#x3D; 0）还要看队列里是否有线程正在排队（hasQueuedPredecessors()），如果有的话，当前线程就得老老实实去排队，不能插队，这里表现了公平性调度。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> boolean tryAcquire(int acquires) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> current = <span class="hljs-type">Thread</span>.currentThread();<br>        int c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            int nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>AQS中除了刚才说的同步队列外，还有等待队列，ReentrantLock中的每个condition都有一个等待队列，这也是condition实现分组唤醒的基础。</p><p><img src="/2023/02/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%8D%8F%E4%BD%9C/condition%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97.png" alt="等待队列"></p><p>查看AQS的newCondition（）方法，实际调用：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">final ConditionObject <span class="hljs-keyword">new</span><span class="hljs-type">Condition</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ConditionObject</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>直接初始化并返回了一个AQS提供的ConditionObject对象。ConditionObject通过维护firstWaiter和lastWaiter来维护Condition等待队列。通过signal操作将Condition等待队列中的线程移到Sync锁等待队列。</p><p>Condition必须与一个独占锁绑定使用，在await或signal之前必须现持有独占锁。Condition队列是一个单向链表，他是公平的，按照先进先出的顺序从队列中被“唤醒”，所谓唤醒指的是完成Condition对象上的等待，被移到Sync锁等待队列中，又参与竞争锁的资格（Sync队列有公平&amp;非公平两种模式，注意区别）。</p><p>参考：<br><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a><br><a href="https://www.cnblogs.com/go2sea/p/5630355.html">Java多线程之JUC包：Condition源码学习笔记</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ">微信公众号:我的IT技术路</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;java多线程同步与协作相关面试题目整理，面经尽量用简短的语句说明问题，详细的信息可以参考每个面经下的参考链接。面经不保证完全正确，欢迎大家</summary>
      
    
    
    
    <category term="java" scheme="http://soatree.github.io/categories/java/"/>
    
    
    <category term="面试" scheme="http://soatree.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="多线程" scheme="http://soatree.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>原码、反码、补码的理解</title>
    <link href="http://soatree.github.io/2023/02/08/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://soatree.github.io/2023/02/08/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2023-02-08T13:49:32.000Z</published>
    <updated>2023-02-12T09:51:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="机器数、真值"><a href="#机器数、真值" class="headerlink" title="机器数、真值"></a>机器数、真值</h2><ul><li>机器数</li></ul><p>一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用机器数的最高位存放符号，正数为0，负数为1。</p><p>比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是0000 0011。如果是 -3 ，就是 100 00011 。</p><p>那么，这里的 0000 0011 和 1000 0011 就是机器数。</p><ul><li>真值</li></ul><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。</p><p>例如上面的有符号数 1000 0011，其最高位1代表负，其真正数值是 -3，而不是形式值131（1000 0011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><p>例：0000 0001的真值 &#x3D; +000 0001 &#x3D; +1，1000 0001的真值 &#x3D; –000 0001 &#x3D; –1</p><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p>原码、反码、补码是机器存储一个具体数字的编码方式。机器数包含了原码、反码、补码的表示形式。</p><ul><li>原码</li></ul><p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如：如果是8位二进制：</p><p>[+1]原&#x3D; 0000 0001</p><p>[-1]原&#x3D; 1000 0001</p><p>第一位是符号位，因为第一位是符号位，所以8位二进制数的取值范围就是：（即第一位不表示值，只表示正负。）</p><p>[1111 1111 , 0111 1111]</p><p>即</p><p>[-127 , 127]</p><ul><li>反码</li></ul><p>反码的表示方法是：</p><p>正数的反码是其本身；</p><p>负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p><p>[+1] &#x3D; [0000 0001]原&#x3D; [0000 0001]反</p><p>[-1] &#x3D; [1000 0001]原&#x3D; [1111 1110]反</p><p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。</p><p><strong>反码表示在计算机中往往作为数码变换的中间环节。</strong></p><ul><li>补码</li></ul><p>补码的表示方法是：</p><p>正数的补码就是其本身；</p><p>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(也即在反码的基础上+1)</p><p>[+1] &#x3D; [0000 0001]原&#x3D; [0000 0001]反&#x3D; [0000 0001]补</p><p>[-1] &#x3D; [1000 0001]原&#x3D; [1111 1110]反&#x3D; [1111 1111]补</p><p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码再计算其数值。</p><h1 id="为什么用反码和补码"><a href="#为什么用反码和补码" class="headerlink" title="为什么用反码和补码"></a>为什么用反码和补码</h1><p>计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂，所以要把对于负数的减法运算转成加法运算。</p><p>将钟表想象成是一个1位的12进制数。例如钟表上的时间为6点，如果我们希望将时间设置为4点，那么我们可以将钟表往回拨2个小时，即“-2”，或者我们可以将钟表往前拨10个小时，即“+10”</p><ol><li>往回拨2个小时：6 - 2 &#x3D; 4</li><li>往前拨10个小时：(6 + 10)mod 12 &#x3D; 4</li></ol><p>这样就将减法计算转成了加法计算。</p><p>类似钟表，计算机中的数值也是有一定范围的，所以同样可以将计算机中的减法运算改为加法运算，即将真值为负的机器数转为补码形式再做加法，实际上是将负数转换成了这个它的<strong>同余数（概念自行百度）</strong>。</p><p>补码举例：</p><p>2-1 &#x3D; 2+(-1) &#x3D; [0000 0010]原+ [1000 0001]原&#x3D; [0000 0010]补 + [1111 1111]补</p><p>如果把[1111 1111]当成原码，去除符号位，则[0111 1111]原 &#x3D; 127</p><p>相当于</p><p>2-1 ≡ 2+127 (mod 128)</p><h1 id="到底什么是补码"><a href="#到底什么是补码" class="headerlink" title="到底什么是补码"></a>到底什么是补码</h1><p>所以到底什么是补码？</p><p><strong>其实负数的补码等于反码+1只是补码的求法，而不是补码的定义，很多人以为求补码就要先求反码，其实并不是，那些计算机学家并不会心血来潮的把反码+1就定义为补码，只不过补码正好就等于反码+1而已。</strong></p><p>其实负数的补码，是能够和其相反数相加通过溢出从而使计算机内计算结果变为0的二进制码。这是补码设计的初衷，具体目标就是让1+（-1）&#x3D;0，这利用原码是无法得到的：</p><p>0001(1) + 1001(-1) &#x3D; 1010(-2)</p><p>而在补码中：</p><p>0001(1补) + 1111(-1补) &#x3D; 10000(1溢出)</p><p>所以对于一个n位的负数-X，有如下关系</p><p>X<del>补</del> + (-X)<del>补</del> &#x3D; 100…0(n个0) &#x3D; 2^n^</p><p>假设寄存器是n位的，那么-X的补码应该是2^n^ - X的二进制编码</p><p>例如：</p><p>X &#x3D; - 0b11(-3) ，四比特表示原码 &#x3D; 1011(11)，对应反码为 &#x3D; 1100(12)，补码为1101(13);<br>如果寄存器4位，-3对应的补码二进制数为13，刚好是2^4^-3</p><p>正十进制数X补码等于其本身，n位寄存器下-X的补码等于2^n^-X对应的二进制编码。</p><h1 id="已知补码如何求原码"><a href="#已知补码如何求原码" class="headerlink" title="已知补码如何求原码"></a>已知补码如何求原码</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>补码的补码就是原码</p><h2 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h2><p>n位寄存器下-X的补码等于2^n^-X对应的二进制编码。</p><p>（1）十进制的情况下，如果给的补码是无符号数2^n^-X，那么原码即(2^n^-X) - 2^n^ &#x3D; -X:<br>例如前面-3补码无符号数是13，对应的原码就是13-2^4^&#x3D;-3</p><p>（2）十进制的情况下，如果给的补码是有符号数-Y，对应的无符号数就是2^n-1^ + Y，那么原码就是(2^n-1^ + Y)- 2^n^&#x3D;Y-2^n-1^:<br>例如前面-3补码有符号数是-5，对应的原码就是5-2^3^ &#x3D; -3</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/118432554">原码、反码、补码</a><br><a href="https://zhuanlan.zhihu.com/p/99082236">二进制的原码、反码、补码</a><br><a href="https://zhuanlan.zhihu.com/p/376848035">补码的计算方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;机器数、真值&quot;&gt;&lt;a href=&quot;#机器数、真值&quot; class=&quot;headerlink&quot; title=&quot;机器数、真值&quot;&gt;&lt;/a&gt;机</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="http://soatree.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="http://soatree.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>八股文-java多线程-基础</title>
    <link href="http://soatree.github.io/2023/01/21/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80/"/>
    <id>http://soatree.github.io/2023/01/21/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80/</id>
    <published>2023-01-21T13:41:42.000Z</published>
    <updated>2023-02-24T14:26:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java多线程基础相关面试题目整理</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="线程和进程的概念？守护线程是干什么的？常见的守护线程有哪些？"><a href="#线程和进程的概念？守护线程是干什么的？常见的守护线程有哪些？" class="headerlink" title="线程和进程的概念？守护线程是干什么的？常见的守护线程有哪些？"></a>线程和进程的概念？守护线程是干什么的？常见的守护线程有哪些？</h2><h3 id="线程和进程的概念"><a href="#线程和进程的概念" class="headerlink" title="线程和进程的概念"></a>线程和进程的概念</h3><p>进程是程序的运行实例，是程序向操作系统申请资源的基本单位，线程是进程的一条执行路径。<br>Java的线程分为两种：用户线程和守护线程。守护线程作用是为其他线程提供服务，如果所有的用户线程死亡，后台线程都会死亡。</p><h3 id="常见的守护线程有哪些"><a href="#常见的守护线程有哪些" class="headerlink" title="常见的守护线程有哪些"></a>常见的守护线程有哪些</h3><p>守护线程最典型代表就是GC线程。</p><p>参考:<br><a href="https://www.jianshu.com/p/f1723dfc0a9d">Java 守护线程Daemon</a><br>《Java多线程编程实战指南》黄文海<br>《Java疯狂讲义》李刚</p><h2 id="并发和并行的概念？Java实现并发的方式？"><a href="#并发和并行的概念？Java实现并发的方式？" class="headerlink" title="并发和并行的概念？Java实现并发的方式？"></a>并发和并行的概念？Java实现并发的方式？</h2><h3 id="并发和并行的概念"><a href="#并发和并行的概念" class="headerlink" title="并发和并行的概念"></a>并发和并行的概念</h3><p>从软件的角度来说，并发就是在一段时间内以交替的方式去完成多个任务，而并行就是以齐头并进的方式去完成多个任务。<br>从硬件的角度来说，在一个处理器一次只能够运行一个线程的情况下，由于处理器可以使用时间片（Time-slice）分配的技术来实现在同一段时间内运行多个线程，因此一个处理器就可以实现并发。而并行则需要靠多个处理器在同一时刻各自运行一个线程来实现。</p><h3 id="Java实现并发的方式"><a href="#Java实现并发的方式" class="headerlink" title="Java实现并发的方式"></a>Java实现并发的方式</h3><ul><li>继承Thread类</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//实现方法的类</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    public void run()&#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;继承Thread类&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行的方法</span><br>public static void main(<span class="hljs-type">String</span>[] args) &#123;<br>        <span class="hljs-type">Demo1</span> demo1=<span class="hljs-keyword">new</span> <span class="hljs-type">Demo1</span>();<br>        demo1.start();<br>&#125;<br><br>执行结果：<br>继承<span class="hljs-type">Thread</span>类<br></code></pre></td></tr></table></figure><ul><li>实现Runnable接口</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//实现的方法类：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;实现runnable接口&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//执行方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Demo2</span> demo2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo2</span>();<br>        <span class="hljs-title class_">Thread</span> thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(demo2);<br>        thread.<span class="hljs-title function_">start</span>();<br>&#125;<br>    <br>执行结果：<br>实现runnable接口<br></code></pre></td></tr></table></figure><ul><li>通过实现Callable接口</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//实现类方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">call</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//执行方法：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br><span class="hljs-comment">//创建实现类对象</span><br>        <span class="hljs-title class_">Callable</span> demo3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo3</span>();<br>        <span class="hljs-title class_">FutureTask</span> oneTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(demo3);<br>        <span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(oneTask);<br>        thread.<span class="hljs-title function_">start</span>();<br>        <span class="hljs-title class_">Object</span> o = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取返回值</span><br>            o = oneTask.<span class="hljs-title function_">get</span>();<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">ExecutionException</span> e) &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(o);<br><br>&#125;<br><br>执行结果：<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>通过线程池来实现多线程</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//实现代码如下：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        ExecutorService executorService = Executors.<span class="hljs-built_in">newFixedThreadPool</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            <span class="hljs-type">int</span> finalI = i;<br>            executorService.<span class="hljs-built_in">execute</span>(()-&gt; &#123;<br>                System.out.<span class="hljs-built_in">println</span>(finalI);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br>执行结果：<br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>参考:<br>《Java多线程编程实战指南》黄文海<br><a href="https://blog.csdn.net/limingxingjy/article/details/102709756">浅谈实现并发的几种方式</a></p><h2 id="native关键字的作用是什么？"><a href="#native关键字的作用是什么？" class="headerlink" title="native关键字的作用是什么？"></a>native关键字的作用是什么？</h2><ul><li>作用</li></ul><p>使用native关键字说明这个方法是原生方法，也就是这个方法是用C&#x2F;C++语言实现的，并且被编译成了DLL，由java去调用。<br>这些函数的实现体在DLL中，JDK的源代码中并不包含。对于不同的平台它们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的。</p><ul><li>使用</li></ul><p>可以将native方法比作Java程序同Ｃ程序的接口，其实现步骤：<br>　　１、在Java中声明native()方法，然后编译；<br>　　２、用javac -h产生一个.h文件；<br>　　３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；<br>　　４、将第三步的.cpp文件编译成动态链接库文件；<br>　　５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。</p><p>参考：<br><a href="https://www.cnblogs.com/KingIceMou/p/7239668.html">Java中Native关键字的作用</a></p><h2 id="线程的状态有哪些，是怎么转换的？Jvm怎么查看线程的运行状态？"><a href="#线程的状态有哪些，是怎么转换的？Jvm怎么查看线程的运行状态？" class="headerlink" title="线程的状态有哪些，是怎么转换的？Jvm怎么查看线程的运行状态？"></a>线程的状态有哪些，是怎么转换的？Jvm怎么查看线程的运行状态？</h2><h3 id="线程的状态有哪些，是怎么转换的"><a href="#线程的状态有哪些，是怎么转换的" class="headerlink" title="线程的状态有哪些，是怎么转换的"></a>线程的状态有哪些，是怎么转换的</h3><p>Java线程的状态可以使用监控工具查看，也可以通过Thread.getState()调用来获取。Thread.getState()的返回值类型Thread.State是一个枚举类型（Enum）。Thread.State所定义的线程状态包括以下几种。<br>NEW：一个已创建而未启动的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程只可能有一次处于该状态。<br>RUNNABLE：该状态可以被看成一个复合状态。它包括两个子状态：READY和RUNNING。前者表示处于该状态的线程可以被线程调度器（Scheduler）进行调度而使之处于RUNNING状态。后者表示处于该状态的线程正在运行，即相应线程对象的run方法所对应的指令正在由处理器执行。执行Thread.yield()的线程，其状态可能会由RUNNING转换为READY。处于READY子状态的线程也被称为活跃线程。<br>BLOCKED：一个线程发起一个阻塞式I&#x2F;O（BlockingI&#x2F;O）操作后，或者申请一个由其他线程持有的独占资源（比如锁）时，相应的线程会处于该状态。处于BLOCKED状态的线程并不会占用处理器资源。当阻塞式I&#x2F;O操作完成后，或者线程获得了其申请的资源，该线程的状态又可以转换为RUNNABLE。<br>WAITING：一个线程执行了某些特定方法之后就会处于这种等待其他线程执行另外一些特定操作的状态。能够使其执行线程变更为WAITING状态的方法包括：Object.wait()、Thread.join()和LockSupport.park(Object)。能够使相应线程从WAITING变更为RUNNABLE的相应方法包括：Object.notify()&#x2F;notifyAll()和LockSupport.unpark(Object))。<br>TIMED_WAITING：该状态和WAITING类似，差别在于处于该状态的线程并非无限制地等待其他线程执行特定操作，而是处于带有时间限制的等待状态。当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为RUNNABLE。<br>TERMINATED：已经执行结束的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程也只可能有一次处于该状态。Thread.run()正常返回或者由于抛出异常而提前终止都会导致相应线程处于该状态。一个线程在其整个生命周期中，只可能有一次处于NEW状态和TERMINATED状态。</p><p><img src="/2023/01/21/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9F%BA%E7%A1%80/java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png"></p><h3 id="Jvm怎么查看线程的运行状态"><a href="#Jvm怎么查看线程的运行状态" class="headerlink" title="Jvm怎么查看线程的运行状态"></a>Jvm怎么查看线程的运行状态</h3><p>对线程进行监视的主要途径是获取并查看程序的线程转储（ThreadDump）。一个程序的线程转储包含了获取这个线程转储的那一刻该程序的线程信息。这些信息包括程序中有哪些线程以及这些线程的具体信息。常用线程转储的方法如下：</p><ul><li>jstack</li></ul><p>功能描述：<br>jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。<br>命令用法：<br>jstack [ option ] vmid<br>主要选项：<br>-l 打印锁的额外信息<br>-e 打印线程的额外信息</p><p>举例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs routeros">C:\Users\liuwe&gt;jstack -l 16788<br>2023-01-23 16:57:23<br>Full thread dump OpenJDK 64-Bit<span class="hljs-built_in"> Server </span>VM (11+28 mixed mode):<br><br>Threads class SMR info:<br><span class="hljs-attribute">_java_thread_list</span>=0x0000024591cff610, <span class="hljs-attribute">length</span>=11, elements=&#123;<br>0x00000245f256d000, 0x00000245911b3000, 0x00000245911b4000, 0x0000024591a43000,<br>0x00000245911e9000, 0x00000245911eb800, 0x00000245911f2000, 0x0000024591ab0000,<br>0x00000245f264d000, 0x0000024591d54000, 0x0000024591d2d800<br>&#125;<br><br><span class="hljs-string">&quot;main&quot;</span> #1 <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">os_prio</span>=0 <span class="hljs-attribute">cpu</span>=20078.13ms <span class="hljs-attribute">elapsed</span>=28.27s <span class="hljs-attribute">tid</span>=0x00000245f256d000 <span class="hljs-attribute">nid</span>=0x3f48 runnable  [0x0000005b97bff000]<br>   java.lang.Thread.State: RUNNABLE<br>        at java.io.FileOutputStream.writeBytes(java.base@11/Native Method)<br>        at java.io.FileOutputStream.write(java.base@11/FileOutputStream.java:354)<br>        at java.io.BufferedOutputStream.flushBuffer(java.base@11/BufferedOutputStream.java:81)<br>        at java.io.BufferedOutputStream.flush(java.base@11/BufferedOutputStream.java:142)<br>        - locked &lt;0x00000000847e2818&gt; (a java.io.BufferedOutputStream)<br>        at java.io.PrintStream.write(java.base@11/PrintStream.java:561)<br>        - locked &lt;0x0000000084718cc8&gt; (a java.io.PrintStream)<br>        at sun.nio.cs.StreamEncoder.writeBytes(java.base@11/StreamEncoder.java:233)<br>        at sun.nio.cs.StreamEncoder.implFlushBuffer(java.base@11/StreamEncoder.java:312)<br>        at sun.nio.cs.StreamEncoder.flushBuffer(java.base@11/StreamEncoder.java:104)<br>        - locked &lt;0x0000000084718c88&gt; (a java.io.OutputStreamWriter)<br>        at java.io.OutputStreamWriter.flushBuffer(java.base@11/OutputStreamWriter.java:184)<br>        at java.io.PrintStream.newLine(java.base@11/PrintStream.java:625)<br>        - eliminated &lt;0x0000000084718cc8&gt; (a java.io.PrintStream)<br>        at java.io.PrintStream.println(java.base@11/PrintStream.java:883)<br>        - locked &lt;0x0000000084718cc8&gt; (a java.io.PrintStream)<br>        at TestClass.main(TestClass.java:7)<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Reference Handler&quot;</span> #2 daemon <span class="hljs-attribute">prio</span>=10 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.01s <span class="hljs-attribute">tid</span>=0x00000245911b3000 <span class="hljs-attribute">nid</span>=0x393c waiting on condition  [0x0000005b982ff000]<br>   java.lang.Thread.State: RUNNABLE<br>        at java.lang.ref.Reference.waitForReferencePendingList(java.base@11/Native Method)<br>        at java.lang.ref.Reference.processPendingReferences(java.base@11/Reference.java:241)<br>        at java.lang.ref.Reference<span class="hljs-variable">$ReferenceHandler</span>.<span class="hljs-built_in">run</span>(java.base@11/Reference.java:213)<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Finalizer&quot;</span> #3 daemon <span class="hljs-attribute">prio</span>=8 <span class="hljs-attribute">os_prio</span>=1 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.01s <span class="hljs-attribute">tid</span>=0x00000245911b4000 <span class="hljs-attribute">nid</span>=0x434c <span class="hljs-keyword">in</span> Object.wait()  [0x0000005b983fe000]<br>   java.lang.Thread.State: WAITING (on object monitor)<br>        at java.lang.Object.wait(java.base@11/Native Method)<br>        - waiting on &lt;0x0000000084729c70&gt; (a java.lang.ref.ReferenceQueue<span class="hljs-variable">$Lock</span>)<br>        at java.lang.ref.ReferenceQueue.<span class="hljs-built_in">remove</span>(java.base@11/ReferenceQueue.java:155)<br>        - waiting <span class="hljs-keyword">to</span> re-lock <span class="hljs-keyword">in</span> wait() &lt;0x0000000084729c70&gt; (a java.lang.ref.ReferenceQueue<span class="hljs-variable">$Lock</span>)<br>        at java.lang.ref.ReferenceQueue.<span class="hljs-built_in">remove</span>(java.base@11/ReferenceQueue.java:176)<br>        at java.lang.ref.Finalizer<span class="hljs-variable">$FinalizerThread</span>.<span class="hljs-built_in">run</span>(java.base@11/Finalizer.java:170)<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Signal Dispatcher&quot;</span> #4 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=27.90s <span class="hljs-attribute">tid</span>=0x0000024591a43000 <span class="hljs-attribute">nid</span>=0x3938 runnable  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Attach Listener&quot;</span> #5 daemon <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=62.50ms <span class="hljs-attribute">elapsed</span>=27.90s <span class="hljs-attribute">tid</span>=0x00000245911e9000 <span class="hljs-attribute">nid</span>=0x28fc waiting on condition  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;C2 CompilerThread0&quot;</span> #6 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=437.50ms <span class="hljs-attribute">elapsed</span>=27.90s <span class="hljs-attribute">tid</span>=0x00000245911eb800 <span class="hljs-attribute">nid</span>=0x2e78 waiting on condition  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br>   <span class="hljs-literal">No</span> compile task<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;C1 CompilerThread0&quot;</span> #8 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=187.50ms <span class="hljs-attribute">elapsed</span>=27.90s <span class="hljs-attribute">tid</span>=0x00000245911f2000 <span class="hljs-attribute">nid</span>=0x4be0 waiting on condition  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br>   <span class="hljs-literal">No</span> compile task<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Sweeper thread&quot;</span> #9 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=15.63ms <span class="hljs-attribute">elapsed</span>=27.88s <span class="hljs-attribute">tid</span>=0x0000024591ab0000 <span class="hljs-attribute">nid</span>=0x13b8 runnable  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Common-Cleaner&quot;</span> #10 daemon <span class="hljs-attribute">prio</span>=8 <span class="hljs-attribute">os_prio</span>=1 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=27.66s <span class="hljs-attribute">tid</span>=0x00000245f264d000 <span class="hljs-attribute">nid</span>=0x40e4 <span class="hljs-keyword">in</span> Object.wait()  [0x0000005b989ff000]<br>   java.lang.Thread.State: TIMED_WAITING (on object monitor)<br>        at java.lang.Object.wait(java.base@11/Native Method)<br>        - waiting on &lt;0x000000008472a448&gt; (a java.lang.ref.ReferenceQueue<span class="hljs-variable">$Lock</span>)<br>        at java.lang.ref.ReferenceQueue.<span class="hljs-built_in">remove</span>(java.base@11/ReferenceQueue.java:155)<br>        - waiting <span class="hljs-keyword">to</span> re-lock <span class="hljs-keyword">in</span> wait() &lt;0x000000008472a448&gt; (a java.lang.ref.ReferenceQueue<span class="hljs-variable">$Lock</span>)<br>        at jdk.internal.ref.CleanerImpl.<span class="hljs-built_in">run</span>(java.base@11/CleanerImpl.java:148)<br>        at java.lang.Thread.<span class="hljs-built_in">run</span>(java.base@11/Thread.java:834)<br>        at jdk.internal.misc.InnocuousThread.<span class="hljs-built_in">run</span>(java.base@11/InnocuousThread.java:134)<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Monitor Ctrl-Break&quot;</span> #11 daemon <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">os_prio</span>=0 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=27.45s <span class="hljs-attribute">tid</span>=0x0000024591d54000 <span class="hljs-attribute">nid</span>=0x34b0 runnable  [0x0000005b98afe000]<br>   java.lang.Thread.State: RUNNABLE<br>        at java.net.SocketInputStream.socketRead0(java.base@11/Native Method)<br>        at java.net.SocketInputStream.socketRead(java.base@11/SocketInputStream.java:115)<br>        at java.net.SocketInputStream.read(java.base@11/SocketInputStream.java:168)<br>        at java.net.SocketInputStream.read(java.base@11/SocketInputStream.java:140)<br>        at sun.nio.cs.StreamDecoder.readBytes(java.base@11/StreamDecoder.java:284)<br>        at sun.nio.cs.StreamDecoder.implRead(java.base@11/StreamDecoder.java:326)<br>        at sun.nio.cs.StreamDecoder.read(java.base@11/StreamDecoder.java:178)<br>        - locked &lt;0x000000008471f758&gt; (a java.io.InputStreamReader)<br>        at java.io.InputStreamReader.read(java.base@11/InputStreamReader.java:185)<br>        at java.io.BufferedReader.fill(java.base@11/BufferedReader.java:161)<br>        at java.io.BufferedReader.readLine(java.base@11/BufferedReader.java:326)<br>        - locked &lt;0x000000008471f758&gt; (a java.io.InputStreamReader)<br>        at java.io.BufferedReader.readLine(java.base@11/BufferedReader.java:392)<br>        at com.intellij.rt.execution.application.AppMainV2<span class="hljs-variable">$1</span>.<span class="hljs-built_in">run</span>(AppMainV2.java:55)<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;Service Thread&quot;</span> #12 daemon <span class="hljs-attribute">prio</span>=9 <span class="hljs-attribute">os_prio</span>=0 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=27.45s <span class="hljs-attribute">tid</span>=0x0000024591d2d800 <span class="hljs-attribute">nid</span>=0x3abc runnable  [0x0000000000000000]<br>   java.lang.Thread.State: RUNNABLE<br><br>   Locked ownable synchronizers:<br>        - None<br><br><span class="hljs-string">&quot;VM Thread&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=31.25ms <span class="hljs-attribute">elapsed</span>=28.03s <span class="hljs-attribute">tid</span>=0x00000245911af000 <span class="hljs-attribute">nid</span>=0x41dc runnable<br><br><span class="hljs-string">&quot;GC Thread#0&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.19s <span class="hljs-attribute">tid</span>=0x00000245f2583000 <span class="hljs-attribute">nid</span>=0x3708 runnable<br><br><span class="hljs-string">&quot;GC Thread#1&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=25.42s <span class="hljs-attribute">tid</span>=0x0000024591dfd800 <span class="hljs-attribute">nid</span>=0x223c runnable<br><br><span class="hljs-string">&quot;GC Thread#2&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=25.42s <span class="hljs-attribute">tid</span>=0x0000024591dfe000 <span class="hljs-attribute">nid</span>=0x3e60 runnable<br><br><span class="hljs-string">&quot;G1 Main Marker&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.18s <span class="hljs-attribute">tid</span>=0x00000245f25b1800 <span class="hljs-attribute">nid</span>=0x4a5c runnable<br><br><span class="hljs-string">&quot;G1 Conc#0&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.18s <span class="hljs-attribute">tid</span>=0x00000245f25b4800 <span class="hljs-attribute">nid</span>=0x3378 runnable<br><br><span class="hljs-string">&quot;G1 Refine#0&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.18s <span class="hljs-attribute">tid</span>=0x00000245f2644000 <span class="hljs-attribute">nid</span>=0x1e0c runnable<br><br><span class="hljs-string">&quot;G1 Young RemSet Sampling&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=28.18s <span class="hljs-attribute">tid</span>=0x00000245f2647000 <span class="hljs-attribute">nid</span>=0x4054 runnable<br><span class="hljs-string">&quot;VM Periodic Task Thread&quot;</span> <span class="hljs-attribute">os_prio</span>=2 <span class="hljs-attribute">cpu</span>=0.00ms <span class="hljs-attribute">elapsed</span>=27.45s <span class="hljs-attribute">tid</span>=0x0000024591d93000 <span class="hljs-attribute">nid</span>=0x2c64 waiting on condition<br><br>JNI global refs: 15, weak refs: 0<br></code></pre></td></tr></table></figure><p>线程中参数解释：<br>tid: Java memory address of its internal Thread control structure. 16进制的<br>nid: native thread id. 每一个nid对应于linux下的一个tid, 即lwp (light weight process, or thread). 16进制的，转到10进制后可以用ps命令找到它。<br>prio: java内定义的线程的优先级<br>os_prio: 操作系统级别的优先级<br>cpu: 为cpu运行时间<br>elapsed: 为实际运行时间<br>daemon: 说明是守护线程</p><ul><li>JvisualVm</li></ul><p>VisualVM是一款免费的\集成了多个JDK命令行工具的可视化工具，是功能最强大的运行监控和故障处理程序之一，曾经很长一段时间是oracle官方主力发展的虚拟机故障处理工具。功能包括生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和CPU分析，同时它还支持在MBeans上进行浏览和操作。可以基于该工具实现线程转储和可视化监测。</p><p>参考:<br>《Java多线程编程实战指南》黄文海<br><a href="https://www.cnblogs.com/lllliuxiaoxia/p/15799378.html">jvm监控工具小结</a></p><h2 id="线程安全问题的三个方面"><a href="#线程安全问题的三个方面" class="headerlink" title="线程安全问题的三个方面"></a>线程安全问题的三个方面</h2><p>线程安全问题概括来说表现为3个方面：原子性、可见性和有序性。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子操作的“不可分割”包括以下两层含义。</p><ul><li>访问（读、写）某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生，即其他线程不会“看到”该操作执行了部分的中间效果。</li><li>访问同一组共享变量的原子操作是不能够被交错的。</li></ul><p>Java中有两种方式来实现原子性。一种是使用锁（Lock）。锁具有排他性，即它能够保障一个共享变量在任意一个时刻只能够被一个线程访问。这就排除了多个线程在同一时刻访问同一个共享变量而导致干扰与冲突的可能，即消除了竞态。另一种是利用处理器提供的专门CAS（Compare-and-Swap）指令，CAS算作乐观锁。</p><p>Java语言中针对任何变量的读操作都是原子操作。在Java语言中，long型和double型以外的任何类型的变量的写操作都是原子操作。对long&#x2F;double型变量的写操作由于Java语言规范并不保障其具有原子性，因此在多个线程并发访问同一long&#x2F;double型变量的情况下，一个线程可能会读取到其他线程更新该变量的“中间结果”。尽管如此，Java语言规范特别地规定对于volatile关键字修饰的long&#x2F;double型变量的写操作具有原子性。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性就是指一个线程对共享变量的更新的结果对于读取相应共享变量的线程而言是否可见的问题。多线程程序在可见性方面存在问题意味着某些线程读取到了旧数据（StaleData）。导致可见性问题的原因分为两种，一种是JIT编译器的优化，需要基于一定机制避免多线程情况下的不正常编译优化；另一种是没有及时进行缓存同步，要通过使更新共享变量的处理器执行冲刷处理器缓存的动作，并使读取共享变量的处理器执行刷新处理器缓存的动作来保障可见性。</p><p>可见性的保障仅仅意味着一个线程能够读取到共享变量的相对新值，而不能保障该线程能够读取到相应变量的最新值，即读到数据后到使用的时候，原来的数据可能已经发生了变化。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>多种因素都可能导致程序的感知顺序与源代码顺序不一致，而这种不一致可能导致线程安全问题。避免这个问题实质上就是保证感知顺序与源代码顺序一致，即有序性。</p><p>导致有序性问题的来源分为：（1）指令重排序。指令重排序主要来源于JIT的编译优化和处理器在判断语句场景的猜测执行技术；（2）存储系统重排序。即使在处理器严格依照程序顺序执行两个内存访问操作的情况下，在存储子系统的作用下其他处理器对这两个操作的感知顺序仍然可能与程序顺序不一致，即这两个操作的执行顺序看起来像是发生了变化。这种现象就是存储子系统重排序，也被称为内存重排序（MemoryOrdering）。</p><p>单线程也会发生重排序，但是结果不会出现异常，就仿佛是串行执行的一样；要保证多线程的有序性，需要在逻辑上部分禁止重排序。</p><p>参考:<br>《Java多线程编程实战指南》黄文海</p><h2 id="Thread类中的start和run方法的区别是什么？"><a href="#Thread类中的start和run方法的区别是什么？" class="headerlink" title="Thread类中的start和run方法的区别是什么？"></a>Thread类中的start和run方法的区别是什么？</h2><p>Thread类的start方法的作用是启动相应的线程，并在这个新线程中执行run方法，线程属于“一次性用品”，start方法也只能够被调用一次，多次调用同一个Thread实例的start方法会导致其抛出IllegalThreadStateException异常。</p><p>Thread类的run方法可以反复执行，但是是在当前线程中执行，不会创建新线程，一般不建议这样操作。</p><p>参考:<br>《Java多线程编程实战指南》黄文海</p><h2 id="Runnable和Callable？Future的作用是什么？"><a href="#Runnable和Callable？Future的作用是什么？" class="headerlink" title="Runnable和Callable？Future的作用是什么？"></a>Runnable和Callable？Future的作用是什么？</h2><h3 id="Runnable和Callable"><a href="#Runnable和Callable" class="headerlink" title="Runnable和Callable"></a>Runnable和Callable</h3><p>Runnable接口可以被看作对任务进行的抽象，任务的处理逻辑就体现在run方法之中。Thread类实际上是Runnable接口的一个实现类，其对Runnable接口的实现。</p><p>Callable接口也是对任务的抽象，任务的处理逻辑可以在Callable接口实现类的call方法中实现。Callable接口相当于一个增强型的Runnable接口：call方法的返回值代表相应任务的处理结果，其类型V是通过Callable接口的类型参数指定的；call方法代表的任务在其执行过程中可以抛出异常。而Runnable接口中的run方法既无返回值也不能抛出异常。</p><p>采用Runnable实例来表示异步任务，其优点是任务既可以交给一个专门的工作者线程执行（以相应的Runnable实例为参数创建并启动一个工作者线程），也可以交给一个线程池或者Executor的其他实现类来执行；其缺点是我们无法直接获取任务的执行结果。使用Callable实例来表示异步任务，其优点是我们可以通过ThreadPoolExecutor.submit(Callable<T>)的返回值获取任务的处理结果；其缺点是Callable实例表示的异步任务只能交给线程池执行，而无法直接交给一个专门的工作者线程或者Executor实现类执行。</T></p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future接口实例可被看作任务的处理结果句柄（Handle），Future.get()方法可以用来获取task参数所指定的任务的处理结果，Future.get()是个阻塞方法，该方法能够抛出InterruptedException说明它可以响应线程中断，可以通过捕获Future.get()调用抛出的异常来知晓相应任务执行过程中抛出的异常。ThreadPoolExecutor线程池的一个submit方法声明如下：public<T>Future<T>submit(Callable<T>task)，可以通过提交Callable任务并通过Future.get()获取结果。</T></T></T></p><p>java.util.concurrent.FutureTask类融合了Runnable接口和Callable接口的优点：FutureTask是java.util.concurrent.RunnableFuture接口的一个实现类，由于RunnableFuture接口继承了Future接口和Runnable接口，因此FutureTask既是Runnable接口的实现类也是Future接口的实现。因此FutureTask表示的异步任务可以交给专门的工作者线程执行，也可以交给Executor实例（比如线程池）执行，FutureTask还能够直接返回其代表的异步任务的处理结果。ThreadPoolExecutor.submit(Callable<T>task)的返回值就是一个FutureTask实例。</T></p><p>FutureTask的一个构造器可以将Callable实例转换为Runnable实例，该构造器的声明如下：publicFutureTask(Callable<V>callable)。<br>我们可以将任务的处理逻辑封装在一个Callable实例中，并以该实例为参数创建一个FutureTask实例，我们可以用FutureTask实例（Runnable实例）为参数来创建并启动一个工作者线程以执行相应的任务，也可以将FutureTask实例交给Executor执行（通过Executor.execute(Runnabletask)调用），FutureTask类还实现了Future接口，这使得我们在调用Executor.execute(Runnabletask)这样只认Runnable接口的方法来执行任务的情况下依然能够获取任务的执行结果。</V></p><p>参考:<br>《Java多线程编程实战指南》黄文海</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ">微信公众号:我的IT技术路</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;java多线程基础相关面试题目整理&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="java" scheme="http://soatree.github.io/categories/java/"/>
    
    
    <category term="面试" scheme="http://soatree.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="多线程" scheme="http://soatree.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>八股文--java基础</title>
    <link href="http://soatree.github.io/2023/01/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%9F%BA%E7%A1%80/"/>
    <id>http://soatree.github.io/2023/01/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%9F%BA%E7%A1%80/</id>
    <published>2023-01-14T14:02:42.000Z</published>
    <updated>2023-07-15T01:41:50.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java基础相关面试题目整理</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Java创建一个对象的方法有几种？"><a href="#Java创建一个对象的方法有几种？" class="headerlink" title="Java创建一个对象的方法有几种？"></a>Java创建一个对象的方法有几种？</h2><ol><li>使用new关键字</li><li>反射<br> (1)使用Class类的newInstance方法 <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Employee emp2 = (Employee) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;org.programming.mitra.exercises.Employee&quot;</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br></code></pre></td></tr></table></figure> 或者(目前Class.newInstance()这种方法因为效率问题已经被标记@Deprecated) <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Employee emp2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Employee</span>.</span></span><span class="hljs-keyword">class</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br></code></pre></td></tr></table></figure> (2)使用Constructor类的newInstance方法 <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;<span class="hljs-title">Employee</span>&gt; <span class="hljs-title">constructor</span> = <span class="hljs-title">Employee</span>.<span class="hljs-title">class</span>.<span class="hljs-title">getConstructor</span><span class="hljs-params">()</span>;</span><br>Employee emp3 = <span class="hljs-keyword">constructor</span>.newInstance();<br></code></pre></td></tr></table></figure></li><li>clone<br> 类需要先实现Cloneable接口并实现其定义的clone方法。 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Employee emp4 <span class="hljs-operator">=</span> (Employee) emp3.clone()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>反序列化<br> 需要让类实现Serializable接口 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ObjectInputStream in <span class="hljs-operator">=</span> new ObjectInputStream(new FileInputStream(<span class="hljs-string">&quot;data.obj&quot;</span>))<span class="hljs-comment">;</span><br>Employee emp5 <span class="hljs-operator">=</span> (Employee) in.readObject()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol><p>参考:<br><a href="https://www.cnblogs.com/wxd0108/p/5685817.html">Java中创建对象的5种方式</a></p><h2 id="Java中-x3D-x3D-和equals的区别是什么？"><a href="#Java中-x3D-x3D-和equals的区别是什么？" class="headerlink" title="Java中&#x3D;&#x3D;和equals的区别是什么？"></a>Java中&#x3D;&#x3D;和equals的区别是什么？</h2><p>略</p><h2 id="序列化的作用是什么？常见的序列化方法是什么？Java自带的序列化是怎么实现的？"><a href="#序列化的作用是什么？常见的序列化方法是什么？Java自带的序列化是怎么实现的？" class="headerlink" title="序列化的作用是什么？常见的序列化方法是什么？Java自带的序列化是怎么实现的？"></a>序列化的作用是什么？常见的序列化方法是什么？Java自带的序列化是怎么实现的？</h2><h3 id="序列化的作用是什么？"><a href="#序列化的作用是什么？" class="headerlink" title="序列化的作用是什么？"></a>序列化的作用是什么？</h3><p>网络传输的数据都必须是二进制数据，但是在Java中都是对象，是没有办法在网络中进行传输的，所以就需要对Java对象进行序列化。</p><p>序列化：将数据结构或对象转换成二进制串的过程；</p><p>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</p><h3 id="常见的序列化方法是什么？"><a href="#常见的序列化方法是什么？" class="headerlink" title="常见的序列化方法是什么？"></a>常见的序列化方法是什么？</h3><p>json序列化，java原生序列化等。关于选型可以参考美团技术博客，见<a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">序列化和反序列化</a>。</p><h3 id="Java自带的序列化是怎么实现的？"><a href="#Java自带的序列化是怎么实现的？" class="headerlink" title="Java自带的序列化是怎么实现的？"></a>Java自带的序列化是怎么实现的？</h3><ol><li>对于要序列化对象的类要去实现Serializable接口或者Externalizable接口 <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_ inherited__">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">long</span> serialVersionUID = <span class="hljs-number">6000894702030258313</span>L;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Date <span class="hljs-built_in">date</span>;<br>    <span class="hljs-comment">//省去getter和setter方法和toString</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用JDK提供的ObjectOutputStream和ObjectInputStream来实现序列化和反序列化<br> 序列化： <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>    TestBean testBean = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TestBean()</span>;<br>    testBean.set<span class="hljs-constructor">Date(<span class="hljs-params">new</span> Date()</span>);<br>    testBean.set<span class="hljs-constructor">Id(1)</span>;<br>    testBean.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;zll1&quot;</span>)</span>;<br>    <span class="hljs-comment">//使用ObjectOutputStream序列化testBean对象并将其序列化成的字节序列写入test.txt文件</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileOutputStream(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>)</span>;<br>        ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectOutputStream(<span class="hljs-params">fileOutputStream</span>)</span>;<br>        objectOutputStream.write<span class="hljs-constructor">Object(<span class="hljs-params">testBean</span>)</span>;<br>    &#125; catch (FileNotFoundException e) &#123;<br>        e.print<span class="hljs-constructor">StackTrace()</span>;<br>    &#125; catch (IOException e) &#123;<br>        e.print<span class="hljs-constructor">StackTrace()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 反序列化： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fileInputStream);<br>        <span class="hljs-type">TestBean</span> <span class="hljs-variable">testBean</span> <span class="hljs-operator">=</span> (TestBean) objectInputStream.readObject();<br>        System.out.println(testBean);<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 注意：<ul><li>一个对象要进行序列化，如果该对象成员变量是引用类型的，那这个引用类型也一定要是可序列化的，否则会报错</li><li>对于不想序列化的字段可以在字段类型之前加上transient关键字修饰（反序列化时会被赋予默认值）</li><li>实现Externalizable接口需要重写两个方法writeExternal(ObjectOutput out)和readExternal(ObjectInput in)，用来自定义决定哪些字段需要序列化，哪些需要反序列化</li><li>关于serialVersionUID：在进行序列化时，会把当前类的serialVersionUID写入到字节序列中（也会写入序列化的文件中），在反序列化时会将字节流中的serialVersionUID同本地对象中的serialVersionUID进行对比，一致的话进行反序列化，不一致则失败报错（报InvalidCastException异常）。如果未显式声明serialVersionUID，会隐式申明一个serialVersionUID，这个serialVersionUID和对象字段还有JVM环境有关，如果没有设置serialVersionUID做了序列化，然后修改了字段就无法进行反序列化了，所以一般会先设定一个serialVersionUID。可以基于IDEA自动生成(参见<a href="https://blog.csdn.net/Aphysia/article/details/80620804">IDEA 自动生成serialVersionUID</a>)，也可以基于jdk中的工具生成。</li></ul></li></ol><p>参考:<br><a href="https://zhuanlan.zhihu.com/p/361705392">Java几种序列化方式对比</a><br><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">序列化和反序列化</a><br><a href="https://zhuanlan.zhihu.com/p/316200445">一文搞懂序列化与反序列化</a><br><a href="https://blog.csdn.net/Aphysia/article/details/80620804">IDEA 自动生成serialVersionUID</a><br><a href="https://cloud.tencent.com/developer/article/1943450">serialVersionUID作用是什么以及如何生成的</a><br><a href="https://www.bbsmax.com/A/8Bz841mVzx/">java序列化框架性能对比</a></p><h2 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h2><p>略</p><h2 id="java的异常机制？结合项目描述一下你是怎么处理异常的？"><a href="#java的异常机制？结合项目描述一下你是怎么处理异常的？" class="headerlink" title="java的异常机制？结合项目描述一下你是怎么处理异常的？"></a>java的异常机制？结合项目描述一下你是怎么处理异常的？</h2><h3 id="java的异常机制"><a href="#java的异常机制" class="headerlink" title="java的异常机制"></a>java的异常机制</h3><ul><li>Error和Exception</li></ul><p>Java所有异常类都是Throwable的子类。它包括Java异常处理的两个重要子类：Error和Exception。</p><p>Error：Error及其子类用来描述Java运行系统中的内部错误以及资源耗尽的错误，是程序无法处理的错误，这类错误比较严重，如OutOfMemoryError。这些异常发生时，JVM一般会选择线程终止。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。 </p><p>Exception：可以通过捕捉处理使程序继续执行，是程序自身可以处理的异常。根据错误发生原因可分为RuntimeException异常和除RunTimeException之外的异常，如IOException异常。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException和 ArrayIndexOutOfBoundException）。 </p><ul><li>可查异常和不可查异常</li></ul><p>可查异常：编译器要求必须处理的异常，这类异常的发生在一定程度上是可以预计的，除了RuntimeException及其子类以外的其它异常类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，出现这种异常，要么用try-catch语句捕捉它，要么用throws语句声明抛出它，否则编译不通过。</p><p>不可查异常：编译器不要求强制处理的异常，包括运行时异常（RuntimeException与其子类）和错误（Error） 。</p><h3 id="结合项目描述一下你是怎么处理异常的"><a href="#结合项目描述一下你是怎么处理异常的" class="headerlink" title="结合项目描述一下你是怎么处理异常的"></a>结合项目描述一下你是怎么处理异常的</h3><p>自定义异常实现错误码接口，在特定检查处抛出包含错误码的自定义异常，</p><p>参考：<br><a href="https://blog.csdn.net/qq_15349687/article/details/82811581">Java的异常处理机制</a></p><h2 id="Object类有哪些常用的方法"><a href="#Object类有哪些常用的方法" class="headerlink" title="Object类有哪些常用的方法"></a>Object类有哪些常用的方法</h2><ul><li>getClass()</li></ul><p>返回Class，native方法</p><ul><li>hashCode()</li></ul><p>返回一个int，native方法</p><ul><li>equals(Object obj)</li></ul><p>默认等价与&#x3D;&#x3D;</p><ul><li>clone()</li></ul><p>需要继承Coloneable接口，返回一个对象的副本，不过是对于对象的引用型字段（String和包装类除外）为浅拷贝</p><ul><li>toString()</li></ul><p>默认返回 getClass().getName() + “@” + Integer.toHexString(hashCode())</p><ul><li>notify()、wait()</li></ul><p>通知</p><ul><li>finalize()</li></ul><p>在GC准备释放对象所占的内存空间时，将会调用finalize()，用于释放非java资源（例如打开的文件资源、数据库连接等）或调用非java方法（native方法）时分配的内存。finalize()最多只会执行一次，可以在这次执行中使对象再次被引用，使对象再活一次。</p><p>已经标记为@Deprecated，主要原因为</p><ol><li>调用时机的不确定性</li><li>影响代码的可移植性，移植到其他JVM，finalize方法可能运行崩溃</li><li>成本较高，如果一个类没有重载finalize方法，那么销毁时只要将堆中的内存处理一下就可以了，而如果重载了finalize方法的话，就要执行finalize方法，万一执行过程中再出现点异常或错误成本就更高了。</li><li>异常丢失，万一fianlize方法中抛出了异常，那么finalize会终止运行，而抛出的这个异常也会被舍弃，最终会让对象实例处于一种半销毁半存活的僵尸状态</li></ol><p>参考：<br><a href="https://blog.csdn.net/CrazyLai1996/article/details/84900818">Java中finalize()方法的使用</a><br><a href="https://zhuanlan.zhihu.com/p/94072959">Java中的finalize方法已经退出历史舞台，再看它最后一眼，留点余香</a></p><h2 id="java的hashcode和equals方法的作用？什么时候会用到？"><a href="#java的hashcode和equals方法的作用？什么时候会用到？" class="headerlink" title="java的hashcode和equals方法的作用？什么时候会用到？"></a>java的hashcode和equals方法的作用？什么时候会用到？</h2><p>hashcode在HashMap和HashSet中可以用于确定key所在桶的位置。在HashMap和HashSet中，两个key的hashcode相等，且equals为true时，可以判定为相同的key，就不会重复添加key。</p><h2 id="String是一个基本类型么？那java的基本类型有哪些？String和StringBuffer和StringBuilder的区别是什么？"><a href="#String是一个基本类型么？那java的基本类型有哪些？String和StringBuffer和StringBuilder的区别是什么？" class="headerlink" title="String是一个基本类型么？那java的基本类型有哪些？String和StringBuffer和StringBuilder的区别是什么？"></a>String是一个基本类型么？那java的基本类型有哪些？String和StringBuffer和StringBuilder的区别是什么？</h2><p>不是;int, long, float, double, boolean, char等；String是不可变字符串，StringBuffer和StringBuilder是可变字符串，StringBuffer线程安全，StringBuilder线程不安全但是效率高。StringBuffer虽然线程安全但可能会造成字符串写入顺序问题，一般使用StringBuilder。</p><h2 id="String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗？不同点主要在哪里呢？"><a href="#String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗？不同点主要在哪里呢？" class="headerlink" title="String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？不同点主要在哪里呢？"></a>String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？不同点主要在哪里呢？</h2><p>不一样。String str&#x3D;”i”的方式，Java 虚拟机会将其分配到常量池中，常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据，常量池不会重复创建对象；而 String str&#x3D;new String(“i”)方式，则会被分到堆内存中。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">String</span>[] <span class="hljs-params">args</span>) &#123;<br>    <span class="hljs-title class_">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;i&quot;</span>;<br>    <span class="hljs-title class_">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;i&quot;</span>;<br>    <span class="hljs-title class_">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;i&quot;</span>);<br>    <span class="hljs-title class_">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;i&quot;</span>);<br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">str1</span> <span class="hljs-operator">==</span> <span class="hljs-variable">str2</span>);<span class="hljs-comment">//ture</span><br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">str2</span> <span class="hljs-operator">==</span> <span class="hljs-variable">str3</span>);<span class="hljs-comment">//false</span><br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">str3</span> <span class="hljs-operator">==</span> <span class="hljs-variable">str4</span>);<span class="hljs-comment">//false</span><br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">str2</span>.<span class="hljs-property">equals</span>(<span class="hljs-variable">str3</span>));<span class="hljs-comment">//ture</span><br>    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">str3</span>.<span class="hljs-property">equals</span>(<span class="hljs-variable">str4</span>));<span class="hljs-comment">//ture</span><br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://blog.csdn.net/MuYIShan1/article/details/115350086">String str&#x3D;“i“与 String str&#x3D;new String(“i”)一样吗？</a></p><h2 id="抽象类和接口的区别？抽象类一定要有抽象函数么？接口定义的变量一定是常量么？接口中可以定义函数的实现么？"><a href="#抽象类和接口的区别？抽象类一定要有抽象函数么？接口定义的变量一定是常量么？接口中可以定义函数的实现么？" class="headerlink" title="抽象类和接口的区别？抽象类一定要有抽象函数么？接口定义的变量一定是常量么？接口中可以定义函数的实现么？"></a>抽象类和接口的区别？抽象类一定要有抽象函数么？接口定义的变量一定是常量么？接口中可以定义函数的实现么？</h2><h3 id="抽象类和接口的区别？"><a href="#抽象类和接口的区别？" class="headerlink" title="抽象类和接口的区别？"></a>抽象类和接口的区别？</h3><p>相同点：</p><ol><li>都不能被实例化 </li><li>接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</li></ol><p>不同点：</p><ol><li><p>接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</p></li><li><p>实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</p></li><li><p>接口强调特定功能的实现，而抽象类强调所属关系。</p></li><li><p>接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</p></li></ol><h3 id="抽象类一定要有抽象函数么？"><a href="#抽象类一定要有抽象函数么？" class="headerlink" title="抽象类一定要有抽象函数么？"></a>抽象类一定要有抽象函数么？</h3><p>不需要，抽象类不一定有抽象方法；但是包含一个抽象方法的类一定是抽象类。</p><h3 id="接口定义的变量一定是常量么？"><a href="#接口定义的变量一定是常量么？" class="headerlink" title="接口定义的变量一定是常量么？"></a>接口定义的变量一定是常量么？</h3><p>是</p><h3 id="接口中可以定义函数的实现么？"><a href="#接口中可以定义函数的实现么？" class="headerlink" title="接口中可以定义函数的实现么？"></a>接口中可以定义函数的实现么？</h3><p>java 1.8中可以定义default方法体</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/94770324">Java基础之接口与抽象类的区别</a><br><a href="https://blog.csdn.net/ZM_Crazy/article/details/113931384">抽象类必须要有抽象方法吗？</a></p><h2 id="final、static关键字在java中的作用？抽象类可以使用final修饰么？"><a href="#final、static关键字在java中的作用？抽象类可以使用final修饰么？" class="headerlink" title="final、static关键字在java中的作用？抽象类可以使用final修饰么？"></a>final、static关键字在java中的作用？抽象类可以使用final修饰么？</h2><h3 id="final、static关键字在java中的作用？"><a href="#final、static关键字在java中的作用？" class="headerlink" title="final、static关键字在java中的作用？"></a>final、static关键字在java中的作用？</h3><ul><li>final 变量<br>  变量指定的对象存储空间固定，不能修改，只读</li><li>final 方法<br>  final 方法使该类的子类无法重写该方法</li><li>final 类<br>  无法被子类继承</li><li>static<br>  与类相关，例如静态内部类、静态方法、静态变量、静态代码块</li></ul><h3 id="抽象类可以使用final修饰么？"><a href="#抽象类可以使用final修饰么？" class="headerlink" title="抽象类可以使用final修饰么？"></a>抽象类可以使用final修饰么？</h3><p>不能</p><h2 id="final-finally-finalize分别是什么？"><a href="#final-finally-finalize分别是什么？" class="headerlink" title="final,finally,finalize分别是什么？"></a>final,finally,finalize分别是什么？</h2><ul><li>final：java中的关键字，修饰符。</li></ul><ol><li>如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。</li><li>被声明为final的变量必须在声明时给定初值，变量指向的内存地址无法改变。</li><li>被声明final的方法子类无法重写。</li></ol><ul><li>finally：java的一种异常处理机制。<br>finally是对Java异常处理模型的补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。</li><li>finalize：Java中的一个方法名。<br>Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。目前该方法已经在JDK1.9被标记@Deprecated</li></ul><p>参考：<br><a href="https://www.cnblogs.com/smart-hwt/p/8257330.html">Java中final、finally、finalize的区别与用法</a></p><h2 id="Java的IO流有了解过，实现一个按行读取数据的方式。"><a href="#Java的IO流有了解过，实现一个按行读取数据的方式。" class="headerlink" title="Java的IO流有了解过，实现一个按行读取数据的方式。"></a>Java的IO流有了解过，实现一个按行读取数据的方式。</h2><h3 id="Java的IO流体系"><a href="#Java的IO流体系" class="headerlink" title="Java的IO流体系"></a>Java的IO流体系</h3><p>在Java中，将不同的终端的输入输出源抽象为流的概念，通过这种方式可以将不同终端的数据进行交互。Java将传统的流类型都放在java.io包中，一般我们将IO以以下三种方式进行分类。</p><p>1）按照流的方向：输入流和输出流</p><p>输入输出流是针对程序运行的内存而言的，从内存输出到其他介质上称为输出流，从其他介质输入到程序内存中称为输入流。一般以inputstream&#x2F;reader结尾的称为输入流，outputstream&#x2F;writer结尾的称为输出流。</p><p>2）按照操作单元分：字节流和字符流</p><p>字节流是针对一个字节一个字节进行操作的，字符流最小的操作单元是一个字符。字节流以inputstream&#x2F;outputstream结尾，字符流以writer&#x2F;reader结尾。字符流和字节流的转换使用适配器模式进行，可以利用转换流将字符流、字节流相互转换。</p><p>3）按照是否可以直接连接一个介质来划分：节点流和处理流</p><p>节点流是指可以直接连接在一个介质上进行输入输出的，而处理流是将节点流进行包装而具有新的功能，节点流也被称为低级流，处理流因为有了新的功能特性（当然了也包含了原来的特性）被称为高级流。这里jdk使用装饰器模式进行。</p><p><img src="/2023/01/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%9F%BA%E7%A1%80/io%E6%B5%81%E4%BD%93%E7%B3%BB.png" alt="IO流体系"></p><h3 id="关于转换流"><a href="#关于转换流" class="headerlink" title="关于转换流"></a>关于转换流</h3><p>InputStreamReader 字节流转字符流<br>OutputStreamWriter 字符流转字节流<br>以上均需要注意指定或默认的字符集</p><h3 id="按行读取文件"><a href="#按行读取文件" class="headerlink" title="按行读取文件"></a>按行读取文件</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-built_in">String</span>[] args) &#123;<br>    <span class="hljs-built_in">BufferedReader</span> reader;<br>    <span class="hljs-keyword">try</span> &#123;<br>        reader = <span class="hljs-keyword">new </span><span class="hljs-class title_">BufferedReader</span>(<span class="hljs-keyword">new </span><span class="hljs-class title_">FileReader</span>(<br>                <span class="hljs-string">&quot;D:\\git\\learning\\readtext.txt&quot;</span>));<br>        <span class="hljs-built_in">String</span> <span class="hljs-built_in">line</span> = reader.<span class="hljs-property">readLine</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">line</span> != <span class="hljs-literal">null</span>) &#123;<br>            System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-built_in">line</span>);<br>            <span class="hljs-built_in">line</span> = reader.<span class="hljs-property">readLine</span>();<br>        &#125;<br>        reader.<span class="hljs-property">close</span>();<br>    &#125; <span class="hljs-title function_">catch</span> (IOException e) &#123;<br>        e.<span class="hljs-property">printStackTrace</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://www.cnblogs.com/tanghaorong/p/12363660.html">Java IO流详解（六）—-转换流（字节流和字符流之间的转换）</a><br><a href="https://blog.csdn.net/cunchi4221/article/details/107470903">java逐行读取文件_Java逐行读取文件</a></p><h2 id="Java的反射原理是什么？Getclass和classforName的区别是什么？"><a href="#Java的反射原理是什么？Getclass和classforName的区别是什么？" class="headerlink" title="Java的反射原理是什么？Getclass和classforName的区别是什么？"></a>Java的反射原理是什么？Getclass和classforName的区别是什么？</h2><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloReflect</span> &#123;<br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">String</span>[] <span class="hljs-params">args</span>) &#123;<br>        <span class="hljs-title function_">try</span> &#123;<br>            <span class="hljs-comment">// 1. 使用外部配置的实现，进行动态加载类</span><br>            <span class="hljs-title class_">TempFunctionTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> (<span class="hljs-title class_">TempFunctionTest</span>)<span class="hljs-title class_">Class</span>.<span class="hljs-property">forName</span>(<span class="hljs-string">&quot;com.tester.HelloReflect&quot;</span>).<span class="hljs-property">newInstance</span>();<br>            <span class="hljs-variable">test</span>.<span class="hljs-property">sayHello</span>(<span class="hljs-string">&quot;call directly&quot;</span>);<br>            <span class="hljs-comment">// 2. 根据配置的函数名，进行方法调用（不需要通用的接口抽象）</span><br>            <span class="hljs-title class_">Object</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">TempFunctionTest</span>();<br>            <span class="hljs-title class_">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> <span class="hljs-variable">t2</span>.<span class="hljs-property">getClass</span>().<span class="hljs-property">getDeclaredMethod</span>(<span class="hljs-string">&quot;sayHello&quot;</span>, <span class="hljs-title class_">String</span>.<span class="hljs-property">class</span>);<br>            <span class="hljs-variable">method</span>.<span class="hljs-property">invoke</span>(<span class="hljs-variable">test</span>, <span class="hljs-string">&quot;method invoke&quot;</span>);<br>        &#125; <span class="hljs-title function_">catch</span> (<span class="hljs-title class_">ClassNotFoundException</span> <span class="hljs-variable">e</span>) &#123;<br>            <span class="hljs-variable">e</span>.<span class="hljs-property">printStackTrace</span>();<br>        &#125; <span class="hljs-title function_">catch</span> (<span class="hljs-title class_">InstantiationException</span> <span class="hljs-variable">e</span>) &#123;<br>            <span class="hljs-variable">e</span>.<span class="hljs-property">printStackTrace</span>();<br>        &#125; <span class="hljs-title function_">catch</span> (<span class="hljs-title class_">IllegalAccessException</span> <span class="hljs-variable">e</span>) &#123;<br>            <span class="hljs-variable">e</span>.<span class="hljs-property">printStackTrace</span>();<br>        &#125; <span class="hljs-title function_">catch</span> (<span class="hljs-title class_">NoSuchMethodException</span> <span class="hljs-variable">e</span> ) &#123;<br>            <span class="hljs-variable">e</span>.<span class="hljs-property">printStackTrace</span>();<br>        &#125; <span class="hljs-title function_">catch</span> (<span class="hljs-title class_">InvocationTargetException</span> <span class="hljs-variable">e</span>) &#123;<br>            <span class="hljs-variable">e</span>.<span class="hljs-property">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-variable">public</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">String</span> <span class="hljs-params">word</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-string">&quot;hello,&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-variable">word</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="forName和newInstance"><a href="#forName和newInstance" class="headerlink" title="forName和newInstance"></a>forName和newInstance</h3><p>forName()反射获取类信息，主要是先获取ClassLoader，然后调用native方法获取信息，最后，jvm又会回调ClassLoader进行类加载（双亲委派）<br>newInstance() 主要做了三件事：（1）权限检测，如果不通过直接抛出异常；（2）查找无参构造器（1. 先尝试从缓存获取所有的constructors，如果没有缓存则重新从jvm中获取并用软引用缓存, 然后通过进行参数类型比较；2. 找到匹配后，通过 ReflectionFactory copy一份constructor返回；3. 否则抛出 NoSuchMethodException;），并将其缓存起来；（3）调用具体方法的无参构造方法，生成实例并返回；</p><h3 id="getDeclaredMethod和invoke"><a href="#getDeclaredMethod和invoke" class="headerlink" title="getDeclaredMethod和invoke"></a>getDeclaredMethod和invoke</h3><p>getDeclaredMethod()主要做了四件事：（1）先进行权限检查；（2）获取所有方法列表(也是先从缓存中取，没有则从jvm中获取)；（3）根据方法名称和方法列表，选出符合要求的方法（ReflectionFactory, copy方法后返回，实际返回的是一个方法的副本）；（4）如果没有找到相应方法，抛出异常，否则返回对应方法；</p><p>invoke()做的事情：（1）先获取Method的MethodAccessor（缓存中没有则创建）;（2）调用MethodAccessor的invoke方法，底层交给JVM实现；</p><h3 id="反射小结"><a href="#反射小结" class="headerlink" title="反射小结"></a>反射小结</h3><p>最后，用几句话总结反射的实现原理：</p><ol><li>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</li><li>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；</li><li>反射也是考虑了线程安全的，放心使用；</li><li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li><li>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</li><li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li><li>调度反射方法，最终是由jvm执行invoke0()执行；</li></ol><h3 id="class、class-forname-和getClass-的区别"><a href="#class、class-forname-和getClass-的区别" class="headerlink" title=".class、class.forname()和getClass()的区别"></a>.class、class.forname()和getClass()的区别</h3><ul><li>相同</li></ul><p>通过这几种方式，得到的都是java.lang.Class对象；都是类加载的产物</p><ul><li>差别</li></ul><p>1.出现的时期不同：Class.forname()在运行时加载（动态加载）；Class.class和对象名.getClass()是在编译时加载（静态加载）<br>2.类名.class：JVM将使用类装载器，将类装入内存(前提是:类还没有装入内存)，不做类的初始化工作，返回Class的对象<br>3.Class.forName(“类名字符串”) （注：类名字符串是包名+类名）：装入类，并做类的静态初始化，返回Class的对象<br>4.实例对象.getClass()：对类进行静态初始化、非静态初始化；返回引用运行时真正所指的对象(因为:子对象的引用可能会赋给父对象的引用变量中)所属的类的Class的对象</p><h3 id="反射慢的原因"><a href="#反射慢的原因" class="headerlink" title="反射慢的原因"></a>反射慢的原因</h3><ol><li>需要对比参数匹配方法；</li><li>需要进行权限检查；</li><li>中间产生很多中间对象（方法副本，方法代理），影响GC；</li><li>据说还影响JIT优化</li></ol><p>参考：<br><a href="https://www.cnblogs.com/yougewe/p/10125073.html">深入理解java反射原理</a><br><a href="https://www.cnblogs.com/Seachal/p/5371733.html">java中Class对象详解和类名.class, class.forName(), getClass()区别</a><br><a href="https://zhuanlan.zhihu.com/p/86993361">都说 Java 反射效率低，究竟原因在哪里？</a></p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>而对于一个基础类型（包装类和非包装基本类型以及String），深拷贝和浅拷贝是一样的，都会复制一份新的，而对于一个对象类型，如果是浅拷贝的话，那其底层访问的是同一份对象，类似于对该对象起了个别名。而深拷贝的话才是我们真正说的复制，它会重新创建一个新的对象出来，和之前的对象的值一模一样，但是底层的地址是完全不同的。</p><h3 id="如何实现深拷贝"><a href="#如何实现深拷贝" class="headerlink" title="如何实现深拷贝"></a>如何实现深拷贝</h3><p>一个类实现了Cloneable接口后，其对象即可调用clone()方法，此时为浅拷贝，被拷贝对象中的变量如果是基本类型及其包装类和String类会创建副本，其他类型的对象则是引用原对象的内存地址。</p><p>如果要实现深拷贝，需要实现Cloneable接口，并且实现clone方法，如果对象中包含其他对象，其他对象也要实现。举例如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;  <br><span class="hljs-keyword">import</span> lombok.Data;  <br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;  <br><span class="hljs-meta">@NoArgsConstructor</span>  <br><span class="hljs-meta">@AllArgsConstructor</span>  <br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> LoginInfo loginInfo;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-function">Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;  <br>        User clone= (User)<span class="hljs-keyword">super</span>.clone();  <br>        <span class="hljs-comment">//调用底层clone方法重新赋值，不然就是浅拷贝  </span><br>        clone.loginInfo =(LoginInfo) clone.getLoginInfo().clone();  <br>        <span class="hljs-keyword">return</span> clone;  <br>    &#125;  <br><br>    <span class="hljs-meta">@NoArgsConstructor</span>  <br>    <span class="hljs-meta">@AllArgsConstructor</span>  <br>    <span class="hljs-meta">@Data</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;  <br>        <span class="hljs-keyword">private</span> String id;  <br>        <span class="hljs-keyword">private</span> String name;  <br>        <span class="hljs-comment">//也要实现clone接口  </span><br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">protected</span> <span class="hljs-function">Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;  <br>            <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">clone</span><span class="hljs-params">()</span></span>;  <br>        &#125;  <br>    &#125;  <br> &#125;  <br></code></pre></td></tr></table></figure><p>当然除了上面的方式，如果底下对象很多的话，那调用也是相对麻烦过程，可以直接new一个对象也可以实现深拷贝，或者通过反序列化(gson\Jackson等)的方式来说实现。</p><h3 id="如何实现一个list类型的深拷贝"><a href="#如何实现一个list类型的深拷贝" class="headerlink" title="如何实现一个list类型的深拷贝"></a>如何实现一个list类型的深拷贝</h3><p>new一个list，然后对象依次深拷贝clone即可</p><p>参考：<br><a href="https://mp.weixin.qq.com/s/EVYDpDVJXx4X72MKLbNsrQ">java 面试–序列化、反射、拷贝</a></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="作用和局限性"><a href="#作用和局限性" class="headerlink" title="作用和局限性"></a>作用和局限性</h3><ul><li>作用</li></ul><p>使用泛型可以在编译时进行类型检查，可以大大减少类型转换的错误。</p><ul><li>局限性</li></ul><p>泛型不会被存入编码区，所以一个泛型的类型T是无法new出来的，我们不能使用T.class()。一个被经常使用的场景就是反序列化一个泛型T是不被允许的，这个时候，我们必须要传入T的具体类型，这样就增加了一个传参，具体如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> GenericClass&lt;T&gt; &#123;<br>    public T get<span class="hljs-constructor">Result(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-comment">//报错，T不是一个类型</span><br>        T t = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>parse<span class="hljs-constructor">Object(<span class="hljs-params">s</span>, T.<span class="hljs-params">class</span>)</span>;<br>        return t;<br>    &#125;<br><br>    <span class="hljs-comment">//通过传入具体的类型，在强制转换</span><br>    public T get<span class="hljs-constructor">Result(String <span class="hljs-params">s</span>, Class <span class="hljs-params">cls</span>)</span> &#123;<br>        T t = (T) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>parse<span class="hljs-constructor">Object(<span class="hljs-params">s</span>, <span class="hljs-params">cls</span>)</span>;<br>        return t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>Java的泛型类型在编译器阶段实现，编译过程泛型类型会被清除掉，生成的字节码中不包含任何的泛型信息，这个过程被称为类型擦除。</p><p><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code> </p><p>上面定义的list为List<String>，经过编译之后就成了List，所以在方法区里面并没有存入String的相关信息。</String></p><p>类型擦除例子：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws Exception </span>&#123;<br>    List&lt;<span class="hljs-type">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>    <span class="hljs-comment">//idea在做检查的时候会报错，无法通过编译</span><br>    list.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//类型擦除之后，通过反射可以添加整型，这句话执行不会报错</span><br>    list.<span class="hljs-built_in">getClass</span>().<span class="hljs-built_in">getMethod</span>(<span class="hljs-string">&quot;add&quot;</span>, Object.<span class="hljs-keyword">class</span>).<span class="hljs-built_in">invoke</span>(list, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的反射可以添加任何类型，不会报错，但是要通过get方法取出来的时候会报错，因为get会进行强制类型转换为String。类型被擦除之后，在jvm中存入的是其限定类，如果没有限定，存入的是object类。</p><h3 id="获取泛型"><a href="#获取泛型" class="headerlink" title="获取泛型"></a>获取泛型</h3><p>泛型的类型在编译的时候确实被擦除了，但可以通过签名来获取泛型的类型。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericClass&lt;String&gt;</span> </span>&#123;<br>&#125;<br><span class="hljs-comment">//获取类型</span><br><span class="hljs-type">ParameterizedType</span> genericType =(<span class="hljs-type">ParameterizedType</span>)<span class="hljs-type">Test</span>.<span class="hljs-keyword">class</span>.getGenericSuperclass();<br><span class="hljs-comment">//输出字符串类型</span><br><span class="hljs-type">System</span>.out.println(genericType.getActualTypeArguments()[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://mp.weixin.qq.com/s/1ZxBOtID64NEnwsXwOXTHg">java 面试–泛型、注解</a></p><h2 id="Java的注解有了解，其底层的实现原理是什么？怎么定义一个注解？"><a href="#Java的注解有了解，其底层的实现原理是什么？怎么定义一个注解？" class="headerlink" title="Java的注解有了解，其底层的实现原理是什么？怎么定义一个注解？"></a>Java的注解有了解，其底层的实现原理是什么？怎么定义一个注解？</h2><p>注解类似一种标记，在实战中，注解有助于我们代码的解耦和无侵入性，一般通过反射获取类、函数或成员上运行时注解信息，从而实现动态控制程序运行的逻辑。</p><p>Java的注解有三类，分别是：元注解，自定义注解，jdk自带的注解。</p><p>元注解是指在定义一个注解的时候，必须要使用元注解进行标注，@Target，@Retention，@Documented，@Inherited，这四个是java的元注解；</p><p>jdk自带的注解是java已经定义好的注解，比如@override。</p><p>自定义注解是开发者定义的注解。自定义注解至少需要使用到元注解的两个@Target和@Retention</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>@Target：运行地方。@Target的取值有以下：<br>ElementType.CONSTRUCTOR 可以给构造方法进行注解<br>ElementType.FIELD 可以给属性进行注解<br>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解<br>ElementType.METHOD 可以给方法进行注解<br>ElementType.PACKAGE 可以给一个包进行注解<br>ElementType.PARAMETER 可以给一个方法内的参数进行注解<br>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解<br>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举（常用）</p><p>@Retention：保留时间，Source代码中，class编译后的类，runtime运行（常用）</p><p>@Document：是否文档化</p><p>@Inhrited：能否被继承</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p><img src="/2023/01/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%9F%BA%E7%A1%80/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A6%81%E6%B1%82.png" alt="自定义注解的语法要求"></p><h3 id="注解反射使用用例"><a href="#注解反射使用用例" class="headerlink" title="注解反射使用用例"></a>注解反射使用用例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.gacl.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-comment">//Retention注解决定MyAnnotation注解的生命周期</span><br><span class="hljs-meta">@Target( &#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    String <span class="hljs-title function_">color</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;blue&quot;</span>;<span class="hljs-comment">//为属性指定缺省值</span><br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<span class="hljs-comment">//定义一个名称为value的属性</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> cn.gacl.<span class="hljs-keyword">annotation</span>;<br><br><span class="hljs-meta">@MyAnnotation(<span class="hljs-string">&quot;孤傲苍狼&quot;</span>)</span><span class="hljs-comment">//等价于@MyAnnotation(value=&quot;孤傲苍狼&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAnnotationTest</span> &#123;<br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 用反射方式获得注解对应的实例对象后，在通过该对象调用属性对应的方法</span><br><span class="hljs-comment">         */</span><br>        MyAnnotation <span class="hljs-keyword">annotation</span> = (MyAnnotation) MyAnnotationTest.<span class="hljs-keyword">class</span>.getAnnotation(MyAnnotation.<span class="hljs-keyword">class</span>);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.color());<span class="hljs-comment">//输出color属性的默认值：blue</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">annotation</span>.value());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://mp.weixin.qq.com/s/1ZxBOtID64NEnwsXwOXTHg">java 面试–泛型、注解</a><br><a href="https://www.cnblogs.com/Qian123/p/5256084.html">框架基础——全面解析Java注解</a><br><a href="https://www.cnblogs.com/xdp-gacl/p/3622275.html">Java基础加强总结(一)——注解(Annotation) </a></p><h2 id="Java中两个类的关系有多少种？"><a href="#Java中两个类的关系有多少种？" class="headerlink" title="Java中两个类的关系有多少种？"></a>Java中两个类的关系有多少种？</h2><ul><li>单向关联: 一个对象是另一个对象的成员变量</li><li>双向关联：两个对象互为对方的成员变量</li><li>自关联：一个对象是同类对象的成员变量</li><li>聚合关系：单向关联，大雁和雁群</li><li>组合关系：单向关联，大雁和翅膀</li><li>依赖关系：一个类的方法使用另一个类的对象作为参数</li><li>继承关系</li><li>接口实现关系</li></ul><p>参考：<br><a href="https://www.cnblogs.com/lllliuxiaoxia/articles/16512406.html">Java 类图(UML)梳理</a></p><h2 id="有了解过设计模式么？"><a href="#有了解过设计模式么？" class="headerlink" title="有了解过设计模式么？"></a>有了解过设计模式么？</h2><h3 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h3><p>饿汉式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingleHungry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingleHungry singleHungry = <span class="hljs-keyword">new</span> SingleHungry();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleHungry</span>()</span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleHungry <span class="hljs-title">getInstance</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> singleHungry;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>懒汉式，基于双重检查，此方式需要注意的是volatile关键字和双重检查</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingleLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingleLazy singleLazy;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleLazy</span>()</span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleLazy <span class="hljs-title">getInstance</span>()</span>&#123;<br>        <span class="hljs-keyword">if</span> (singleLazy == <span class="hljs-literal">null</span>)&#123;<br>            synchronized (SingleLazy.<span class="hljs-keyword">class</span>)&#123;<br>                <span class="hljs-keyword">if</span> (singleLazy == <span class="hljs-literal">null</span>)&#123;<br>                    singleLazy = <span class="hljs-keyword">new</span> SingleLazy();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleLazy;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>基于不同的标识，加载不同的策略进行处理。例如计算器加载加法策略进行加法计算，基于不同的子类标志采用不同的策略反射创建对象。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>被观察者维护了一个观察者的列表，当被观察者的状态发生改变时通知所有的观察者做出相应的处理。</p><h2 id="Java的collection有几种？Collection和collections的区别是什么？"><a href="#Java的collection有几种？Collection和collections的区别是什么？" class="headerlink" title="Java的collection有几种？Collection和collections的区别是什么？"></a>Java的collection有几种？Collection和collections的区别是什么？</h2><h3 id="java集合框架"><a href="#java集合框架" class="headerlink" title="java集合框架"></a>java集合框架</h3><p><img src="/2023/01/14/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%9F%BA%E7%A1%80/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.gif" alt="java集合框架"></p><h3 id="Collection和Collections的区别是什么"><a href="#Collection和Collections的区别是什么" class="headerlink" title="Collection和Collections的区别是什么"></a>Collection和Collections的区别是什么</h3><p>Collection是集合的接口，Collections是操作Collection的工具类，可以排序、填充、混排、最值、复制、线程安全包装等</p><p>参考：<br><a href="https://www.runoob.com/java/java-collections.html">Java 集合框架</a><br><a href="https://www.jianshu.com/p/0494cce4312a">Collection和Collections的区别及Collections常用方法</a></p><h2 id="ArrayLsit、LinkedList和vector的区别？它们是线程安全的么？如果想要线程安全应该要怎么实现？"><a href="#ArrayLsit、LinkedList和vector的区别？它们是线程安全的么？如果想要线程安全应该要怎么实现？" class="headerlink" title="ArrayLsit、LinkedList和vector的区别？它们是线程安全的么？如果想要线程安全应该要怎么实现？"></a>ArrayLsit、LinkedList和vector的区别？它们是线程安全的么？如果想要线程安全应该要怎么实现？</h2><h3 id="ArrayLsit、LinkedList和vector"><a href="#ArrayLsit、LinkedList和vector" class="headerlink" title="ArrayLsit、LinkedList和vector"></a>ArrayLsit、LinkedList和vector</h3><p>ArrayList,LinkedList和Vector都继承自List接口。ArrayList和Vector的底层是动态数组，LinkedList的底层是双向链表。</p><p>ArrayList和Vector的区别就是ArrayList是线程不安全的，Vector是线程安全的，Vector中的方法都是同步方法(synchronized),所以ArrayList的执行效率要高于Vector,它也是用的最广泛的一种集合。</p><h3 id="线程安全的List"><a href="#线程安全的List" class="headerlink" title="线程安全的List"></a>线程安全的List</h3><ul><li>Vector</li></ul><p>Vector大部分方法和ArrayList都是相同的，只是加上了synchronized关键字(同步在this上)</p><ul><li>Collections.synchronizedList</li></ul><p>List list &#x3D; Collections.synchronizedList(new ArrayList());<br>转换包装后的list可以实现add，remove，get等操作的线程安全性（内部同步在mutex），但是对于迭代操作，Collections.synchronizedList并没有提供相关机制，所以迭代时需要对包装后的list（必须对包装后的list进行加锁，锁其他的不行,多线程需要保证monitor相同）进行手动加锁，使用方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br><span class="hljs-comment">//必须对list进行加锁</span><br><span class="hljs-keyword">synchronized</span> (list) &#123;<br>  <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.iterator();<br>  <span class="hljs-keyword">while</span> (i.hasNext())<br>      foo(i.next());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>CopyOnWriteArrayList</li></ul><p>是java并发包里类，用可重入锁<br>每次修改都会生成一个新的Array,同时利用Arrays.copyOf复制，最后更新<br>修改的时候加锁，读的时候不加锁，读写分离</p><ul><li>对比</li></ul><p>Collections.synchronizedList和Vector性能接近，但是Collections.synchronizedList可以包装多种List，兼容性和拓展性更强，一般推荐Collections.synchronizedList</p><p>CopyOnWriteArrayList会有一段时间的数据更新延迟，不是强同步，适用读多写少的非严格同步环境，非此场景建议用Collections.synchronizedList</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/79624468?utm_id=0">ArrayList,LinkedList和Vector的区别</a><br><a href="https://www.cnblogs.com/lkxsnow/p/12247524.html">Collections.synchronizedList 、CopyOnWriteArrayList、Vector介绍、源码浅析与性能对比</a></p><h2 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h2><h3 id="HashMap扩容机制？"><a href="#HashMap扩容机制？" class="headerlink" title="HashMap扩容机制？"></a>HashMap扩容机制？</h3><p>元素数量大于阈值，阈值是总容量*负载因子</p><h3 id="它和Hashtable的区别是什么？"><a href="#它和Hashtable的区别是什么？" class="headerlink" title="它和Hashtable的区别是什么？"></a>它和Hashtable的区别是什么？</h3><p>都实现了Map接口，Hashtable线程安全，而HashMap线程不安全。</p><p>HashTable的类注释说明HashTable已经被淘汰，如果你不需要线程安全，那么使用HashMap，如果需要线程安全，那么使用ConcurrentHashMap。应该是加锁比较粗暴的原因，性能估计较低。</p><h3 id="hashMap-key和value可以是null么？"><a href="#hashMap-key和value可以是null么？" class="headerlink" title="hashMap key和value可以是null么？"></a>hashMap key和value可以是null么？</h3><p>可以，一般不这么操作</p><h3 id="Hashmap的扩容一定是2-n么？"><a href="#Hashmap的扩容一定是2-n么？" class="headerlink" title="Hashmap的扩容一定是2^n么？"></a>Hashmap的扩容一定是2^n么？</h3><p>HashMap的初始化的数组长度一定是2的n次的，每次扩容仍是原来的2倍的话，就不会破坏这个规律，每次扩容后，原数据都会进行数据迁移，根据二进制的计算，扩容后数据要么在原来位置，要么在【原来位置+扩容长度】，这样就不需要重新hash，效率上更高。</p><h3 id="1-8版本的优化点在哪里？"><a href="#1-8版本的优化点在哪里？" class="headerlink" title="1.8版本的优化点在哪里？"></a>1.8版本的优化点在哪里？</h3><p>resize 扩容优化，不用rehash，快速寻址<br>引入了红黑树，目的是避免单条链表过长而影响查询效率<br>解决了resize时多线程死循环问题，但仍是非线程安全的</p><h3 id="什么时候链表转换为红黑树？什么时候红黑树转换为链表？"><a href="#什么时候链表转换为红黑树？什么时候红黑树转换为链表？" class="headerlink" title="什么时候链表转换为红黑树？什么时候红黑树转换为链表？"></a>什么时候链表转换为红黑树？什么时候红黑树转换为链表？</h3><p>链表长度大于 8 并且 表的长度大于 64 的时候会转化红黑树;<br>链表长度低于6，就把红黑树转回链表;</p><h3 id="平时在使用HashMap时一般使用什么类型的元素作为Key？"><a href="#平时在使用HashMap时一般使用什么类型的元素作为Key？" class="headerlink" title="平时在使用HashMap时一般使用什么类型的元素作为Key？"></a>平时在使用HashMap时一般使用什么类型的元素作为Key？</h3><p>选择Integer，String这种不可变的类型，像对String的一切操作都是新建一个String对象，对新的对象进行拼接分割等，这些类已经很规范的覆写了hashCode()以及equals()方法。作为不可变类天生是线程安全的，</p><h3 id="Hashmap的get和put方法是怎么实现的？"><a href="#Hashmap的get和put方法是怎么实现的？" class="headerlink" title="Hashmap的get和put方法是怎么实现的？"></a>Hashmap的get和put方法是怎么实现的？</h3><p>存储对象时，将 K&#x2F;V 键值传给 put() 方法：</p><ol><li>调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；</li><li>调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；</li><li>(1)如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；(2)如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；(3) 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。</li></ol><p>（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD &#x3D; 8 时，就把链表转换成红黑树）</p><p>获取对象时，将 K 传给 get() 方法：</p><ol><li>调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；</li><li>顺序遍历链表，equals()方法查找相同 Node 链表中 K 值对应的 V 值。</li></ol><p>hashCode 是定位的，存储位置；equals是定性的，比较两者是否相等。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/567114632">为什么HashMap的数组长度一定是2的次幂？</a><br><a href="https://zhuanlan.zhihu.com/p/410319925">2021年大厂必备HashMap夺命连环问！转红黑树的阈值为什么是8？红黑树转链表为什么是6？</a><br><a href="https://www.cnblogs.com/xiaoxi/p/7233201.html">JDK1.8 HashMap源码分析</a><br><a href="https://www.cnblogs.com/better-farther-world2099/p/9258605.html">Java集合：HashMap底层实现和原理</a><br><a href="https://blog.csdn.net/weixin_44141495/article/details/108402128">HashMap 1.7和1.8的区别</a></p><h2 id="什么是不可变类型"><a href="#什么是不可变类型" class="headerlink" title="什么是不可变类型"></a>什么是不可变类型</h2><p>不可变数据类型：当该数据类型对应的变量的值发生了改变，那么它对应的内存地址也发生改变，对于这种数据类型，就称不可变数据类型。即：原有内存地址中的内容不变，为变化后的值分配了新的内存。<br>可变数据类型：当该数据类型对应的变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数据类型，就称之为可变数据类型。可变数据类型改变时实际上更改了内存中的内容。</p><p>样例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> num;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>    t.num = <span class="hljs-number">11</span>;<br>    <br>    <span class="hljs-type">Test</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> t;<br>    t1.num = <span class="hljs-number">111</span>;<br><br>    System.out.println(t.num);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;输出结果是111</p><p>样例2：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test_1</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> i1 = i;<br>    i1 = <span class="hljs-number">10</span>;<br><br>    System.out.<span class="hljs-built_in">println</span>(i);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;输出结果仍然是0</p><p>如上样例1中：<br>t是Test类型，属于可变数据类型。对象t和t1的值其实是一个地址，也可以看成一个指向堆内存中某个对象的指针。让t1&#x3D;t时，实际上也是让t1指向t指向的对象，通过t1改变num的值，也就是改变了堆内存中的对象的值，通过t再调用时，num的值自然也是改变后的结果。</p><p>如上样例2中：<br>虽然i1&#x3D;i的时候，i1和i共用0，但是一旦i1赋值10，此时不是将内存中的0改成10，而是又创建一个10，让i1指向10，而i还是指向0的，所以最后的结果还是0</p><p>参考：<br><a href="https://www.cnblogs.com/yickel/p/14593913.html">Java中的不可变类型</a></p><h2 id="Queue中poll和remove方法的区别是什么？"><a href="#Queue中poll和remove方法的区别是什么？" class="headerlink" title="Queue中poll和remove方法的区别是什么？"></a>Queue中poll和remove方法的区别是什么？</h2><p>队列是一个典型的先进先出（FIFO）的容器。即从容器的一端放入事物，从另一端取出，并且事物放入容器的顺序与取出的顺序是相同的。队列的两种实现方式：LinkedList\PriorityQueue。</p><ol><li><p>offer()和add()的区别<br>add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。可以据此在程序中进行有效的判断！</p></li><li><p>peek()和element()的区别<br>peek()和element()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回null，调用element()方法会抛出NoSuchElementException异常。</p></li><li><p>poll()和remove()的区别<br>poll()和remove()都将移除并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。</p></li></ol><p>参考：<br><a href="https://blog.csdn.net/qq_41026809/article/details/90647569">Java面试题之 Queue 中 poll()和 remove()有什么区别？</a></p><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>Java迭代器（Iterator）是 Java 集合框架中的一种机制，它提供了一种在不暴露集合内部实现的情况下遍历集合元素的方法，可用于迭代 ArrayList 和 HashSet 等集合。</p><p>ArrayList中怎么一边遍历一边删除？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>list1.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><br>list1.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><br><span class="hljs-comment">//1.8之前 使用迭代器删除 可以删除</span><br><br>Iterator&lt;String&gt; iterator = list1.iterator();<br><br><span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br><br>    <span class="hljs-keyword">if</span> (iterator.next().<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;1&quot;</span>))&#123;<br><br>        iterator.<span class="hljs-keyword">remove</span>();<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//-------------------------------------------------</span><br><br>List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>list2.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><br>list2.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><br><span class="hljs-comment">//1.8 版本之后 使用removeIf  可以删除</span><br><br>list2.removeIf(s -&gt; s.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;1&quot;</span>));<span class="hljs-comment">//底层实现就是迭代器</span><br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://mp.weixin.qq.com/s/reWHsPetHA7sAq-SXn-GMA">java面试–集合（collection）</a><br><a href="https://www.runoob.com/java/java-iterator.html">Java Iterator（迭代器）</a></p><h2 id="Treemap和LinkedHashMap有什么作用？其实现的原理是什么？"><a href="#Treemap和LinkedHashMap有什么作用？其实现的原理是什么？" class="headerlink" title="Treemap和LinkedHashMap有什么作用？其实现的原理是什么？"></a>Treemap和LinkedHashMap有什么作用？其实现的原理是什么？</h2><p>TreeMap是基于key排序的Map，LinkedHashMap是保留插入顺序的Map</p><p>LinkedHashMap继承HashMap,在HashMap的基础上将entry做成了双向链表，默认按照插入顺序排序，后插入的排在最后，也可以按照访问进行排序，最少访问的排在前面，另外重写removeEldestEntry可以触发删除最早元素的功能，达成LRU即Least Recently Used的功能。<br>TreeMap基于比较器进行排序，底层为红黑树</p><p>参考：<br><a href="https://www.cnblogs.com/xiaoxi/p/6170590.html">Java集合之LinkedHashMap</a><br><a href="https://www.cnblogs.com/chenssy/p/3746600.html">Java提高篇（二七）—–TreeMap</a><br><a href="https://www.cnblogs.com/coder-lzh/p/10819627.html">LinkedHashMap和hashMap和TreeMap的区别 </a></p><h2 id="HashSet的实现原理有了解？"><a href="#HashSet的实现原理有了解？" class="headerlink" title="HashSet的实现原理有了解？"></a>HashSet的实现原理有了解？</h2><p>基于HashMap实现，底层和HashMap类似，就是没有value而已</p><h2 id="静态内部类和内部类的区别是什么？为什么内部类可以访问外部类？"><a href="#静态内部类和内部类的区别是什么？为什么内部类可以访问外部类？" class="headerlink" title="静态内部类和内部类的区别是什么？为什么内部类可以访问外部类？"></a>静态内部类和内部类的区别是什么？为什么内部类可以访问外部类？</h2><ul><li>内部类</li></ul><ol><li>内部类中的变量和方法不能声明为静态的。</li><li>内部类实例化：B是A的内部类，实例化B：A.B b &#x3D; new A().new B()。</li><li>内部类可以引用外部类的静态或者非静态属性及方法。</li></ol><ul><li>静态内部类</li></ul><ol><li>静态内部类属性和方法可以声明为静态的或者非静态的。</li><li>实例化静态内部类：B是A的静态内部类，A.B b &#x3D; new A.B()。</li><li>静态内部类只能引用外部类的静态的属性及方法。</li></ol><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/61735448">Java面试题—内部类和静态内部类的区别</a></p><h2 id="从安全性上说说java权限关键字private，protected，default，public的区别？"><a href="#从安全性上说说java权限关键字private，protected，default，public的区别？" class="headerlink" title="从安全性上说说java权限关键字private，protected，default，public的区别？"></a>从安全性上说说java权限关键字private，protected，default，public的区别？</h2><table><thead><tr><th></th><th>类内部</th><th>本包</th><th>子类</th><th>外部包</th></tr></thead><tbody><tr><td>public</td><td>y</td><td>y</td><td>y</td><td>y</td></tr><tr><td>protected</td><td>y</td><td>y</td><td>y</td><td>n</td></tr><tr><td>default</td><td>y</td><td>y</td><td>n</td><td>n</td></tr><tr><td>private</td><td>y</td><td>n</td><td>n</td><td>n</td></tr></tbody></table><h2 id="面向对象的概念是什么？Java的多态怎么实现？"><a href="#面向对象的概念是什么？Java的多态怎么实现？" class="headerlink" title="面向对象的概念是什么？Java的多态怎么实现？"></a>面向对象的概念是什么？Java的多态怎么实现？</h2><p>程序中的一切都是由对象构成的。面向对象的三大特征：继承、封装、多态性</p><p>将一个子类申明为它的父类，运行时实际执行子类的方法。</p><h2 id="try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后"><a href="#try-里有一个return语句，那么紧跟在这个try后的finally-里的code会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?"></a>try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?</h2><p>如果finally中也有return，则会直接返回并终止程序，函数栈中的return不会被完成！；<br>如果finally中没有return，则在执行完finally中的代码之后，会将函数栈中的try中的return的内容返回并终止程序；</p><p>参考：<br><a href="https://www.cnblogs.com/xh_Blog/p/6518620.html">try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ">微信公众号:我的IT技术路</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;java基础相关面试题目整理&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="java" scheme="http://soatree.github.io/categories/java/"/>
    
    
    <category term="面试" scheme="http://soatree.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>道德经</title>
    <link href="http://soatree.github.io/2023/01/05/%E9%81%93%E5%BE%B7%E7%BB%8F/"/>
    <id>http://soatree.github.io/2023/01/05/%E9%81%93%E5%BE%B7%E7%BB%8F/</id>
    <published>2023-01-05T14:31:30.000Z</published>
    <updated>2023-08-03T14:13:26.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《道德经》 老子 中国华侨出版社</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>上善若水。水善利万物而不争，处众人之所恶，故几于道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤。</li><li>五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎，令人心发狂，难得之货，令人行妨。是以圣人为腹不为目，故去彼取此。</li><li>企者不立；跨者不行；自见者不明；自是者不彰；自伐者无功；自矜者不长。其在道也，曰：余食赘形。物或恶之，故有道者不处。</li><li>重为轻根，静为躁君。是以君子终日行不离辎重。虽有荣观，燕处超然。奈何万乘之主，而以身轻天下？轻则失根，躁则失君。</li><li>将欲歙之，必固张之；将欲弱之，必固强之；将欲废之，必固兴之；将欲取之，必固与之。是谓微明。柔弱胜刚强。鱼不可脱于渊，国之利器不可以示人。</li><li>名与身孰亲？身与货孰多？得与亡孰病？甚爱必大费；多藏必厚亡。故知足不辱，知止不殆，可以长久。</li><li>反者道之动。弱者道之用。天下万物生于有，有生于无。</li><li>大成若缺，其用不弊。大盈若冲，其用不穷。大直若屈，大巧若拙，大辩若讷。静胜躁，寒胜热。清静为天下正。</li><li>为学日益，为道日损。损之又损，以至于无为。无为而无不为。取天下常以无事，及其有事，不足以取天下。</li><li>其安易持，其未兆易谋。其脆易泮，其微易散。为之于未有，治之于未乱。合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。为者败之，执者失之。是以圣人无为故无败，无执故无失。民之从事，常于几成而败之。慎终如始，则无败事。是以圣人欲不欲，不贵难得之货；学不学，复众人之所过，以辅万物之自然而敢为。</li><li>天下皆谓我：道大，似不肖。夫唯大，故似不肖。若肖，久矣其细也夫！我有三宝，持而保之：一曰慈，二曰俭，三曰不敢为天下先。慈故能勇；俭故能广；不敢为天下先，故能成器长。今舍慈且勇，舍俭且广，舍后且先，死矣！夫慈，以战则胜，以守则固，天将救之，以慈卫之。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>无论顺境逆境，保持一颗平常心，低调做人。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h1&gt;&lt;p&gt;《道德经》 老子 中国华侨出版社&lt;/p&gt;
&lt;h1 id=&quot;摘录&quot;&gt;&lt;a href=&quot;#摘录&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="读书" scheme="http://soatree.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="哲学" scheme="http://soatree.github.io/tags/%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>菜根谭</title>
    <link href="http://soatree.github.io/2023/01/03/%E8%8F%9C%E6%A0%B9%E8%B0%AD/"/>
    <id>http://soatree.github.io/2023/01/03/%E8%8F%9C%E6%A0%B9%E8%B0%AD/</id>
    <published>2023-01-03T13:54:59.000Z</published>
    <updated>2023-08-03T14:13:21.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>《菜根谭》 洪应明 吉林出版集团有限责任公司</p><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>处世让一步为高，退步即进步的张本；待人宽一分是福，利人是利己的根基。</li><li>完名美节，不宜独任，分些与人，可以远害全身；辱行污名，不宜全推，引些归己，可以韬光养德。</li><li>忧勤是美德，太苦则无以适性怡情；澹泊是高风，太枯则无以济人利物。</li><li>澹泊之士，必为浓艳者所疑；检饬之人，多为放肆者所忌。君子处此，故不可稍变其操履，亦不可太露其锋芒！</li><li>善人未能急亲，不宜预扬，恐来谗谮之奸；恶人未能轻去，不宜先发，恐遭媒孽之祸。</li><li>建功立业者，多虚圆之士；偾事失机者，必执拗之人。</li><li>十语九中未必称奇，一语不中则愆尤骈集；十谋九成未必归功，一谋不成则訾议丛兴。君子所以宁默毋躁，宁拙毋巧。</li><li>老来疾病，都是壮时招的；衰后罪孽，都是盛时造的。故持盈履满，君子尤兢兢焉。</li><li>锄奸杜倖，要放他一条去路。若使之一无所容，譬如塞鼠穴者，一切去路都塞尽，则一切好物俱咬破矣。</li><li>事有急之不白者，宽之或自明，毋躁急以速其忿；人有操之不从者，纵之或自化，毋躁切以益其顽。</li><li>恩宜自淡而浓；先浓后淡者，人忘其惠。威宜自严而宽；先宽后严者，人怨其酷。</li><li>忙里要偷闲，须先向闲时讨个把柄；闹中要取静，须先从静处立个主宰。不然未有不因境而迁，随事而靡者。</li><li>闻恶不可就恶，恐为谗夫泄怒；闻善不可即亲，恐引奸人进身。</li><li>不可乘喜而轻诺，不可因醉而生嗔，不可乘快而多事，不可因倦而鲜终。</li><li>今人专求无念，而终不可无。只是前念不滞，后念不迎，但将现在的随缘打发得去，自然渐渐入无。</li><li>不责人小过，不发人阴私，不念人旧恶。三者可以养德，亦可以远害。</li><li>胜私制欲之功，有曰识不早力不易者，有曰识得破忍不过者，盖识是一颗照魔的明珠，力是一把斩魔的慧剑，两不可少也。</li><li>觉人之诈不形于言，受人之侮不动于色，此中有无穷意味，亦有无穷受用。</li><li>损之又损，栽花种竹，尽交还乌有先生；忘无可忘，焚香煮茗，总不问白衣童子。</li><li>无风月花柳不成造化，无情欲嗜好不成心体。只以我转物，不以物役我，则嗜欲莫非天机，尘情即是理境矣。</li><li>忙处不乱性，须闲处心神养得清；死时不动心，须生时事物看得破。</li><li>悠长之趣，不得于酿酽，而得于啜菽饮水；惆恨之怀，不生于枯寂，而是生于品竹调丝。故知浓处味常短，淡中趣独真也。</li><li>知成之必败，则求成之心不必太坚；知生之必死，则保生之道不必过劳。</li></ul><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>嚼得菜根者，百事可做。需要反复品读思考。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息&quot;&gt;&lt;a href=&quot;#信息&quot; class=&quot;headerlink&quot; title=&quot;信息&quot;&gt;&lt;/a&gt;信息&lt;/h1&gt;&lt;p&gt;《菜根谭》 洪应明 吉林出版集团有限责任公司&lt;/p&gt;
&lt;h1 id=&quot;摘录&quot;&gt;&lt;a href=&quot;#摘录&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="读书" scheme="http://soatree.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://soatree.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb学习-MVC</title>
    <link href="http://soatree.github.io/2022/12/31/JavaWeb%E5%AD%A6%E4%B9%A0-MVC/"/>
    <id>http://soatree.github.io/2022/12/31/JavaWeb%E5%AD%A6%E4%B9%A0-MVC/</id>
    <published>2022-12-31T07:21:56.000Z</published>
    <updated>2023-01-14T13:48:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于JavaWeb基础知识进行优化，形成了MVC的开发模式。</p><h1 id="程序结构优化"><a href="#程序结构优化" class="headerlink" title="程序结构优化"></a>程序结构优化</h1><p>教程原来案例中的servlet太多了，希望只有一个servlet，把原来多个servlet的合并成一个，根据参数operation判断用哪个方法并用反射调用，都写到了新servlet的service方法中了。引入dispatcherservlet，作为中心控制器，把原来整合后的servlet都换成controller，不再是servlet了。<br>dispatcherservlet开始加载不同关键字和controller的对应关系，然后根据前端传入的url关键字(servletpath)调用不同controller，然后根据参数operation调用controller中不同的方法。<br>原来controller中的重定向，改为返回重定向的信息String，由dispatcherservlet接收后统一重定向（如果需要重定向的话），参数获取也由dispatcherservlet统一基于反射获取然后传给controller中的方法，不在需要在controller进行参数获取和重定向，controller变成一个普通类。</p><p><img src="/2022/12/31/JavaWeb%E5%AD%A6%E4%B9%A0-MVC/javaweb%E4%BC%98%E5%8C%96%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF.png"></p><p>另外将业务逻辑抽出为Service层，来将Dao中的单精度操作聚合，使web整体层次更清晰。</p><p><img src="/2022/12/31/JavaWeb%E5%AD%A6%E4%B9%A0-MVC/Service%E5%B1%82.png"></p><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>MVC : Model（模型）、View（视图）、Controller（控制器）<br>视图层：用于做数据展示以及和用户交互的一个界面<br>控制层：能够接受客户端的请求，具体的业务功能还是需要借助于模型组件来完成<br>模型层：模型分为很多种：有比较简单的pojo&#x2F;vo(value object)，有业务模型组件，有数据访问层组件<br>    1) pojo&#x2F;vo : 值对象<br>    2) DAO ： 数据访问对象，DAO中的方法都是单精度方法或者称之为细粒度方法。什么叫单精度？一个方法只考虑一个操作，比如添加，那就是insert操作、查询那就是select操作….<br>    3) BO ： 业务对象，BO中的方法属于业务方法，也实际的业务是比较复杂的，因此业务方法的粒度是比较粗的</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>Filter也属于Servlet规范。</p><p>Filter开发步骤：新建类实现Filter接口，然后实现其中的三个方法：init、doFilter、destroy</p><p>配置Filter，可以用注解@WebFilter，也可以使用xml文件 <filter> <filter-mapping></filter-mapping></filter></p><p>Filter在配置时，和servlet一样，也可以配置通配符，例如 @WebFilter(“*.do”)表示拦截所有以.do结尾的请求</p><p>以下是一个Filter的案例，拦截所有以.do结尾的请求，会在处理请求前先打印”helloA”然后等请求处理完之后再打印”helloA2”</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@WebFilter</span>(<span class="hljs-string">&quot;*.do&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Filter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;helloA&quot;</span>);<br>        <span class="hljs-comment">//放行</span><br>        filterChain.doFilter(servletRequest,servletResponse);<br>        System.out.println(<span class="hljs-string">&quot;helloA2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h2><p>监听器分类：</p><ol><li>ServletContextListener - 监听ServletContext对象的创建和销毁的过程</li><li>HttpSessionListener - 监听HttpSession对象的创建和销毁的过程</li><li>ServletRequestListener - 监听ServletRequest对象的创建和销毁的过程</li><li>ServletContextAttributeListener - 监听ServletContext的保存作用域的改动(add,remove,replace)</li><li>HttpSessionAttributeListener - 监听HttpSession的保存作用域的改动(add,remove,replace)</li><li>ServletRequestAttributeListener - 监听ServletRequest的保存作用域的改动(add,remove,replace)</li><li>HttpSessionBindingListener - 监听某个对象在Session域中的创建与移除</li><li>HttpSessionActivationListener - 监听某个对象在Session域中的序列化和反序列化</li></ol><p>监听器举例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServletContextListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServletContextListener</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">contextInitialized</span>(<span class="hljs-params">ServletContextEvent servletContextEvent</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Servlet上下文对象初始化动作被我监听到了....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">contextDestroyed</span>(<span class="hljs-params">ServletContextEvent servletContextEvent</span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Servlet上下文对象销毁动作被我监听到了.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>Cookie是浏览器端的缓存</p><ul><li>设置Cookie的有效时长<br>cookie.setMaxAge(60)  ， 设置cookie的有效时长是60秒</li><li>Cookie的应用：<br>记住用户名和密码十天 setMaxAge(60 * 60 * 24 * 10)<br>十天免登录</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1AS4y177xJ/">尚硅谷javaweb教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;基于JavaWeb基础知识进行优化，形成了MVC的开发模式。&lt;/p&gt;
&lt;h1 id=&quot;程序结构优化&quot;&gt;&lt;a href=&quot;#程序结构优化&quot; c</summary>
      
    
    
    
    <category term="java" scheme="http://soatree.github.io/categories/java/"/>
    
    
    <category term="web" scheme="http://soatree.github.io/tags/web/"/>
    
  </entry>
  
</feed>
