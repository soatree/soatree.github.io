---
title: 八股文-redis
categories:
  - 中间件
tags:
  - 面试
date: 2023-07-26 08:48:28
---

# 前言

整理redis的相关面试题，题目来源微信公众号。

# 题目

## Redis的高性能体现在哪些方面？

1. 纯内存访问
2. 非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间
3. 单线程避免了线程切换和竞态产生的消耗

参考：
《Redis开发与运维》 付磊　张益军 机械工业出版社

## Redis的常见数据类型？底层是怎么实现的？

![redis数据结构](./2023-07-26-八股文-redis/redis数据结构.png)
![redis数据结构内部编码](./2023-07-26-八股文-redis/redis数据结构内部编码.png)

type命令实际返回的就是当前键的数据结构类型，它们分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合），但这些只是Redis对外的数据结构。

实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码。

参考：
《Redis开发与运维》 付磊　张益军 机械工业出版社

## Redis的pipeline机制有了解过？
### 概念

Pipeline（流水线）能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端。

![pipeline](./2023-07-26-八股文-redis/pipeline.png)

```
public void mdel(List<String> keys) {
    Jedis jedis = new Jedis("127.0.0.1");
    // 1)生成pipeline对象
    Pipeline pipeline = jedis.pipelined();
    // 2)pipeline执行命令，注意此时命令并未真正执行
    for (String key : keys) {
        pipeline.del(key);
    }
    // 3)执行命令
    pipeline.sync();
}
```

### 原生批量命令与Pipeline对比

可以使用Pipeline模拟出批量操作的效果，但是在使用时要注意它与原生批量命令的区别，具体包含以下几点：

- 原生批量命令是原子的，Pipeline是非原子的。

- 原生批量命令是一个命令对应多个key，Pipeline支持多个命令。

- 原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。

### 集群pipeline

- 串行IO

```
Map<String, String> serialIOMget(List<String> keys) {
    // 结果集
    Map<String, String> keyValueMap = new HashMap<String, String>();
    // 属于各个节点的key列表,JedisPool要提供基于ip和port的hashcode方法
    Map<JedisPool, List<String>> nodeKeyListMap = new HashMap<JedisPool, List<String>>();
    // 遍历所有的key
    for (String key : keys) {
        // 使用CRC16本地计算每个key的slot
        int slot = JedisClusterCRC16.getSlot(key);
        // 通过jedisCluster本地slot->node映射获取slot对应的node
        JedisPool jedisPool = jedisCluster.getConnectionHandler().getJedisPoolFrom
            Slot(slot);
        // 归档
        if (nodeKeyListMap.containsKey(jedisPool)) {
            nodeKeyListMap.get(jedisPool).add(key);
        } else {
            List<String> list = new ArrayList<String>();
            list.add(key);
            nodeKeyListMap.put(jedisPool, list);
        }
    }
    // 从每个节点上批量获取，这里使用mget也可以使用pipeline
    for (Entry<JedisPool, List<String>> entry : nodeKeyListMap.entrySet()) {
        JedisPool jedisPool = entry.getKey();
       List<String> nodeKeyList = entry.getValue();
        // 列表变为数组
        String[] nodeKeyArray = nodeKeyList.toArray(new String[nodeKeyList.size()]);
        // 批量获取，可以使用mget或者Pipeline
        List<String> nodeValueList = jedisPool.getResource().mget(nodeKeyArray);
        // 归档
        for (int i = 0; i < nodeKeyList.size(); i++) {
            keyValueMap.put(nodeKeyList.get(i), nodeValueList.get(i));
        }
    }
    return keyValueMap;
}
```

- 并行IO

```
Map<String, String> parallelIOMget(List<String> keys) {
    // 结果集
    Map<String, String> keyValueMap = new HashMap<String, String>();
    // 属于各个节点的key列表
    Map<JedisPool, List<String>> nodeKeyListMap = new HashMap<JedisPool, List<String>>();
    ...和前面一样
    // 多线程mget，最终汇总结果，也可pipeline
    for (Entry<JedisPool, List<String>> entry : nodeKeyListMap.entrySet()) {
        // 多线程实现
    }
    return keyValueMap;
}
```

- hash_tag

将多个key强制分配到一个节点上，它的操作时间=1次网络时间+n次命令时间，这里换成pipeline即可

```
List<String> hashTagMget(String[] hashTagKeys) {
    return jedisCluster.mget(hashTagKeys);
}
```

参考：
《Redis开发与运维》 付磊　张益军 机械工业出版社

## 事务

为了保证多条命令组合的原子性，Redis提供了简单的事务功能以及集成Lua脚本来解决这个问题。

### Redis的事务怎么实现？有什么缺点？

- 事务实现

Redis提供了简单的事务功能，将一组需要一起执行的命令放到multi和exec两个命令之间。multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子顺序执行的

```
127.0.0.1:6379> multi
OK
127.0.0.1:6379> sadd user:a:follow user:b
QUEUED
127.0.0.1:6379> sadd user:b:fans user:a
QUEUED
```

可以看到sadd命令此时的返回结果是QUEUED，代表命令并没有真正执行，而是暂时保存在Redis中。如果此时另一个客户端执行sismember user：a：follow user：b返回结果应该为0。

```
127.0.0.1:6379> sismember user:a:follow user:b
(integer) 0
```

只有当exec执行后，用户A关注用户B的行为才算完成，如下所示返回的两个结果对应sadd命令。

```
127.0.0.1:6379> exec
1) (integer) 1
2) (integer) 1
127.0.0.1:6379> sismember user:a:follow user:b
(integer) 1
```

如果要停止事务的执行，可以使用discard命令代替exec命令即可。

命令语法错误将导致事务无法执行；非语法错误将正常执行

watch命令可以提供类似乐观锁的功能，会在exec执行前观察watch 的 key是否发生变化，如果变化则不会执行事务

- 缺点

不支持事务中的回滚特性，同时无法实现命令之间的逻辑关系计算

### Redis结合lua有什么作用？Eval和evalsha的区别？

#### Redis结合lua有什么作用

Lua脚本在Redis中是原子执行的，执行过程中间不会插入其他命令，实现事务功能。

Lua脚本可以帮助开发和运维人员创造出自己定制的命令，并可以将这些命令常驻在Redis内存中，实现复用的效果。

Lua脚本可以将多条命令一次性打包，有效地减少网络开销。

#### Eval和evalsha的区别

- eval

```
eval 脚本内容 key个数 key列表 参数列表
```

```
127.0.0.1:6379> eval 'return "hello " .. KEYS[1] .. ARGV[1]' 1 redis world
"hello redisworld"
```

如果Lua脚本较长，还可以使用redis-cli--eval直接执行文件。eval命令和--eval参数本质是一样的，客户端如果想执行Lua脚本，首先在客户端编写好Lua脚本代码，然后把脚本作为字符串发送给服务端，服务端会将执行结果返回给客户端

![eval](./2023-07-26-八股文-redis/eval.png)

- evalsha

除了使用eval，Redis还提供了evalsha命令来执行Lua脚本。首先要将Lua脚本加载到Redis服务端，得到该脚本的SHA1校验和，evalsha命令使用SHA1作为参数可以直接执行对应Lua脚本，避免每次发送Lua脚本的开销。这样客户端就不需要每次执行脚本内容，而脚本也会常驻在服务端，脚本功能得到了复用

加载脚本：script load命令可以将脚本内容加载到Redis内存中，例如下面将lua_get.lua加载到Redis中，得到SHA1为："7413dc2440db1fea7c0a0bde841fa68eefaf149c"

```
# redis-cli script load "$(cat lua_get.lua)"
"7413dc2440db1fea7c0a0bde841fa68eefaf149c"
```

执行脚本：evalsha的使用方法如下，参数使用SHA1值，执行逻辑和eval一致。

```
evalsha 脚本SHA1值 key个数 key列表 参数列表
```

所以只需要执行如下操作，就可以调用lua_get.lua脚本：

```
127.0.0.1:6379> evalsha 7413dc2440db1fea7c0a0bde841fa68eefaf149c 1 redis world
"hello redisworld"
```

![evalsha](./2023-07-26-八股文-redis/evalsha.png)

参考：
《Redis开发与运维》 付磊　张益军 机械工业出版社

## hyperloglog

HyperLogLog并不是一种新的数据结构（实际类型为字符串类型），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。

HyperLogLog提供了3个命令：pfadd、pfcount、pfmerge

- 添加

pfadd key element [element …]

- 计算独立用户数

pfcount key [key …]

- 合并

pfmerge destkey sourcekey [sourcekey ...]

HyperLogLog内存占用量非常小，但是存在错误率，开发者在进行数据结构选型时只需要确认如下两条即可：

- 只为了计算独立总数，不需要获取单条数据。

- 可以容忍一定误差率，毕竟HyperLogLog在内存的占用量上有很大的优势。

参考：
《Redis开发与运维》 付磊　张益军 机械工业出版社

## 持久化

### RDB

#### 触发机制

RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。

手动触发分别对应save和bgsave命令。save命令已经废弃。bgsave命令使Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束，阻塞只发生在fork阶段，一般时间很短。

除了执行命令手动触发之外，Redis内部还存在自动触发RDB的持久化机制，例如以下场景：
- 使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。
- 如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点，更多细节见6.3节介绍的复制原理。
- 默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。

#### RDB优缺点

RDB的优点：

- RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。
- Redis加载RDB恢复数据远远快于AOF的方式。

RDB的缺点：
- RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。
- Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。

针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。

### AOF

AOF（append only file）持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。开启AOF功能需要设置配置：appendonly yes，默认不开启。

#### AOF的工作流程如下

![AOF工作流程](./2023-07-26-八股文-redis/AOF工作流程.png)

1. 所有的写入命令会追加到aof_buf（缓冲区）中。
2. AOF缓冲区根据对应的策略向硬盘做同步操作。
3. 随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。
4. 当Redis服务器重启时，可以加载AOF文件进行数据恢复。

####  AOF为什么把命令追加到aof_buf中？

Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。

####  Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制

配置为always时，每次写入都要同步AOF文件，在一般的SATA硬盘上，Redis只能支持大约几百TPS写入，显然跟Redis高性能特性背道而驰，不建议配置。

配置为no，由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。

配置为everysec，是建议的同步策略，也是默认配置，做到兼顾性能和数据安全性。理论上只有在系统突然宕机的情况下丢失1秒的数据。

####  重写机制

随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。

重写后的AOF文件为什么可以变小？有如下原因：
- 进程内已经超时的数据不再写入文件。
- 旧的AOF文件含有无效命令，如del key1、hdel key2、srem keys、set a111、set a222等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。
- 多条写命令可以合并为一个，如：lpush list a、lpush list b、lpush list c可以转化为：lpush list a b c。为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。

AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快地被Redis加载。

AOF重写过程可以手动触发和自动触发：
- 手动触发：直接调用bgrewriteaof命令。
- 自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。auto-aof-rewrite-percentage：代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。自动触发时机=aof_current_size>auto-aof-rewrite-min-size&&（aof_current_size-aof_base_size）/aof_base_size>=auto-aof-rewrite-percentage。其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。

#### 重启加载

总体看来优先加载AOF文件，其次加载RDB文件。

![持久化文件加载](./2023-07-26-八股文-redis/持久化文件加载.png)

参考：
《Redis开发与运维》 付磊　张益军 机械工业出版社



2. Redis的主备同步流程？

书 6.3



4. Redis有几种部署模式？重点讲下集群和哨兵机制的实现？

集群放key流程


14. 如果Redis主备切换回发生什么问题？



网络
17. Redis的reactor模型能否介绍下？

实践
8. 常见的Redis的优化方案？
9. 常见的Redis问题？缓存击穿，缓存雪崩，热点key问题解决方案？
10. Redis在集群下做分布式锁有什么优缺点？
12. Redis的过期策略怎么实现的？Redis的淘汰策略是怎么实现的？
16. Redis如果cpu过高，怎么解决？在使用中有出现什么问题？是怎么解决的？
20. 如果有海量的数据，怎么查询某个key是否存在？
21. 如果要统计某一天的页面访问量怎么实现？



# 参考

[微信公众号:我的IT技术路](https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ)