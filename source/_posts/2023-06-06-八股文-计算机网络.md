---
title: 八股文-计算机网络
categories:
  - 计算机网络
tags:
  - 面试
date: 2023-06-06 22:15:48
---


# 前言

整理计算机网络的相关面试题，计算机网络在我看来挺复杂的，想要完全精通应该是不可能的，毕竟后端开发的知识点那么多，不过掌握面试的常考知识点是由必要的。建议系统学习计算机网络课本再进行知识点的整理记忆。

# 题目

## IOS七层协议有了解么？Ip协议是哪层协议？

### 计算机网络体系结构

目前的计算机网络分层结构主流分为三种：OSI协议体系结构、TCP/IP协议体系结构、原理体系结构。OSI协议体系结构是国际标准化组织（ISO）制定的协议体系，但实际较为复杂，缺少商业驱动；TCP/IP是推广最广的标准，是事实国际标准；原理体系结合了OSI和TCP/IP的优势，将网络分成了5层。

![计网体系结构](./2023-06-06-八股文-计算机网络/计网体系结构.png)

### 原理体系分层
- 物理层：物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流;
- 数据链路层：数据链路层考虑同一个局域网中的点对点传输（PPP协议）和局域网内的广播传输（以太网、wifi等）；
- 网络层：网络层考虑在整个互联的网络中两个主机之间的通信，一个主机的信息需要经过若干路由器传送到目标主机。网络层最核心的功能是分组转发和路由选择。核心协议为网际协议IP，配合协议为地址解析协议（AddressResolutionProtocol，ARP）、逆地址解析协议（ReverseAddressResolutionProtocol，RARP）、网际控制报文协议（InternetControlMessageProtocol，ICMP）、网际组管理协议（InternetGroupManagementProtocol，IGMP）。
- 运输层：如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。它属于面向通信部分的最高层，同时也是用户功能中的最低层。根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP。
- 应用层：定义运行在不同端系统上的应用进程间为实现特定应用而互相通信的规则。

![应用层协议](./2023-06-06-八股文-计算机网络/应用层协议.png)

### IP协议是哪层协议

网络层

参考：
《计算机网络教程》 谢钧，谢希仁 人民邮电出版社


## TCP和UDP的区别

因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP。

### UDP

UDP在传送数据之前不需要先建立连接；

远地主机的运输层在收到UDP报文后，不需要给出任何确认，不提供可靠交付；

UDP支持一对一、一对多、多对一和多对多的交互通信。

UDP是面向报文的。这就是说，UDP对应用程序交下来的报文不再划分为若干个分组来发送，也不把收到的若干个报文合并后再交付给应用程序。应用程序交给UDP一个报文，UDP就发送这个报文；而UDP收到一个报文，就把它交付给应用程序。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部相对太大，这也降低了IP层的效率；

UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很多的实时应用（如IP电话、实时视频会议等）要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延。UDP正好适合这种要求；

### TCP

TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接；

提供可靠交付(通过TCP连接传送的数据无差错、不丢失、不重复，并且按序到达)的服务，因此需要提供如确认、流量控制、拥塞控制、计时器及连接管理等功能；

TCP不提供广播或多播服务。每一条TCP连接只能有两端点，即每一条TCP连接只能是点对点的（一对一）。TCP连接唯一地被通信两端的端点所确定，而两个端点分别由二元组（IP地址、端口号）唯一标识，即一条TCP连接由两个套接字（socket）地址标识。与UDP的端口队列不同的是，TCP的发送缓存和接收缓存都是分配给一个连接的，而不是一个端口。

面向字节流。TCP中的“流”（stream）指的是流入到进程或从进程流出的字节序列；

TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。

参考：
《计算机网络教程》 谢钧，谢希仁 人民邮电出版社

## TCP三次握手、四次挥手

### 三次握手

设主机B中运行TCP的服务器进程，它先发出一个被动打开（passiveopen）命令，准备接受客户进程的连接请求。然后服务器进程就处于“听”（listen）的状态，不断检测是否有客户进程要发起连接请求。如有，即做出响应。设客户进程运行在主机A中。它先向其TCP发出主动打开（activeopen）命令，表明要向某个IP地址的某个端口建立运输层连接。主机A的TCP向主机B的TCP发出连接请求报文段，其首部中的同步位SYN应置1，同时选择一个序号seq=x，这表明下一个报文段的第一个数据字节的序号是x+1。主机B的TCP收到连接请求报文段后，如同意，则发回连接请求确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个序号seq=y。主机A的TCP收到B接受连接请求的确认后，还要向B给出确认，其ACK置1，确认号ack=y+1，而自己的序号seq=x+1。TCP的标准规定，SYN=1的报文段（例如，A发送的第一个报文段）不能携带数据，但要消耗掉一个序号。因此A发送的第二个报文段的序号应当是第一个报文段的序号加1（虽然在第一个报文段中并没有数据）。注意，A发送的第二个报文段中SYN是0而不是1，ACK位必须为1。该报文段是对B的同步报文段的确认，但是一个普通报文段，可携带数据。若该报文段不携带数据，则按照TCP的规定，确认报文段不消耗序号。运行客户进程的主机A的TCP通知上层应用进程，连接已经建立。当运行服务器进程的主机B的TCP收到主机A的确认后，会通知其上层应用进程，连接已经建立。

![三次握手](./2023-06-06-八股文-计算机网络/三次握手.png)

### 为何要三次握手

这主要是为了防止已失效的连接请求报文段突然又传送到了主机B，因而产生错误。

所谓“已失效的连接请求报文段”是这样产生的。考虑这样一种情况。主机A发出连接请求，但因连接请求报文丢失而未收到确认。主机A于是再重传一次。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。主机A共发送了两个连接请求报文段，其中的第二个到达了主机B。现

假定出现另一种情况，即主机A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点滞留的时间太长，以致延误到在这次的连接释放以后才传送到主机B。本来这是一个已经失效的报文段。但主机B收到此失效的连接请求报文段后，就误认为是主机A又发出一次新的连接请求。于是就向主机A发出确认报文段，同意建立连接。主机A由于并没有要求建立连接，因此不会理睬主机B的确认，也不会向主机B发送数据。但主机B却以为运输连接就这样建立了，并一直等待主机A发来数据。主机B的许多资源就这样白白浪费了。

采用三次握手的办法可以防止上述现象的发生。例如，在刚才的情况下，主机A不会向主机B的确认发出确认。主机B收不到确认，连接就建立不起来。

### 四次挥手

主机A的应用进程先向其TCP发出连接释放请求，并且不再发送数据。TCP通知对方要释放从A到B这个方向的连接，把发往主机B的报文段首部的FIN置1，其序号seq=u。由于FIN报文段要消耗一个序号，因此序号u等于A前面已传送过的数据的最后一个字节的序号加1。主机B的TCP收到释放连接通知后即发出确认，确认号是ack=u+1，而这个报文段自己的序号假定为v（v等于B前面已传送过的数据的最后一个字节的序号加1）。主机B的TCP这时应通知高层应用进程。这样，从A到B的连接就释放了，连接处于半关闭（half-close）状态，相当于主机A向主机B说：“我已经没有数据要发送了。但你如果还发送数据，我仍可以接收。”此后，主机B不再接收主机A发来的数据。但若主机B还有一些数据要发往主机A，则可以继续发送（这种情况很少）。主机A只要正确收到数据，仍应向主机B发送确认。若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须使FIN=1，并使其序号仍为v（因为前面发送的确认报文段不消耗序号），还必须重复上次已发送过的确认号ack=u+1。主机A必须对此发出确认，把ACK置1，确认号ack=v+1，而自己的序号是seq=u+1（因为根据TCP标准，前面发送过的FIN报文段要消耗一个序号）。这样才把从B到A的反方向连接释放掉。但此时，主机A的TCP并不能马上释放整个连接，还要再等待一个超时时间才能将整个连接释放。因为主机A的确认有可能丢失，这时B会重传FIN报文段。在这段超时时间内，若A又收到B重传的FIN报文段，A需要再次进行确认。收到A的最后确认，B才能最终将整个连接释放。若等待的这段超时时间内没有收到B的FIN报文段，主机A的TCP则向其应用进程报告，整个连接已经全部释放。

![四次挥手](./2023-06-06-八股文-计算机网络/四次挥手.png)

### 为何要四次挥手

因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

参考：
《计算机网络教程》 谢钧，谢希仁 人民邮电出版社
[TCP连接状态详解及TIME_WAIT过多的解决方法](https://www.cnblogs.com/softidea/p/5741192.html)



# 参考

[微信公众号:我的IT技术路](https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ)
