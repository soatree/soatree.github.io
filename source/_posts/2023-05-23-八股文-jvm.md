---
title: 八股文--jvm
categories:
  - java
tags:
  - 面试
date: 2023-05-23 21:36:37
---

# 前言

jvm相关面试题目整理

# 题目

## Java创建一个对象的方法有几种？

1. 使用new关键字
2. 反射
    (1)使用Class类的newInstance方法
    ```
    Employee emp2 = (Employee) Class.forName("org.programming.mitra.exercises.Employee").newInstance();
    ```
    或者(目前Class.newInstance()这种方法因为效率问题已经被标记@Deprecated)
    ```
    Employee emp2 = Employee.class.newInstance();
    ```
    (2)使用Constructor类的newInstance方法
    ```
    Constructor<Employee> constructor = Employee.class.getConstructor();
    Employee emp3 = constructor.newInstance();
    ```
3. clone
    类需要先实现Cloneable接口并实现其定义的clone方法。
    ```
    Employee emp4 = (Employee) emp3.clone();
    ```
4. 反序列化
    需要让类实现Serializable接口
    ```
    ObjectInputStream in = new ObjectInputStream(new FileInputStream("data.obj"));
    Employee emp5 = (Employee) in.readObject();
    ```

参考:
[Java中创建对象的5种方式](https://www.cnblogs.com/wxd0108/p/5685817.html)


## JVM 的内存模型描述一下？

### 程序计数器

线程私有。可以看作是当前线程做执行的字节码的行号指示器。此内存区域是唯一一个在《JVM规范》中没有规定任何outOfMemoryError情况的区域。

### 虚拟机栈

线程私有。虚拟机栈描述的是java方法执行的线程内存模型：每个方法执行时，jvm会同步创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法被调用直到执行完毕的过程对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
如果线程请求的栈深度超过了虚拟机允许的深度时会抛出StackOverflowError异常；如果jvm栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常（HopSpot不允许栈空间扩展，只有在申请的时候空间不足会抛出该异常，在运行的时候不会出现该异常）。

### 本地方法栈

线程私有。和虚拟机栈类似，只不过本地方法栈服务于本地方法（native方法）。也会抛出StackOverflowError异常和OutOfMemoryError异常。
当堆内存超过上限时会抛出OutOfMemoryError异常。

### 堆

线程共享。几乎所有的对象实例及数组都分配在java堆上。

### 方法区

线程共享。用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
jdk8以前，Hotspot设计团队把收集器的分代设计扩展至方法区或者说用永久代实现了方法区，所以有的人会认为方法区是永久代，实际上是不严谨的。jdk8将方法区采用本地内存来实现，这个空间叫做元空间（meta-space），方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。
运行时常量池是方法去的一部分。Class文件中除了有类版本、字段、方法、接口等信息的描述外，还有一项信息是常量池表，用于存放编译期间生成的各种字面量和符号引用，常量池表在类加载后存放到方法区的运行时常量池中。运行时常量池一般除了保存class文件中描述的符号引用外，还会把符号引用翻译出来的直接引用也存储在运行时常量池中。
另外运行时常量池具备动态性，处理类加载时导入的常量外，可以在程序运行中加入新的常量。常量池无法再申请内存的时候会抛出OutOfMemoryError异常。

### 直接内存
直接内存不是JVM运行时数据区的一部分，也不是《规范》中定义的内存区域，但是这部分可能被频繁使用，而且也会导致OutOfMemoryError异常。一般为NIO使用。

参考：
[jvm运行时数据区域](https://www.cnblogs.com/lllliuxiaoxia/p/15785650.html)

## 什么情况下会发生堆溢出？什么情况下会发生栈溢出？

## JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor？

## JVM 是怎么从新生代到老年代？一个完整的GC流程是怎样的？

## 简述一下垃圾回收器？说下各自的优缺点？有了解过cms和G1么？能详细说明一下么？

## 简述下垃圾回收算法？为什么新生代使用复制算法？

## 简述一下类加载过程，重点说明一下双亲委派模型，怎么破坏双亲委派模型？Tomat是怎么破坏的呢？

## 说说你了解的jvm参数和其作用？

## Java的四种引用有了解么？引用队列怎么使用？作用是什么？

## 怎么打出一个线程的堆栈信息？如果内存过高怎么分析？如果cpu过高怎么定位？

# 参考

[微信公众号:我的IT技术路](https://mp.weixin.qq.com/s/54_bMeUwjxk-8DHa90heNQ)

